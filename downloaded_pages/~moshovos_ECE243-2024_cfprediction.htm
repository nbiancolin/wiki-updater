<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:m="http://schemas.microsoft.com/office/2004/12/omml"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 14">
<meta name=Originator content="Microsoft Word 14">
<link rel=File-List href="cfprediction_files/filelist.xml">
<link rel=Edit-Time-Data href="cfprediction_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>pipeliining</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>bongo</o:Author>
  <o:LastAuthor>bongo</o:LastAuthor>
  <o:Revision>30</o:Revision>
  <o:TotalTime>1084</o:TotalTime>
  <o:Created>2013-10-24T13:25:00Z</o:Created>
  <o:LastSaved>2013-11-08T00:01:00Z</o:LastSaved>
  <o:Pages>9</o:Pages>
  <o:Words>5074</o:Words>
  <o:Characters>28928</o:Characters>
  <o:Lines>241</o:Lines>
  <o:Paragraphs>67</o:Paragraphs>
  <o:CharactersWithSpaces>33935</o:CharactersWithSpaces>
  <o:Version>14.00</o:Version>
 </o:DocumentProperties>
 <o:OfficeDocumentSettings>
  <o:AllowPNG/>
 </o:OfficeDocumentSettings>
</xml><![endif]-->
<link rel=themeData href="cfprediction_files/themedata.thmx">
<link rel=colorSchemeMapping href="cfprediction_files/colorschememapping.xml">
<!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>110</w:Zoom>
  <w:SpellingState>Clean</w:SpellingState>
  <w:GrammarState>Clean</w:GrammarState>
  <w:TrackMoves>false</w:TrackMoves>
  <w:TrackFormatting/>
  <w:PunctuationKerning/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DoNotPromoteQF/>
  <w:LidThemeOther>EN-US</w:LidThemeOther>
  <w:LidThemeAsian>X-NONE</w:LidThemeAsian>
  <w:LidThemeComplexScript>X-NONE</w:LidThemeComplexScript>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
   <w:DontGrowAutofit/>
   <w:SplitPgBreakAndParaMark/>
   <w:EnableOpenTypeKerning/>
   <w:DontFlipMirrorIndents/>
   <w:OverrideTableStyleHps/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
  <m:mathPr>
   <m:mathFont m:val="Cambria Math"/>
   <m:brkBin m:val="before"/>
   <m:brkBinSub m:val="&#45;-"/>
   <m:smallFrac m:val="off"/>
   <m:dispDef/>
   <m:lMargin m:val="0"/>
   <m:rMargin m:val="0"/>
   <m:defJc m:val="centerGroup"/>
   <m:wrapIndent m:val="1440"/>
   <m:intLim m:val="subSup"/>
   <m:naryLim m:val="undOvr"/>
  </m:mathPr></w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" DefUnhideWhenUsed="true"
  DefSemiHidden="true" DefQFormat="false" DefPriority="99"
  LatentStyleCount="267">
  <w:LsdException Locked="false" Priority="0" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Normal"/>
  <w:LsdException Locked="false" Priority="9" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="heading 1"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 2"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 3"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 4"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 5"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 6"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 7"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 8"/>
  <w:LsdException Locked="false" Priority="9" QFormat="true" Name="heading 9"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 1"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 2"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 3"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 4"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 5"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 6"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 7"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 8"/>
  <w:LsdException Locked="false" Priority="39" Name="toc 9"/>
  <w:LsdException Locked="false" Priority="35" QFormat="true" Name="caption"/>
  <w:LsdException Locked="false" Priority="10" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Title"/>
  <w:LsdException Locked="false" Priority="1" Name="Default Paragraph Font"/>
  <w:LsdException Locked="false" Priority="11" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Subtitle"/>
  <w:LsdException Locked="false" Priority="22" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Strong"/>
  <w:LsdException Locked="false" Priority="20" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Emphasis"/>
  <w:LsdException Locked="false" Priority="0" SemiHidden="false"
   UnhideWhenUsed="false" Name="Table Grid"/>
  <w:LsdException Locked="false" UnhideWhenUsed="false" Name="Placeholder Text"/>
  <w:LsdException Locked="false" Priority="1" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="No Spacing"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 1"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 1"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 1"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 1"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 1"/>
  <w:LsdException Locked="false" UnhideWhenUsed="false" Name="Revision"/>
  <w:LsdException Locked="false" Priority="34" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="List Paragraph"/>
  <w:LsdException Locked="false" Priority="29" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Quote"/>
  <w:LsdException Locked="false" Priority="30" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Intense Quote"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 1"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 1"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 1"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 1"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 1"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 1"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 2"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 2"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 2"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 2"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 2"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 2"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 2"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 2"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 3"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 3"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 3"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 3"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 3"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 3"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 3"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 3"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 4"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 4"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 4"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 4"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 4"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 4"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 4"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 4"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 5"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 5"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 5"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 5"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 5"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 5"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 5"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 5"/>
  <w:LsdException Locked="false" Priority="60" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Shading Accent 6"/>
  <w:LsdException Locked="false" Priority="61" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light List Accent 6"/>
  <w:LsdException Locked="false" Priority="62" SemiHidden="false"
   UnhideWhenUsed="false" Name="Light Grid Accent 6"/>
  <w:LsdException Locked="false" Priority="63" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="64" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Shading 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="65" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="66" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium List 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="67" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="68" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="69" SemiHidden="false"
   UnhideWhenUsed="false" Name="Medium Grid 3 Accent 6"/>
  <w:LsdException Locked="false" Priority="70" SemiHidden="false"
   UnhideWhenUsed="false" Name="Dark List Accent 6"/>
  <w:LsdException Locked="false" Priority="71" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Shading Accent 6"/>
  <w:LsdException Locked="false" Priority="72" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful List Accent 6"/>
  <w:LsdException Locked="false" Priority="73" SemiHidden="false"
   UnhideWhenUsed="false" Name="Colorful Grid Accent 6"/>
  <w:LsdException Locked="false" Priority="19" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Subtle Emphasis"/>
  <w:LsdException Locked="false" Priority="21" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Intense Emphasis"/>
  <w:LsdException Locked="false" Priority="31" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Subtle Reference"/>
  <w:LsdException Locked="false" Priority="32" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Intense Reference"/>
  <w:LsdException Locked="false" Priority="33" SemiHidden="false"
   UnhideWhenUsed="false" QFormat="true" Name="Book Title"/>
  <w:LsdException Locked="false" Priority="37" Name="Bibliography"/>
  <w:LsdException Locked="false" Priority="39" QFormat="true" Name="TOC Heading"/>
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:Batang;
	panose-1:2 3 6 0 0 1 1 1 1 1;
	mso-font-alt:\BC14\D0D5;
	mso-font-charset:129;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1342176593 1775729915 48 0 524447 0;}
@font-face
	{font-family:Batang;
	panose-1:2 3 6 0 0 1 1 1 1 1;
	mso-font-alt:\BC14\D0D5;
	mso-font-charset:129;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1342176593 1775729915 48 0 524447 0;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:-536870145 1073786111 1 0 415 0;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:-520081665 -1073717157 41 0 66047 0;}
@font-face
	{font-family:"\@Batang";
	panose-1:2 3 6 0 0 1 1 1 1 1;
	mso-font-charset:129;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1342176593 1775729915 48 0 524447 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:0in;
	line-height:115%;
	mso-pagination:widow-orphan;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	mso-ascii-font-family:Calibri;
	mso-ascii-theme-font:minor-latin;
	mso-fareast-font-family:Calibri;
	mso-fareast-theme-font:minor-latin;
	mso-hansi-font-family:Calibri;
	mso-hansi-theme-font:minor-latin;
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-theme-font:minor-bidi;}
a:link, span.MsoHyperlink
	{mso-style-noshow:yes;
	mso-style-priority:99;
	color:blue;
	mso-themecolor:hyperlink;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{mso-style-noshow:yes;
	mso-style-priority:99;
	color:purple;
	mso-themecolor:followedhyperlink;
	text-decoration:underline;
	text-underline:single;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{mso-style-priority:99;
	mso-style-link:"Plain Text Char";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:Batang;}
p
	{mso-style-noshow:yes;
	mso-style-priority:99;
	mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";
	mso-fareast-font-family:"Times New Roman";}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-link:"Balloon Text Char";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:8.0pt;
	font-family:"Tahoma","sans-serif";
	mso-fareast-font-family:Calibri;
	mso-fareast-theme-font:minor-latin;}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{mso-style-noshow:yes;
	mso-style-priority:34;
	mso-style-unhide:no;
	mso-style-qformat:yes;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	mso-add-space:auto;
	line-height:115%;
	mso-pagination:widow-orphan;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	mso-ascii-font-family:Calibri;
	mso-ascii-theme-font:minor-latin;
	mso-fareast-font-family:Calibri;
	mso-fareast-theme-font:minor-latin;
	mso-hansi-font-family:Calibri;
	mso-hansi-theme-font:minor-latin;
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-theme-font:minor-bidi;}
p.MsoListParagraphCxSpFirst, li.MsoListParagraphCxSpFirst, div.MsoListParagraphCxSpFirst
	{mso-style-noshow:yes;
	mso-style-priority:34;
	mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-type:export-only;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-add-space:auto;
	line-height:115%;
	mso-pagination:widow-orphan;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	mso-ascii-font-family:Calibri;
	mso-ascii-theme-font:minor-latin;
	mso-fareast-font-family:Calibri;
	mso-fareast-theme-font:minor-latin;
	mso-hansi-font-family:Calibri;
	mso-hansi-theme-font:minor-latin;
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-theme-font:minor-bidi;}
p.MsoListParagraphCxSpMiddle, li.MsoListParagraphCxSpMiddle, div.MsoListParagraphCxSpMiddle
	{mso-style-noshow:yes;
	mso-style-priority:34;
	mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-type:export-only;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-add-space:auto;
	line-height:115%;
	mso-pagination:widow-orphan;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	mso-ascii-font-family:Calibri;
	mso-ascii-theme-font:minor-latin;
	mso-fareast-font-family:Calibri;
	mso-fareast-theme-font:minor-latin;
	mso-hansi-font-family:Calibri;
	mso-hansi-theme-font:minor-latin;
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-theme-font:minor-bidi;}
p.MsoListParagraphCxSpLast, li.MsoListParagraphCxSpLast, div.MsoListParagraphCxSpLast
	{mso-style-noshow:yes;
	mso-style-priority:34;
	mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-type:export-only;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:10.0pt;
	margin-left:.5in;
	mso-add-space:auto;
	line-height:115%;
	mso-pagination:widow-orphan;
	font-size:11.0pt;
	font-family:"Calibri","sans-serif";
	mso-ascii-font-family:Calibri;
	mso-ascii-theme-font:minor-latin;
	mso-fareast-font-family:Calibri;
	mso-fareast-theme-font:minor-latin;
	mso-hansi-font-family:Calibri;
	mso-hansi-theme-font:minor-latin;
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-theme-font:minor-bidi;}
span.PlainTextChar
	{mso-style-name:"Plain Text Char";
	mso-style-priority:99;
	mso-style-unhide:no;
	mso-style-locked:yes;
	mso-style-link:"Plain Text";
	mso-ansi-font-size:10.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Courier New";
	mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:Batang;
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";}
span.BalloonTextChar
	{mso-style-name:"Balloon Text Char";
	mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-unhide:no;
	mso-style-locked:yes;
	mso-style-link:"Balloon Text";
	mso-ansi-font-size:8.0pt;
	mso-bidi-font-size:8.0pt;
	font-family:"Tahoma","sans-serif";
	mso-ascii-font-family:Tahoma;
	mso-hansi-font-family:Tahoma;
	mso-bidi-font-family:Tahoma;}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
.MsoChpDefault
	{mso-style-type:export-only;
	mso-default-props:yes;
	font-size:10.0pt;
	mso-ansi-font-size:10.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Calibri","sans-serif";
	mso-ascii-font-family:Calibri;
	mso-ascii-theme-font:minor-latin;
	mso-fareast-font-family:Calibri;
	mso-fareast-theme-font:minor-latin;
	mso-hansi-font-family:Calibri;
	mso-hansi-theme-font:minor-latin;
	mso-bidi-font-family:"Times New Roman";
	mso-bidi-theme-font:minor-bidi;}
@page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 1.0in 1.0in 1.0in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 @list l0
	{mso-list-id:18551856;
	mso-list-type:hybrid;
	mso-list-template-ids:336361860 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l0:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l0:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l0:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l0:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l1
	{mso-list-id:186065645;
	mso-list-type:hybrid;
	mso-list-template-ids:-1079352764 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l1:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l1:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l1:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l1:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l1:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l1:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l1:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l1:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l1:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l2
	{mso-list-id:205915032;
	mso-list-type:hybrid;
	mso-list-template-ids:1764419072 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l2:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l2:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l2:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l2:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l2:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l2:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l2:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l2:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l2:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l3
	{mso-list-id:369652921;
	mso-list-type:hybrid;
	mso-list-template-ids:1523746402 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l3:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l3:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l3:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l3:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l3:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l3:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l3:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l3:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l3:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l4
	{mso-list-id:709378100;
	mso-list-type:hybrid;
	mso-list-template-ids:-493982 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l4:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l4:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l4:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l4:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l4:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l4:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l4:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l4:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l4:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l5
	{mso-list-id:981352977;
	mso-list-type:hybrid;
	mso-list-template-ids:1229591722 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l5:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l5:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l5:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l5:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l5:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l5:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l5:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l5:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l5:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l6
	{mso-list-id:1088766560;
	mso-list-type:hybrid;
	mso-list-template-ids:1135540244 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l6:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l6:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l6:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l6:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l6:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l6:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l6:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l6:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l6:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l7
	{mso-list-id:1207984971;
	mso-list-type:hybrid;
	mso-list-template-ids:-1140950778 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l7:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l7:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l7:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l7:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l7:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l7:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l7:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l7:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l7:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l8
	{mso-list-id:1474102295;
	mso-list-type:hybrid;
	mso-list-template-ids:-1755120562 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l8:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l8:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l8:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l8:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l8:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l8:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l8:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l8:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l8:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l9
	{mso-list-id:1505245714;
	mso-list-type:hybrid;
	mso-list-template-ids:1863870616 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l9:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l9:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l9:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l9:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l9:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l9:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l9:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l9:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l9:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l10
	{mso-list-id:1580288319;
	mso-list-type:hybrid;
	mso-list-template-ids:-1982532632 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l10:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l10:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l10:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l10:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l10:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l10:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l10:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l10:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l10:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l11
	{mso-list-id:1699308988;
	mso-list-type:hybrid;
	mso-list-template-ids:-1551585988 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l11:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l11:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l11:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l11:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l11:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l11:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l11:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l11:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l11:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l12
	{mso-list-id:1893536695;
	mso-list-type:hybrid;
	mso-list-template-ids:1157035762 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l12:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l12:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l12:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l12:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l12:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l12:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l12:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l12:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l12:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l13
	{mso-list-id:2034063530;
	mso-list-type:hybrid;
	mso-list-template-ids:-158840178 67698703 67698713 67698715 67698703 67698713 67698715 67698703 67698713 67698715;}
@list l13:level1
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l13:level2
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l13:level3
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l13:level4
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l13:level5
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l13:level6
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
@list l13:level7
	{mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l13:level8
	{mso-level-number-format:alpha-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l13:level9
	{mso-level-number-format:roman-lower;
	mso-level-tab-stop:none;
	mso-level-number-position:right;
	text-indent:-9.0pt;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Calibri","sans-serif";
	mso-ascii-font-family:Calibri;
	mso-ascii-theme-font:minor-latin;
	mso-hansi-font-family:Calibri;
	mso-hansi-theme-font:minor-latin;}
table.MsoTableGrid
	{mso-style-name:"Table Grid";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-unhide:no;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman","serif";
	mso-fareast-font-family:"Times New Roman";}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="1026"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>

<div class=WordSection1>

<p class=MsoNormal>Computer Organization<br>
Andreas <span class=SpellE>Moshovos</span><br>
FALL 2013</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Control Flow and
Pipelining<o:p></o:p></b></p>

<p class=MsoNormal>We will be focusing on the way control flow (i.e., the
change in the value of PC) interacts with pipelining for this note. However,
the concepts described here apply to any processor and architecture that
attempts to overlap the execution of instructions that follow a control flow
instruction (such as a branch or jump or call) with that instruction. This <span
class=GramE>includes,</span> superscalar and OOO processors. <span
style='mso-spacerun:yes'> </span>Moreover, we will be assuming a standard
5-stage pipeline with Fetch, Decode, Execute, Memory, and <span class=SpellE>Writeback</span>
stages and we will be assuming the NIOS II instruction set.</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>The Problem:<o:p></o:p></b></p>

<p class=MsoNormal>As we have seen, a pipelined processor will attempt to fetch
a new instruction every cycle. To do so, it needs to determine what <span
class=GramE>is the next value</span> for the PC. Unfortunately, given an
instruction A the decision as to where exactly is the next instruction cannot
be taken with certainty while A is being fetched. In particular, we need to see
A to first decide whether this is a control flow instruction or not. Then, in
the latter case, we need to execute A to determine where the next instruction
is. If A is not a control flow instruction, the next PC value is PC + 4 in NIOS
II. In a typical 5-stage pipeline, that decision can be taken at the following
stages:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in;mso-list:l3 level1 lfo21'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>In stage 2 Decode for all non-control flow
instructions.</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in;mso-list:l3 level1 lfo21'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>In stage 3 Execute for all control flow
instructions such as branches, etc.</p>

<p class=MsoNormal>As a result, fetch can be directed accordingly in following
cycle after the decision is taken. The following diagrams show how a pipeline
would work if it had to wait to determine for sure where <span class=GramE>is
the next instruction to fetch</span>:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="Picture_x0020_53" o:spid="_x0000_i1045" type="#_x0000_t75"
 style='width:494.25pt;height:230.25pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image001.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=659 height=307
src="cfprediction_files/image002.png" v:shapes="Picture_x0020_53"><![endif]></span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Execution Timeline
for non-control flow instructions: Once I1 is fetched in <span class=GramE>C1,</span>
the pipeline stalls one cycle (C2) to decode the instruction. As long as the instruction
is not a control-flow one, the pipeline can direct fetch at the beginning of
cycle 3 (C3).<o:p></o:p></b></p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_55" o:spid="_x0000_i1044" type="#_x0000_t75" style='width:492.75pt;
 height:225.75pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image003.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=657 height=301
src="cfprediction_files/image004.png" v:shapes="Picture_x0020_55"><![endif]></span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Execution Timeline
for control flow instructions: Once I1 is fetched in <span class=GramE>C1,</span>
the pipeline stalls one cycle (C2) to decode the instruction. Then it realizes that
this is a control flow instruction (<span class=SpellE>e.g</span>, a <span
class=SpellE>beq</span>, <span class=SpellE>jmp</span>, call, etc.) and hence
it has to wait for one more clock cycle for the instruction to execute. So, the
pipeline stalls for one more cycle (C3) while the control flow instruction executes
(stage EXEC). At the beginning of cycle 4 (C4) fetch is redirected to the
appropriate PC value and fetching resumes. <o:p></o:p></b></p>

<p class=MsoNormal>Waiting to determine where to fetch the next instruction
induces stalls in the pipeline. In particular, one cycle stalls are induced for
all but control flow instructions, and two cycle stalls are induced for control
flow instructions. </p>

<p class=MsoNormal>As we have seen, it is relatively easy to avoid some of the
stalls if the pipeline instead guesses what would be the next PC value. Given
the current PC the pipeline can easily calculate PC+4 while fetching the
current instruction. PC+4 in NIOS II <span class=GramE>is</span> the PC of the
next in memory instruction. This will be the correct next value for the PC in
two cases:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in;mso-list:l9 level1 lfo22'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>The current instruction is not a control flow
one (e.g., not a branch, <span class=SpellE>jmp</span>, etc.)</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in;mso-list:l9 level1 lfo22'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>The current instruction is a control flow
instruction which is not taken (e.g., <span class=SpellE>bne</span> r0, r0,
somewhere)</p>

<p class=MsoNormal>This is a straightforward form of control flow prediction or
branch prediction coupled with speculative execution. There are two possible
execution scenarios:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_56" o:spid="_x0000_i1043" type="#_x0000_t75" style='width:482.25pt;
 height:232.5pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image005.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=643 height=310
src="cfprediction_files/image006.png" v:shapes="Picture_x0020_56"><![endif]></span><span
style='mso-spacerun:yes'> </span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Scenario 1: The fetch
stage predicts that the next PC will be PC + 4. If the instruction is not a
control flow one that prediction is validated during C2 and becomes available
in C3. If this is a control flow instruction and proves not taken, the actual
next PC is calculated in C3 during the EXEC stage, and becomes available in C4.
Instructions I2 and I3 are both fetched speculatively in cycles C2 and C3, and
instruction I2 is decoded speculatively in cycle C3. No stalls are needed and
the pipeline can retire one instruction per cycle.<o:p></o:p></b></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape id="Picture_x0020_57"
 o:spid="_x0000_i1042" type="#_x0000_t75" style='width:478.5pt;height:237.75pt;
 visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image007.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=638 height=317
src="cfprediction_files/image008.png" v:shapes="Picture_x0020_57"><![endif]></span><o:p></o:p></b></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Scenario 2: A branch
is fetched in C1 and the fetch stage predicts PC + 4 as the next PC. In cycle
C2 instruction I2 is <span class=GramE>fetched,</span> and in cycle C3
instruction I2 is decoded and instruction I3 is fetched while the branch
executes and determines that the current execution path is wrong. In cycle 4,
instructions I2 and I3 are squashed inducing two bubbles in the pipeline while
the fetch stage is redirected to I4, the correct next instruction after I1.<o:p></o:p></b></p>

<p class=MsoNormal>Since 1 in 5 instructions is typically a branch our pipeline
may incur a performance overhead of two bubbles every five instructions. The
exact performance lost depends on the instruction mix and on how often branches
are taken.</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Static Branch
Prediction<o:p></o:p></b></p>

<p class=MsoNormal>The prediction that the next PC will be the current PC + 4
is a form of <i style='mso-bidi-font-style:normal'>static control flow
prediction, </i>or, as it is commonly referred to a <i style='mso-bidi-font-style:
normal'>static branch prediction. </i>In particular, it is a static, <b
style='mso-bidi-font-weight:normal'>always not taken</b> branch prediction method.
It is <b style='mso-bidi-font-weight:normal'>static<i style='mso-bidi-font-style:
normal'> </i></b>because the decision does not change at <span class=GramE>runtime,</span>
it is always the same for a particular brand irrespective of what happens
during execution. <span style='mso-spacerun:yes'> </span>This is the easiest to
implement since all it needs is the current PC and a constant. There are other
forms of branch prediction that are a bit <span class=GramE>more tricky</span>
to implement. Consider this C code fragment:</p>

<p class=MsoNormal><span style='font-family:"Courier New"'><span
style='mso-tab-count:1'>     </span><span class=GramE>do</span> {<br>
<span style='mso-tab-count:2'>           </span>if (a[<span class=SpellE>i</span>]
!= 0) <br>
<span style='mso-tab-count:2'>           </span><span style='mso-tab-count:
1'>     </span>some computation<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:2'>          </span><span
class=SpellE>i</span>++;<br>
<span style='mso-tab-count:1'>     </span>} while (<span class=SpellE>i</span>
&lt; 100);<o:p></o:p></span></p>

<p class=MsoNormal>In NIOS II assembly this code would be translated to
something like this:</p>

<p class=MsoNormal><span style='font-family:"Courier New"'><span
style='mso-tab-count:1'>     </span>DOWHILE:<br>
<span style='mso-spacerun:yes'>    </span><span
style='mso-spacerun:yes'>      </span>load in r10 a[<span class=SpellE>i</span>]<br>
<span style='mso-tab-count:2'>           </span><span class=SpellE><b
style='mso-bidi-font-weight:normal'><u>beq</u></b></span><b style='mso-bidi-font-weight:
normal'><u><span style='mso-tab-count:1'>  </span>r10, r0, SKIP</u></b><br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span><span
style='mso-tab-count:1'>     </span>some computation<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span>SKIP:<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:2'>          </span><span
class=SpellE>addi</span><span style='mso-tab-count:1'> </span>r11, r11, 1<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:2'>          </span><span
class=SpellE><span class=GramE><b style='mso-bidi-font-weight:normal'><u>blt</u></b></span></span><b
style='mso-bidi-font-weight:normal'><u><span style='mso-tab-count:1'>  </span>r11,
r12, DOWHILE</u></b> <o:p></o:p></span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Where <span class=SpellE>i</span> <span class=GramE>is</span>
in r11 and 100 is in r12. The code has two branch instructions, a <span
class=SpellE>beq</span> and a <span class=SpellE><span class=GramE>blt</span></span>.
Assuming that most elements of the array would be valid, how would you guess
each branch would behave at runtime? How about the <span class=SpellE>beq</span>?
Chances are it will not <span class=SpellE>taken</span> most of the time as we
will be performing the computation for most array elements. How about the <span
class=SpellE><span class=GramE>blt</span></span>? It will execute 100 times, 99
will be taken and once, at the end will be not taken. The simple always taken
predictor will work well for the <span class=SpellE>beq</span>, but it will
fail miserably for the <span class=SpellE><span class=GramE>blt</span></span>.
A better static prediction policy is this: <b style='mso-bidi-font-weight:normal'>forward
not-taken, backward taken. </b>What does forward and backward mean? A
branch is a forward branch is <span class=SpellE>its</span> taken address is
higher than the branchs address. The <span class=SpellE>beq</span> is a
forward branch since SKIP is at the higher, numerically address. A backward
branch is a branch whose taken address is at a lower address. The <span
class=SpellE><span class=GramE>blt</span></span> is a backward branch. Note
that the not-taken address is always forward at PC + 4.<span
style='mso-spacerun:yes'>  </span>So, this static branch predictor must determine
whether the taken address of an instruction is less than or greater than the
current PC. Unfortunately, this is not straightforward for the simple reason
that to do so, the actual instruction is needed, the current PC is not
sufficient. </p>

<p class=MsoNormal>So, how can the forward not-taken, backward taken be
implemented in practice? One way is to prolong the fetch stage just enough to
do the <span class=GramE>calculation<span style='mso-spacerun:yes'>  </span>of</span>
the taken PC plus a decision as shown below. During the fetch stage, we use the
PC to first read the instruction <span class=SpellE>opcode</span> from the
instruction cache or memory. Then, while still in the fetch stage, we do the
following two things in parallel. Calculate the next PC (typically PC + 4 +
sign-<span class=SpellE><span class=GramE>ext</span></span><span class=GramE>(</span>Imm16)
in NIOS II) while deciding whether the taken PC is forward or backward. The
latter decision is easy to make for branch instructions in NIOS II since we
just need to look at the sign of the Imm16 offset. A negative offset means a
backward branch and a positive offset a forward one (think, is this true for
all cases? If not, does it matter that much?). Finally, we can select either
the taken and not taken next PC just before the next cycle/stage. The downside
of this approach is that the fetch stage and hence the clock cycle must be made
long enough to accommodate these actions. Careful instruction set design can
help. One has to realize that we do not need to fully decode the instruction.
We just need to figure out that this is a branch and what would the taken
address. If this is not a branch, we do not care which instruction it is.
Moreover, we do not care whether the branch is taken or not. Only what is the
taken address. NIOS IIs instruction set encoding is such that determining
whether an instruction is a branch is relatively straightforward (a few
specific bits in the <span class=SpellE>opcode</span> take a specific value)
and the taken address for conditional branches is always PC + 4 + sign-<span
class=SpellE><span class=GramE>ext</span></span><span class=GramE>(</span>Imm16).
Other control flow instructions use different calculations (e.g., jump). We
will ignore these for the time being. <span class=GramE>Suffices to say that we
can add functionality to correctly handle these at the expense of additional
hardware and most likely lower operating frequency.</span> Alternatively, we
can treat those as always not taken accepting a performance hit.</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_58" o:spid="_x0000_i1041" type="#_x0000_t75" style='width:534pt;
 height:273pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image009.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=712 height=364
src="cfprediction_files/image010.png" v:shapes="Picture_x0020_58"><![endif]></span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Instead of making the fetch stage long enough to accommodate
the calculation of taken PC plus the decision as described, we can instead use
a <b style='mso-bidi-font-weight:normal'>pre-decoding </b>approach. <span
class=GramE>In this approach, pushes the calculation of the taken PC plus the
decision as to whether a branch is forward <span class=SpellE>of</span>
backward just before the instruction cache.</span> In particular, when <span
class=SpellE>a</span> instruction is fetched from main memory, a hardware unit
inspects the contents returned from memory, determines whether the instruction
is a branch and if so, what is <span class=GramE>its</span> taken address. This
is metadata information is stored along the instruction in the instruction
cache using extra bits that are invisible to the programmer. Eventually, when
the pipeline fetches <span class=GramE>this instructions</span> it gets both
the taken address and whether this is a forward or not branch directly from the
instruction cache. Accordingly, it can redirect fetch for the next cycle. This
approach essentially moves the taken address calculation and the
forward/backward calculation off the fetch stage and pushes it before the
instruction cache. Since memory latencies are typically large (in the order of
tens or hundreds of cycles) adding an extra cycle to do these calculations does
not add much to the latency. Moreover, since the common case is that the
pipeline will hit in the instruction cache, this one cycle overhead is paid
rarely; once an instruction is pre-decoded and stored in the instruction cache,
the pipeline does not to calculate and hence delay for the taken PC and the
forward/backward determination. This pre-decoding technique can be used to hide
other decoding-related complexities in the pipeline as well. </p>

<p class=MsoNormal>There are several other static branch prediction techniques.
They are rarely used in practice since there are better, albeit more expensive
method which we will discuss next.</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Generalized Branch
Prediction<o:p></o:p></b></p>

<p class=MsoNormal>In general, given a branch instruction, branch prediction entails
the following actions:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in;mso-list:l0 level1 lfo23'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Guessing whether the branch will be taken or not.
This is called <b style='mso-bidi-font-weight:normal'>branch direction prediction,
</b>and often, incorrectly referred to as branch prediction.</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in;mso-list:l0 level1 lfo23'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Guess the correct next PC value. This is called <b
style='mso-bidi-font-weight:normal'>target address prediction.</b></p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in;mso-list:l0 level1 lfo23'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>Fetching the instructions at the next PC. <span
class=GramE>The is</span> no special term for this. </p>

<p class=MsoNormal>We will be discussing actions 1 and 2 in more detail next.
Action 3 depends on the first two actions and for the most part is
straightforward: just fetch the instruction at the predicted PC. We will start
with branch direction prediction</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Dynamic Branch Direction
Prediction</b> </p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Last Outcome <span
class=SpellE>Predition</span><o:p></o:p></b></p>

<p class=MsoNormal>Static branch prediction makes decisions which do not depend
on what happens at runtime. This is pretty naïve. Think of the equivalent in
real life. One of the reasons why <span class=GramE>humans has</span> survived
is that they learn and do not repeat the same mistake (at least some of us do).
Can the same concept be applied for branch prediction? The idea here is the
following: observe and learn. When you first encounter a branch never seen
before, just guess something (may be always not taken is good enough). However,
once the branch executes once, see what it did and remember that. Next time,
when you see the same <span class=GramE>branch predict</span> that it will do
the same as last time. This method will work very well for our previous code
example. It will quickly learn that the <span class=SpellE>beq</span> is not
taken while the <span class=SpellE><span class=GramE>blt</span></span> is
taken. This is called <b style='mso-bidi-font-weight:normal'>last outcome
branch direction prediction, </b>or simply <b style='mso-bidi-font-weight:normal'>last
outcome branch prediction. </b>Heres an example of how it will behave given
the first two iterations of the code above:</p>

<p class=MsoNormal style='margin-left:.5in;text-indent:.5in'><b
style='mso-bidi-font-weight:normal'><span style='font-family:"Courier New";
color:red'>ITERATION 1</span></b><span style='font-family:"Courier New"'><br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span>DOWHILE:<br>
<span style='mso-spacerun:yes'>    </span><span
style='mso-spacerun:yes'>      </span>load in r10 a[<span class=SpellE>i</span>]<br>
<span style='mso-tab-count:2'>           </span><span class=SpellE><b
style='mso-bidi-font-weight:normal'><u>beq</u></b></span><b style='mso-bidi-font-weight:
normal'><u><span style='mso-tab-count:1'>  </span>r10, r0, SKIP</u><span
style='mso-tab-count:1'>   </span><span style='color:red'>FIRST TIME SEEN </span></b></span><b
style='mso-bidi-font-weight:normal'><span style='font-family:Wingdings;
mso-ascii-font-family:"Courier New";mso-hansi-font-family:"Courier New";
mso-bidi-font-family:"Courier New";color:red;mso-char-type:symbol;mso-symbol-font-family:
Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>à</span></span></b><b
style='mso-bidi-font-weight:normal'><span style='font-family:"Courier New";
color:red'> PREDICT NOT TAKEN </span></b><b style='mso-bidi-font-weight:normal'><span
style='font-family:Wingdings;mso-ascii-font-family:"Courier New";mso-hansi-font-family:
"Courier New";mso-bidi-font-family:"Courier New";color:red;mso-char-type:symbol;
mso-symbol-font-family:Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:
Wingdings'>à</span></span></b><b style='mso-bidi-font-weight:normal'><span
style='font-family:"Courier New";color:red'> LEARN NOT TAKEN</span></b><span
style='font-family:"Courier New"'><br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span><span
style='mso-tab-count:1'>     </span>some computation<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span>SKIP:<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:2'>          </span><span
class=SpellE>addi</span><span style='mso-tab-count:1'> </span>r11, r11, 1<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:2'>          </span><span
class=SpellE><b style='mso-bidi-font-weight:normal'><u>blt</u></b></span><b
style='mso-bidi-font-weight:normal'><u><span style='mso-tab-count:1'>  </span>r11,
r12, DOWHILE</u></b> <b style='mso-bidi-font-weight:normal'><span
style='color:red'>FIRST TIME SEEN </span></b></span><b style='mso-bidi-font-weight:
normal'><span style='font-family:Wingdings;mso-ascii-font-family:"Courier New";
mso-hansi-font-family:"Courier New";mso-bidi-font-family:"Courier New";
color:red;mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span
style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>à</span></span></b><b
style='mso-bidi-font-weight:normal'><span style='font-family:"Courier New";
color:red'> PREDICT NOT TAKEN </span></b><b style='mso-bidi-font-weight:normal'><span
style='font-family:Wingdings;mso-ascii-font-family:"Courier New";mso-hansi-font-family:
"Courier New";mso-bidi-font-family:"Courier New";color:red;mso-char-type:symbol;
mso-symbol-font-family:Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:
Wingdings'>à</span></span></b><b style='mso-bidi-font-weight:normal'><span
style='font-family:"Courier New";color:red'> MISPREDICTION </span></b><b
style='mso-bidi-font-weight:normal'><span style='font-family:Wingdings;
mso-ascii-font-family:"Courier New";mso-hansi-font-family:"Courier New";
mso-bidi-font-family:"Courier New";color:red;mso-char-type:symbol;mso-symbol-font-family:
Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>à</span></span></b><b
style='mso-bidi-font-weight:normal'><span style='font-family:"Courier New";
color:red'> LEARN TAKEN</span></b><span style='font-family:"Courier New"'><br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span><b
style='mso-bidi-font-weight:normal'><span style='color:red'>ITERATION 2<br>
<span style='mso-spacerun:yes'>     </span></span></b>DOWHILE:<br>
<span style='mso-spacerun:yes'>    </span><span
style='mso-spacerun:yes'>      </span>load in r10 a[<span class=SpellE>i</span>]<br>
<span style='mso-tab-count:2'>           </span><span class=SpellE><b
style='mso-bidi-font-weight:normal'><u>beq</u></b></span><b style='mso-bidi-font-weight:
normal'><u><span style='mso-tab-count:1'>  </span>r10, r0, SKIP</u><span
style='mso-tab-count:1'>   </span><span style='color:red'>SEEN BEFORE </span></b></span><b
style='mso-bidi-font-weight:normal'><span style='font-family:Wingdings;
mso-ascii-font-family:"Courier New";mso-hansi-font-family:"Courier New";
mso-bidi-font-family:"Courier New";color:red;mso-char-type:symbol;mso-symbol-font-family:
Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>à</span></span></b><b
style='mso-bidi-font-weight:normal'><span style='font-family:"Courier New";
color:red'> PREDICT SAME AS LAST TIME: NOT TAKEN </span></b><b
style='mso-bidi-font-weight:normal'><span style='font-family:Wingdings;
mso-ascii-font-family:"Courier New";mso-hansi-font-family:"Courier New";
mso-bidi-font-family:"Courier New";color:red;mso-char-type:symbol;mso-symbol-font-family:
Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>à</span></span></b><b
style='mso-bidi-font-weight:normal'><span style='font-family:"Courier New";
color:red'> LEARN NOT TAKEN</span></b><span style='font-family:"Courier New"'><br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span><span
style='mso-tab-count:1'>     </span>some computation<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span>SKIP:<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:2'>          </span><span
class=SpellE>addi</span><span style='mso-tab-count:1'> </span>r11, r11, 1<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:2'>          </span><span
class=SpellE><b style='mso-bidi-font-weight:normal'><u>blt</u></b></span><b
style='mso-bidi-font-weight:normal'><u><span style='mso-tab-count:1'>  </span>r11,
r12, DOWHILE</u></b> <b style='mso-bidi-font-weight:normal'><span
style='color:red'>SEEN BEFORE </span></b></span><b style='mso-bidi-font-weight:
normal'><span style='font-family:Wingdings;mso-ascii-font-family:"Courier New";
mso-hansi-font-family:"Courier New";mso-bidi-font-family:"Courier New";
color:red;mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span
style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>à</span></span></b><b
style='mso-bidi-font-weight:normal'><span style='font-family:"Courier New";
color:red'> PREDICT SAME AS LAST TIME: PREDICT TAKEN </span></b><b
style='mso-bidi-font-weight:normal'><span style='font-family:Wingdings;
mso-ascii-font-family:"Courier New";mso-hansi-font-family:"Courier New";
mso-bidi-font-family:"Courier New";color:red;mso-char-type:symbol;mso-symbol-font-family:
Wingdings'><span style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>à</span></span></b><b
style='mso-bidi-font-weight:normal'><span style='font-family:"Courier New";
color:red'> LEARN NOT TAKEN</span></b><span style='font-family:"Courier New"'><o:p></o:p></span></p>

<p class=MsoNormal><span style='mso-tab-count:1'>                </span><span
class=GramE>and</span> so on</p>

<p class=MsoNormal>How well will this predictor work for our example? It will
predict the <span class=SpellE>beq</span> correct all the time as long as it is
not taken, it will <span class=SpellE>mispredict</span> the <span class=SpellE><span
class=GramE>blt</span></span> two times. <span class=GramE>Once in the
beginning for learning that it is taken, and once at the end, when the loop
ends where it will predict as taken while the branch will be not taken.</span>
The accuracy of the branch predictor is defined as:</p>

<p class=MsoNormal><span style='mso-tab-count:1'>                </span># <span
class=GramE>correct</span> predictions / #total predictions</p>

<p class=MsoNormal>In our example we will have:</p>

<p class=MsoNormal><span style='mso-tab-count:1'>                </span>100
correct for the <span class=SpellE>beq</span> and 98 correct for the <span
class=SpellE><span class=GramE>blt</span></span> out of the 200 in total
predictions. So, the accuracy will be 198/200 = 99%</p>

<p class=MsoNormal>How can we implement this prediction algorithm? There is a
price to pay, which amounts to extra storage for remembering what happened
last time we saw a particular branch. Specifically, for each branch that we encounter,
we need to remember two things: 1. <span class=GramE>Which</span> branch it
was; that is its PC value. 2. Which direction it went, taken or not taken
(recall, for the time being we are only interested in the taken/not taken
decision, we will discuss predicting the target address later on).</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Implementing
last-outcome prediction<o:p></o:p></b></p>

<p class=MsoNormal>One straightforward implementation of this technique is to
create a <b style='mso-bidi-font-weight:normal'>prediction table </b>which is an
associative table, or a content addressable memory, with three fields: (1) A PC
value, (2) a single bit encoding not taken as 0 and taken as 1, and (3) a valid
bit indicating whether this entry contains valid information or not. We can
create a table containing such entries. Ignore the issue of how many we need
for the time being. In the beginning all entries are empty which is signified
by having their valid bits at 0. Once a branch is fetched, we use its PC and
compare against all entries (I know this appears, expensive, hold on, we will
simplify soon). If there a match we can use the information from the taken/not
taken bit. In the beginning all of the entries are empty, so there will be no
match, and hence we will fall back to a default prediction, say PC +4 which is
easy to implement. Once the branch executes, we can then see what direction it
took and if necessary allocate an entry for it in our prediction table. Next
time, once we encounter the same branch, we will look it up using the same PC
and find the information about what it did last time. If we are lucky, history
will repeat itself, and the prediction will be correct. Once the branch
executes, we can go back and update the prediction information. This way the
predictor can adjust at runtime in response to the branchs behavior. This is
why this is a dynamic predictor.</p>

<p class=MsoNormal>The implementation described might be straightforward to
understand but is expensive. In particular, if we need one entry per possible
branch, we will need 2^32/4, that is 2^30 or 1G entries for the 4G address
space of NIOS II, since a branch can appear anywhere in memory. Each entry
would contain a full PC (thats 4 bytes) plus two more bits. That is a lot of
storage and more than our main memory. But <span class=GramE>wait,</span> if we
are going to have an entry for each possible PC then we do not need to store
the PC value in it. Starting from a PC, we can simply index the corresponding prediction
table entry and get the valid and prediction bits. So instead of having a table
like this:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_60" o:spid="_x0000_i1040" type="#_x0000_t75" style='width:146.25pt;
 height:99pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image011.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=195 height=132
src="cfprediction_files/image012.png" v:shapes="Picture_x0020_60"><![endif]></span></p>

<p class=MsoNormal>We can have a table like this:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_59" o:spid="_x0000_i1039" type="#_x0000_t75" style='width:66.75pt;
 height:102pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image013.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=89 height=136
src="cfprediction_files/image014.png" v:shapes="Picture_x0020_59"><![endif]></span></p>

<p class=MsoNormal><span style='mso-spacerun:yes'> </span>The problem is that
this table still needs to have 1G <span class=GramE>entries</span>. While each
entry is 2 bits wide, in total we are still looking at 256Mbytes of storage. That
is still a lot. What can we do to reduce its size?</p>

<p class=MsoNormal>First, lets recall that we are predicting. That is, we can
be wrong or right and the machine will still execute the program correctly.
Being wrong just reduces performance. So, how about we have branches share
table entries? This can be done with a hash function. So instead of having a
table with 1G <span class=GramE>entries</span> that is directly indexed by all
relevant bits of the PC like this:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_61" o:spid="_x0000_i1038" type="#_x0000_t75" style='width:223.5pt;
 height:156pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image015.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=298 height=208
src="cfprediction_files/image016.png" v:shapes="Picture_x0020_61"><![endif]></span></p>

<p class=MsoNormal>We can have a smaller table with as many entries we can afford
which is indexed using a hash function as in this:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_62" o:spid="_x0000_i1037" type="#_x0000_t75" style='width:239.25pt;
 height:150pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image017.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=319 height=200
src="cfprediction_files/image018.png" v:shapes="Picture_x0020_62"><![endif]></span></p>

<p class=MsoNormal>For example, the table can have 2K entries only. The hash function
needs not be something overly complicated. For example, for a 2K entry
prediction table, we can use just the lower 11 bits (after ignoring bits 1 and
0 which are always 0 as the instruction needs to be aligned at a 4-byte
granularity).</p>

<p class=MsoNormal>Once we have limited the number of entries, we will have
collisions, that is different branches will map onto the same prediction table
entry. This is called <b style='mso-bidi-font-weight:normal'>aliasing. </b>Aliasing
can be <i style='mso-bidi-font-style:normal'>destructive</i> or <i
style='mso-bidi-font-style:normal'>constructive</i>. That is, if the two
aliasing branches have opposite behavior they will <span class=GramE>interfere</span>
reducing prediction accuracy. If they have the same behavior they will
reinforce each other and accuracy may improve when the decision changes
(observing the change for one branch will be enough to correctly predict the
changed behavior for the other).</p>

<p class=MsoNormal>Finally, since we no longer have a PC, many different
branches may map to each entry, and since we are predicting anyhow, what is the
point of having valid bits? We can simply drop them and have a simple
prediction table as follows:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>The Problem with
Last-Outcome prediction<o:p></o:p></b></p>

<p class=MsoNormal>Last-outcome prediction is nice, but it is like a bad
politician. Anyway the wind blows it goes. That is, it quickly changes its
mind. Again, going back to our do-while loop example think what would happen if
that loop were to execute multiple times. The first time the loop executes, our
predictor will quickly learn that the <span class=SpellE><span class=GramE>blt</span></span>
is taken. At the 100<sup>th</sup> iteration however, our predictor will fail to
predict that this is the last iteration and predict taken. It will <span
class=SpellE>misspredict</span> as the <span class=GramE>loop<span
style='mso-spacerun:yes'>  </span>will</span> exit. Immediately, the prediction
bit will be updated. Next time the loop runs, at the end of the first
iteration, the predictor will miss-predict not taken. It will adjust to predict
taken and then correctly predict the rest 98 iterations. Again at the 100<sup>th</sup>
will miss-predict.</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Adding <span
class=SpellE>Hysterisis</span>  Two bit predictors<o:p></o:p></b></p>

<p class=MsoNormal>A solution to this is to add some hysteresis in the
prediction mechanism. That is, we will still allow the predictor to change its
mind, but it will do so with some resistance. A simple, hysteresis mechanism is
a 2-bit up/down saturating counter which operates as follows:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_63" o:spid="_x0000_i1036" type="#_x0000_t75" style='width:312pt;
 height:177pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image019.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=416 height=236
src="cfprediction_files/image020.png" v:shapes="Picture_x0020_63"><![endif]></span></p>

<p class=MsoNormal>Each prediction table entry now has two bits which are
updated according to the diagram above. The table looks as follows:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_64" o:spid="_x0000_i1035" type="#_x0000_t75" style='width:174pt;
 height:170.25pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image021.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=232 height=227
src="cfprediction_files/image022.png" v:shapes="Picture_x0020_64"><![endif]></span></p>

<p class=MsoNormal>There are four possible values which take the following
meaning:</p>

<p class=MsoListParagraphCxSpFirst style='text-indent:-.25in;mso-list:l11 level1 lfo24'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>1.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>00: means strongly biased toward not taken <span
style='font-family:Wingdings;mso-ascii-font-family:Calibri;mso-ascii-theme-font:
minor-latin;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;
mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span style='mso-char-type:
symbol;mso-symbol-font-family:Wingdings'>à</span></span> predict not taken</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in;mso-list:l11 level1 lfo24'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>2.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>01: weakly biased toward not taken <span
style='font-family:Wingdings;mso-ascii-font-family:Calibri;mso-ascii-theme-font:
minor-latin;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;
mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span style='mso-char-type:
symbol;mso-symbol-font-family:Wingdings'>à</span></span> predict not taken</p>

<p class=MsoListParagraphCxSpMiddle style='text-indent:-.25in;mso-list:l11 level1 lfo24'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>3.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>10: weakly biased toward taken <span
style='font-family:Wingdings;mso-ascii-font-family:Calibri;mso-ascii-theme-font:
minor-latin;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;
mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span style='mso-char-type:
symbol;mso-symbol-font-family:Wingdings'>à</span></span> predict taken</p>

<p class=MsoListParagraphCxSpLast style='text-indent:-.25in;mso-list:l11 level1 lfo24'><![if !supportLists]><span
style='mso-bidi-font-family:Calibri;mso-bidi-theme-font:minor-latin'><span
style='mso-list:Ignore'>4.<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]>11: strongly biased toward taken <span
style='font-family:Wingdings;mso-ascii-font-family:Calibri;mso-ascii-theme-font:
minor-latin;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;
mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span style='mso-char-type:
symbol;mso-symbol-font-family:Wingdings'>à</span></span> predict taken</p>

<p class=MsoNormal>The diagram shows how the counter changes value according to
the actual direction of the branch. The labels on top of the arrows show the
actual branch outcome. For example, assuming that the current value is 10 the
predictor is weakly biased toward taken and will predict taken. If the actual
direction proves to be taken, the predictor will be updated to 11 and will
become strongly biased toward taken. If the direction is not taken, the
predictor will be updated to 01 changing its decision for time and becoming
weakly biased toward not taken.</p>

<p class=MsoNormal>In our loop example, lets assume the predictor for <span
class=SpellE><span class=GramE>blt</span></span> is initially weakly biased
toward taken. The first loop iteration will correctly predict taken and will
then move to be strongly biased toward taken. For the next 98 iterations it
will predict taken and stay at 11. For the 100<sup>th</sup> iteration it will
miss-predict and move to 10, weakly biased toward taken. Next time the loop
starts executing it will correctly predict the first iteration and thus avoid
the extra miss-prediction that the last-outcome predictor suffered. While for a
loop that iterates 100 times the difference in accuracy is minor, for shorter
loops avoiding that extra miss-prediction is significant.</p>

<p class=MsoNormal>The two bit saturating counter is an example of a <b
style='mso-bidi-font-weight:normal'>confidence mechanism. </b>We can think of
many others. For example, we can use a 3-bit saturating counter in order to add
more hysteresis in changing prediction direction. Such predictors are called <b
style='mso-bidi-font-weight:normal'>bi-modal.<o:p></o:p></b></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>The problem with bimodal
predictors<o:p></o:p></b></p>

<p class=MsoNormal>Let us now consider these nested loops:</p>

<p class=MsoNormal style='margin-left:.5in'><span class=SpellE><span
style='font-family:"Courier New"'>i</span></span><span style='font-family:"Courier New"'>
= 0<span class=GramE>;</span><br>
do {<br>
<span style='mso-spacerun:yes'>      </span><span style='mso-tab-count:1'>     </span>j
= 0;<br>
<span style='mso-tab-count:1'>     </span>do {<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:2'>          </span>some
calculation<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:2'>          </span>j++;<br>
<span style='mso-tab-count:1'>     </span>} while (j &lt; 2);<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span><span
class=SpellE>i</span>++;<o:p></o:p></span></p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:"Courier New"'>}
while (<span class=SpellE>i</span> &lt; 3);<o:p></o:p></span></p>

<p class=MsoNormal>The equivalent NIOS II code would look something like this:</p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-family:"Courier New"'><br>
<span style='mso-tab-count:1'>     </span><span class=SpellE>movi</span><span
style='mso-tab-count:1'> </span>r18, 3<span style='mso-tab-count:1'>     </span>#
max <span class=SpellE>i</span><br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span><span
class=SpellE>movi</span><span style='mso-tab-count:1'> </span>r19, 2<span
style='mso-tab-count:1'>     </span># max j<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span><span
class=SpellE>movi</span><span style='mso-tab-count:1'> </span>r8, 0<span
style='mso-tab-count:1'> </span><span style='mso-tab-count:1'>     </span>#<span
class=SpellE>i</span> = 0<br>
<span class=SpellE>DOi</span>:<br>
<span style='mso-tab-count:1'>     </span><span class=SpellE>movi</span><span
style='mso-tab-count:1'> </span>r9, 0<span style='mso-tab-count:1'> </span><span
style='mso-tab-count:1'>     </span># j = 0<br>
<span class=SpellE>DOj</span>:<br>
<span style='mso-tab-count:1'>     </span>some computation<br>
<span style='mso-tab-count:1'>     </span><span class=SpellE>addi</span><span
style='mso-tab-count:1'> </span>r9, r9, 1<br>
<span style='mso-tab-count:1'>     </span><span class=SpellE>blt</span><span
style='mso-tab-count:1'>  </span>r9, r19, <span class=SpellE>DOj</span> #J
branch<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span><span
class=SpellE>addi</span> <span style='mso-tab-count:1'> </span>r8, r8, 1<br>
<span style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>    </span><span
class=SpellE>blt</span> <span style='mso-tab-count:1'> </span>r8, r18, <span
class=SpellE>DOi</span><span style='mso-spacerun:yes'>  </span># I branch<o:p></o:p></span></p>

<p class=MsoNormal>When this code runs we will see the following pattern for
the J branch:</p>

<p class=MsoNormal><span style='mso-tab-count:1'>                </span>T <span
class=SpellE>T</span> NT<span style='mso-spacerun:yes'>    </span>T <span
class=SpellE>T</span> NT<span style='mso-spacerun:yes'>   </span>T <span
class=SpellE>T</span> NT</p>

<p class=MsoNormal>Our 2-bit confidence counter will struggle with this.
Assuming that it starts say from 10 (weakly taken), it will make the following
predictions:</p>

<p class=MsoNormal style='margin-left:.5in;text-indent:-.5in'><span
style='mso-tab-count:1'>                </span>T (11<span class=GramE>) <span
style='mso-spacerun:yes'> </span>T</span>(11) <b style='mso-bidi-font-weight:
normal'><span style='color:red'>T</span></b>(10) <span
style='mso-spacerun:yes'>    </span>T(11) T (11) <b style='mso-bidi-font-weight:
normal'><span style='color:red'>T</span></b>(10)<span
style='mso-spacerun:yes'>  </span>T(11) T (11) <b style='mso-bidi-font-weight:
normal'><span style='color:red'>T</span></b>(10)</p>

<p class=MsoNormal style='margin-left:.5in;text-indent:-.5in'>It will
miss-predict three times (the numbers in parentheses show the predictor state
after each prediction is resolved).</p>

<p class=MsoNormal style='margin-left:.5in;text-indent:-.5in'>However, the
pattern that the J branch exhibits is fairly regular: two taken followed by
one not taken. Can we design a predictor that can predict this kind of
patterns?</p>

<p class=MsoNormal style='margin-left:.5in;text-indent:-.5in'><b
style='mso-bidi-font-weight:normal'>Pattern-Based Predictors<o:p></o:p></b></p>

<p class=MsoNormal>The idea behind pattern based branch predictor is to
associate a prediction not just with a particular branch but also with a
history of other related events. In particular, we can associate a prediction
with both a PC and a series of recent branch outcomes. This is pattern-based
prediction. In this prediction a shift register is introduced. Each bit corresponds
to the direction taken by the N most recent branches. Each time a branch is <span
class=GramE>predicted,</span> we shift the register by one bit to the right and
add an extra bit with the direction predicted for the current branch. To make
things easy to understand, lets pretend that the only branch that we were to
observe at runtime was the J branch above. How will the prediction proceed? Lets
assume that we had a 2 bit history register and that initially the register is
all zeroes corresponding to NT. Lets see at three invocations of the inner j
loop above. In this example assume that the only PC that will access the
prediction table is the J branch and that there are enough entries to store
all possible patterns. When indexing the prediction table we use both the PC
and the pattern as specified by the history register. This can be done for
example by concatenating the two (this is called a <span class=SpellE><b
style='mso-bidi-font-weight:normal'>gselect</b></span> predictor) or by hashing
them together somehow through say some <span class=SpellE>xor</span> function
(this is called <span class=SpellE><b style='mso-bidi-font-weight:normal'>gshare</b></span>):</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_65" o:spid="_x0000_i1034" type="#_x0000_t75" style='width:337.5pt;
 height:244.5pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image023.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=450 height=326
src="cfprediction_files/image024.png" v:shapes="Picture_x0020_65"><![endif]></span></p>

<p class=MsoNormal>Heres what happens for the first time the J loop executes:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_67" o:spid="_x0000_i1033" type="#_x0000_t75" style='width:373.5pt;
 height:272.25pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image025.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=498 height=363
src="cfprediction_files/image026.png" v:shapes="Picture_x0020_67"><![endif]></span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The first time the J branch executes, the history register
contains 00 and the prediction is NT. This is assuming that all entries in the
prediction table are initialized to NT. The predictor miss-predicts and when
the J branch executes eventually, the predictor learns that the history pattern
00 leads to T. The history register is updated to 10, since the last branch
that was since was taken. The second time the branch executes, it again resorts
to the initial value provided for the history pattern 10, which incorrectly set
to NT. It miss-predicts and learns that 10 leads to T instead. The history
register is now 11 since the last two times J was taken. The third time, the
predictor correctly predicts NT just by luck as the default initial value is
NT. It also learns that 11 leads to NT. History <span class=GramE>is</span>
updated to 01, since the last branch was not taken and the previous to last was
taken. So far our predictor has learned three patterns: 00 <span
style='font-family:Wingdings;mso-ascii-font-family:Calibri;mso-ascii-theme-font:
minor-latin;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;
mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span style='mso-char-type:
symbol;mso-symbol-font-family:Wingdings'>à</span></span> T, 10 <span
style='font-family:Wingdings;mso-ascii-font-family:Calibri;mso-ascii-theme-font:
minor-latin;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;
mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span style='mso-char-type:
symbol;mso-symbol-font-family:Wingdings'>à</span></span>T, and 11 <span
style='font-family:Wingdings;mso-ascii-font-family:Calibri;mso-ascii-theme-font:
minor-latin;mso-hansi-font-family:Calibri;mso-hansi-theme-font:minor-latin;
mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span style='mso-char-type:
symbol;mso-symbol-font-family:Wingdings'>à</span></span> NT.</p>

<p class=MsoNormal>Lets now see what happens when the J loop executes again:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_68" o:spid="_x0000_i1032" type="#_x0000_t75" style='width:401.25pt;
 height:288.75pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image027.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=535 height=385
src="cfprediction_files/image028.png" v:shapes="Picture_x0020_68"><![endif]></span></p>

<p class=MsoNormal>The 4<sup>th</sup> time branch executes, there is no
information in table for the current history pattern of 01 and hence we get the
default NT which proves wrong. The predictor, however, learns that 01 leads to
T. At this point the predictor has learned the four patterns shown in the
diagram above. From this point on, as we shall see the predictor will predict
all J branches correctly 100% of the time. Heres what happens next. </p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_69" o:spid="_x0000_i1031" type="#_x0000_t75" style='width:392.25pt;
 height:294.75pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image029.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=523 height=393
src="cfprediction_files/image030.png" v:shapes="Picture_x0020_69"><![endif]></span></p>

<p class=MsoNormal>History is now 10. The predictor has learned that 10 <span
class=GramE>leads</span> to 1 which is the correct prediction. History now
becomes 11. The predictor for the next branch sees that 11 leads to 0 and
correctly predicts that the next J branch will be not taken. History now
becomes 01. Lets see what happens if the J loop is invoked again:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_70" o:spid="_x0000_i1030" type="#_x0000_t75" style='width:387pt;
 height:293.25pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image031.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=516 height=391
src="cfprediction_files/image032.png" v:shapes="Picture_x0020_70"><![endif]></span></p>

<p class=MsoNormal>At this point, you should be able to follow the example and
to see that our predictor correctly predicts all instances of the J branch
since it learned the three possible history patterns, 11, 01, <span
class=GramE>10</span>.</p>

<p class=MsoNormal>In the example we discussed we assume that the predictor
table stores just a single bit for each prediction. However, we can still use
the two-bit saturating counter for hysteresis. Most processors today would
implement a pattern based predictor. There are quite a few variants depending
as to whether the history register is shared among all branches, and whether there
are separate prediction tables per branch. In practice, the history register is
shared and all branches access a single table using a hash of the PC and the
current history. The exact history length that works best varies within and
across applications and is determined experimentally. There are even methods
that adjust the history length at runtime using a sample and run approach. In
this approach, we start with one length and run for a while measuring accuracy.
After say 10K cycles we adjust the size and run again. <span class=GramE>After
10K cycles we compare the accuracy with the new history length versus the one
used before.</span> We pick the best and move along with that. This process of
adjust continues for ever.</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>The problem with
pattern based predictors. <o:p></o:p></b></p>

<p class=MsoNormal>As the example has shown, it takes a while for a pattern
predictor to learn how a branch behaves. It may be more capable than a simple
bi-modal predictor but it takes a while to do so and uses many entries. In
summary, bi-modal is a fast learner but it can only learn so much, <span
class=SpellE>gshare</span>/pattern is clever but it takes a while to light the
fuse. Enter <b style='mso-bidi-font-weight:normal'>tournament </b>predictors.
These predictors try to get the best of both worlds. They run in parallel say a
bi-modal and a <span class=SpellE>gshare</span> predictor and then try to pick
the <span class=GramE>best</span> of the two:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_71" o:spid="_x0000_i1029" type="#_x0000_t75" style='width:280.5pt;
 height:197.25pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image033.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=374 height=263
src="cfprediction_files/image034.png" v:shapes="Picture_x0020_71"><![endif]></span><span
style='mso-spacerun:yes'> </span></p>

<p class=MsoNormal>How does it pick which is best? It predicts using another
predictor which is often another bimodal:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_72" o:spid="_x0000_i1028" type="#_x0000_t75" style='width:369.75pt;
 height:281.25pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image035.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=493 height=375
src="cfprediction_files/image036.png" v:shapes="Picture_x0020_72"><![endif]></span></p>

<p class=MsoNormal>The first two predictors observe the branch stream, PCs and
taken or not taken and operate as we described. The third, <span class=GramE><b
style='mso-bidi-font-weight:normal'>meta</b></span> predictor observes the
other two and in particular whether they are wrong or right. It adjusts its
decision toward the one that is right (breaking ties either way probably
preferably toward the bimodal which is more space efficient). Most high-end
processors today implement some variant of this tournament predictor.</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Rush job<o:p></o:p></b></p>

<p class=MsoNormal>Branch predictors operate under very strict time
constraints. They have to make a decision within a single clock cycle in order
to be able to continuously feed the pipeline with new instructions. Branch
prediction accuracy can increase considerably if larger tables are used since
this reduces aliasing and allows us to learn more patterns. However, larger
tables are slower. As a result, processors are often use very small predictors
that are not as accurate as we would wish. If someone is willing to pay the
price, there is a better solution where two predictors operate in parallel. The
first is a fast that operates within a single clock cycle. The second is a much
larger, <b style='mso-bidi-font-weight:normal'>overwriting</b> predictor that
may take multiple cycles to make a prediction. For example, in our 5-stage pipeline,
the overwriting predictor may take two cycles and produce a better prediction
by the end of decode:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_73" o:spid="_x0000_i1027" type="#_x0000_t75" style='width:429.75pt;
 height:264pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image037.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=573 height=352
src="cfprediction_files/image038.png" v:shapes="Picture_x0020_73"><![endif]></span></p>

<p class=MsoNormal>If the overwriting predictor agrees with the fast predictor
nothing changes, however, if it disagrees, the pipeline may be flushed and
fetch redirected right now. In our five stage pipeline, this may save just one
cycle which doesnt seem much. However, if you think of a modern OOO processor
which is deeply pipelined and has many outstanding branches, it <span
class=GramE>make</span> take several 10s of cycles before the branch is
resolved, so a more confident prediction may be better.</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Predicting the Target
Address<o:p></o:p></b></p>

<p class=MsoNormal>So far, we were concerned with predicting whether the branch
will be taken or not. If its taken it would be nice to know where it goes to.
We said that one option is to calculate this at the fetch stage at the cost of
making the clock cycle slow enough to accommodate this calculation. An
alternate approach is to predict the target address. A simple last-outcome
predictor can be used here as well. That is, the first time we see a branch we
take our losses and do not predict the taken address. However, once the branch
executes and we see <span class=GramE>which is the taken address we store it in
in a separate <b style='mso-bidi-font-weight:normal'>Branch Target Buffer </b>table
(BTB)</span>. Next time around, we encounter the same branch we look it up in
the BTB using just its PC where we will find its target address. To avoid
aliasing we can tag each entry with the PC that it corresponds to:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_74" o:spid="_x0000_i1026" type="#_x0000_t75" style='width:285.75pt;
 height:121.5pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image039.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=381 height=162
src="cfprediction_files/image040.png" v:shapes="Picture_x0020_74"><![endif]></span></p>

<p class=MsoNormal>This BTB works very well for NIOS IIs branches since the
taken address does not change at runtime. It can also be used for Jump instructions.
It will work reasonably well for indirect branches such as those using a register
for the target address (used in switch statements and function pointers for
example, or to implement virtual functions in C++). More advanced techniques
have been proposed to increase accuracy for indirect branches where, for
example, a history pattern is used to associate different possible target
addresses with different execution paths.</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Putting it all
together<o:p></o:p></b></p>

<p class=MsoNormal>In summary, the fetch stage contains a branch direction
predictor and a Branch Target Buffer which operate in parallel. The branch
direction predictor provides a taken/not taken prediction and the BTB provides
the taken address. In parallel we also calculate the fall through address (PC +
4) and select between that and the one provided by the BTB based on the
direction prediction:</p>

<p class=MsoNormal><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_75" o:spid="_x0000_i1025" type="#_x0000_t75" style='width:369.75pt;
 height:286.5pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="cfprediction_files/image041.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=493 height=382
src="cfprediction_files/image042.png" v:shapes="Picture_x0020_75"><![endif]></span></p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Calls and Returns<o:p></o:p></b></p>

<p class=MsoNormal>Call and returns are very frequent and foil the BTB. In
particular, the BTB will correctly predict calls since their target address
does not change, however, it will fail to predict returns since the return
address varies depending on where the call was made from; the same ret
instruction may return to different addresses. However, where the <span
class=SpellE>ret</span> will return is known at call time. Since these are
frequent instructions a specialized prediction mechanism is used. Specifically,
a hardware stack is used. When fetch encounters a call instruction it pushes on
the stack PC+4 which is the return address for the call. When a return is
encountered, fetch pops an address from this hardware stack. The hardware stack
is not visible to the programmer and works perfectly as long as the call depth
does not exceed its capacity.</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'>Avoiding Control Flow
when we can<o:p></o:p></b></p>

<p class=MsoNormal>Consider the following if statement:</p>

<p class=MsoNormal><span style='mso-tab-count:1'>                </span>If (<span
class=GramE>error !</span>= 0) <span class=SpellE>error_handle</span>();</p>

<p class=MsoNormal>Assuming that errors are rare the above code will rarely
jump into <span class=SpellE>error_<span class=GramE>handle</span></span><span
class=GramE>(</span>). Branch prediction will correctly learn this and avoid
stalling. Now consider this branch:</p>

<p class=MsoNormal><span style='mso-tab-count:1'>                </span>If (a[<span
class=SpellE>i</span>] &lt; threshold) a++; else b++;</p>

<p class=MsoNormal>What the branch will do is completely depending on the
values of a[<span class=SpellE>i</span>]. We may get a runtime pattern that is
easy to predict or we may get one that will foil our predictors. Is there an
alternative? Another possibility is to use <b style='mso-bidi-font-weight:normal'>predicated
instructions. </b>These instructions take the following form:</p>

<p class=MsoNormal><span class=SpellE><span class=GramE>cond</span></span>
register: <span style='mso-tab-count:1'>   </span>some instruction</p>

<p class=MsoNormal><span class=GramE>Where <span class=SpellE>cond</span>
register is a reference to a single bit register.</span> If the value of that
register is 0 the instruction converts on the fly into a no op (does nothing),
otherwise if the condition register is 1, the instruction executes normally.</p>

<p class=MsoNormal>Lets look at the code we had before. Heres how it is
implemented in conventional NIOS II machine language:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><span style='mso-tab-count:1'>                </span>Load a[<span
class=SpellE>i</span>] in r8<br>
<span style='mso-tab-count:1'>                </span><span class=SpellE><span
class=GramE><b style='mso-bidi-font-weight:normal'>blt</b></span></span><span
class=GramE><b style='mso-bidi-font-weight:normal'><span
style='mso-spacerun:yes'>  </span>r8</b></span><b style='mso-bidi-font-weight:
normal'>, r9, THEN</b><span style='mso-tab-count:1'>                </span># r9
holds threshold<br>
ELSE:<br>
<span style='mso-tab-count:1'>                </span><span class=SpellE>addi</span>
r10, r10, 1<span style='mso-tab-count:2'>                   </span># b++<br>
<span style='mso-tab-count:1'>                </span><span class=SpellE><b
style='mso-bidi-font-weight:normal'>br</b></span><b style='mso-bidi-font-weight:
normal'> <span style='mso-tab-count:1'>           </span>DONE<o:p></o:p></b></p>

<p class=MsoNormal>THEN:<br>
<span style='mso-tab-count:1'>                </span><span class=SpellE>addi</span>
r11, r11, 1<span style='mso-tab-count:2'>                   </span># a++<br>
DONE:</p>

<p class=MsoNormal>A pipeline will struggle with the <span class=SpellE><span
class=GramE>blt</span></span> instruction trying to predict a data dependent
pattern. In a hypothetical predicated NIOS II variant we would have this:</p>

<p class=MsoNormal><b style='mso-bidi-font-weight:normal'><span
style='mso-tab-count:1'>                </span>Load a[<span class=SpellE>i</span>]
in r8<br>
<span style='mso-tab-count:1'>                </span><span class=SpellE>cmplt</span>
c0, r8, r9<span style='mso-tab-count:1'>  </span># condition register c0 = r8
&lt; r9<br>
c0:<span style='mso-tab-count:1'>          </span><span class=SpellE>addi</span>
r10, r10, 1<br>
<span class=GramE>!c0</span>:<span style='mso-tab-count:1'>         </span><span
class=SpellE>addi</span> r11, r11, 1<o:p></o:p></b></p>

<p class=MsoNormal>The first c0: <span class=SpellE>addi</span> writes into r10
only if c0 is TRUE while <span class=GramE>the !</span>c0: <span class=SpellE>addi</span>
writes into r11 only if c0 is FALSE. In this code there are no branches so
nothing to predict and no possibility of miss-prediction which is great. However,
notice that no matter what one of the instructions will be converted to no op.
So, we will effectively have one bubble in the pipeline. This is the price we
pay with predication. This is less of a concern for if-then constructs as it is
not always the case that we will see no ops. A commonly used instruction set
that provides prediction is that of ARM. GPUs are also implementing
predication. General purpose processors usually implemented a poor-mans
predication alternative in the form of a conditional move. For example, in a
hypothetical NIOS II implementation we could have:</p>

<p class=MsoNormal><span style='mso-tab-count:1'>                </span><span
class=SpellE><span class=GramE>cmov</span></span> r10, r11, r12</p>

<p class=MsoNormal><span class=GramE>which</span> does r10 = r11 only if r12 is
non-zero (TRUE).</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal style='margin-left:.5in;text-indent:-.5in'><o:p>&nbsp;</o:p></p>

</div>

</body>

</html>
