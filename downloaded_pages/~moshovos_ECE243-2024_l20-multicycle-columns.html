<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1253">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="l20-multicycle-columns_files/filelist.xml">
<link rel=Edit-Time-Data href="l20-multicycle-columns_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>BestFit</w:Zoom>
  <w:SpellingState>Clean</w:SpellingState>
  <w:GrammarState>Clean</w:GrammarState>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Batang;
	panose-1:2 3 6 0 0 1 1 1 1 1;
	mso-font-alt:Batang;
	mso-font-charset:129;
	mso-generic-font-family:auto;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 151388160 16 0 524288 0;}
@font-face
	{font-family:"\@Batang";
	mso-font-charset:129;
	mso-generic-font-family:auto;
	mso-font-pitch:auto;
	mso-font-signature:0 0 0 0 0 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:Batang;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:Batang;}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 65.95pt 1.0in 65.95pt;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
table.MsoTableGrid
	{mso-style-name:"Table Grid";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="6146"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoPlainText>Computer Organization</p>

<p class=MsoPlainText>Implementing a Processor: Multi-cycle Implementation</p>

<p class=MsoPlainText>Andreas <span class=SpellE>Moshovos</span></p>

<p class=MsoPlainText>Spring 2007</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b>MULTICYCLE IMPLEMENTATION: The <span class=SpellE>Datapath</span><o:p></o:p></b></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>As with the single-cycle implementation our processor
will consist of two cooperating units the <span class=SpellE>datapath</span> and
the control. We will first design the <span class=SpellE>datapath</span> and
then the control. The key difference here is that the execution of a single
instruction will take multiple cycles to complete. Accordingly, the <span
class=SpellE>datapath</span> will have to change a bit. </p>

<p class=MsoPlainText>The high-level methodology used to develop this <span
class=SpellE>datapath</span> is the following: We approach instruction
execution as a sequence of small steps/actions. Instead of trying to perform
all these actions in one giant step/cycle we instead partition them into groups
that are performed in order one after the other. Roughly the groups we will use
here are:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'>1.<span
style='font-size:7.0pt;font-family:"Times New Roman"'><span style='font-size-adjust: none;
font-stretch: normal'>&nbsp;&nbsp;&nbsp; </span></span>Read instruction from
memory.</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'>2.<span
style='font-size:7.0pt;font-family:"Times New Roman"'><span style='font-size-adjust: none;
font-stretch: normal'>&nbsp;&nbsp;&nbsp; </span></span>Decode instruction and
speculatively read two registers that the instruction might use</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'>3.<span
style='font-size:7.0pt;font-family:"Times New Roman"'><span style='font-size-adjust: none;
font-stretch: normal'>&nbsp;&nbsp;&nbsp; </span></span>Perform ALU calculations
or access memory.</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'>4.<span
style='font-size:7.0pt;font-family:"Times New Roman"'><span style='font-size-adjust: none;
font-stretch: normal'>&nbsp;&nbsp;&nbsp; </span></span>Write result back to
register file.</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'>5.<span
style='font-size:7.0pt;font-family:"Times New Roman"'><span style='font-size-adjust: none;
font-stretch: normal'>&nbsp;&nbsp;&nbsp; </span></span>Determine next PC and
update PC.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Because these steps will be executed in separate cycles
it is necessary to introduce additional storage elements to remember what step
of the execution we are at and to hold information as long as it might needed.</p>

<p class=MsoPlainText>The figure that follows shows the <span class=SpellE>datapath</span>.
You will notice that it is slightly different than the single cycle <span
class=SpellE>datapath</span>. One key difference is the introduction of
temporary registers to hold the outcomes that are produced at each cycle. For
the time being please ignore the details and focus on the grey boxes. These are
the new registers but keep in mind that these registers are not visible to the
programmer:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><u3:shapetype id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f"><u3:stroke joinstyle="miter"/><u3:formulas><u3:f eqn="if lineDrawn pixelLineWidth 0"/><u3:f eqn="sum @0 1 0"/><u3:f eqn="sum 0 0 @1"/><u3:f eqn="prod @2 1 2"/><u3:f eqn="prod @3 21600 pixelWidth"/><u3:f eqn="prod @3 21600 pixelHeight"/><u3:f eqn="sum @0 0 1"/><u3:f eqn="prod @6 1 2"/><u3:f eqn="prod @7 21600 pixelWidth"/><u3:f eqn="sum @8 21600 0"/><u3:f eqn="prod @7 21600 pixelHeight"/><u3:f eqn="sum @10 21600 0"/></u3:formulas><u3:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/><o:lock u3:ext="edit" aspectratio="t"/></u3:shapetype><u3:shape id="_x0000_i1025" type="#_x0000_t75" style="width:652.5pt;&#13;&#10; height:354pt"><u3:imagedata src="l20-multicycle-columns_files/image003.emz" o:title=""/></u3:shape><img
width=870 height=472 id="_x0000_i1025" src="l20-multicycle-columns_files/image002.gif"
u3:shapes="_x0000_i1025"></p>

<p class=MsoPlainText>The following temporary registers are introduced:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'>IR or
Instruction Register: This is used to hold the instruction encoding after it is
read from memory. A register is needed because we will use a single memory
device both for data and instructions. Accordingly, its output may change
during the execution of an instruction (a load will read from memory).</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'>R1 and R2:
These are used to temporarily hold the register values read from the register
file. </p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'><span
class=SpellE>AluOut</span>: This is used to temporarily hold the result
calculated by the ALU.</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'>MDR or Memory
Data Register: holds the value returned from memory so that it can later be
written into the register file.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Observe that in our <span class=SpellE>datapath</span> there
is now a single memory device, one ALU and no additional adders. Contrary to
the single cycle implementation here we do not have to replicate any functional
block/unit that is used twice by an instruction. For example, we can use the
same memory to read an instruction in one cycle and then read/write from/to it
in a subsequent cycle for loads and stores. Similarly, we do not need to use
separate adders for calculating PC + 1 and PC + 1 + <span class=GramE>SE(</span>Imm4).
We can reuse the same ALU.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Let’s see how this <span class=SpellE>datapath</span> was
derived. We will explain what happens cycle by cycle. The division of work in
cycles will seem arbitrary when you read the rest of the material. How one
decides what can be done in a single cycle and how to partition the various
actions into separate actions. This is really only possible if one knows the
relative delay of each action. For example, how long it takes to read to
registers from the register file, and how does this compare to performing an
addition with the ALU? Ideally, we would partition the actions in a way such
that every cycle is used in full to perform useful work. This means that the
delay of the work performed in each cycle will be pretty much the same for all
cycles. In practice, we try to get as close as possible to this ideal. </p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b>CYCLE-BY-CYCLE DESCRIPTION<o:p></o:p></b></p>

<p class=MsoPlainText>The first two cycles are the same for all instructions
since we need to fetch the instruction from memory and then decode it (i.e.,
the control has to look at the <span class=SpellE>opcode</span> and decide what
to do next).</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>-----</p>

<p class=MsoPlainText><b>CYCLE 1: Fetching the Instruction and Incrementing the
PC<o:p></o:p></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>The first step in executing an instruction requires
fetching the instruction from memory. For this we have to send the value of the
PC register to the address lines of the memory device. Assuming that the memory
will respond within this first cycle, we want to store the returned value (this
is the encoding of the instruction that we should execute). To do this we need
to take the value from the memory’s output and write into the IR register.
These steps are possible as shown below:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><u3:shape id="_x0000_s1041" type="#_x0000_t75" style="position:absolute;margin-left:0;margin-top:0;width:249pt;height:316.5pt;&#13;&#10; z-index:1;mso-position-horizontal:left;mso-position-vertical:top;&#13;&#10; mso-position-vertical-relative:line" o:allowoverlap="f"><u3:imagedata src="l20-multicycle-columns_files/image004.emz" o:title=""/><w:wrap type="square" side="right"/></u3:shape><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_s1026" type="#_x0000_t75" alt="" style='position:absolute;
 margin-left:0;margin-top:0;width:249pt;height:316.5pt;z-index:1;
 mso-position-horizontal:left;mso-position-vertical-relative:line'
 o:allowoverlap="f">
 <v:imagedata src="l20-multicycle-columns_files/image001.gif"/>
 <w:wrap type="square"/>
</v:shape><![endif]--><![if !vml]><img width=332 height=422
src="l20-multicycle-columns_files/image001.gif" align=left hspace=12
u3:shapes="_x0000_s1041" v:shapes="_x0000_s1026"><![endif]><br clear=all
style='mso-special-character:line-break'>
</p>

<p class=MsoPlainText>Because we may access the same memory device to perform a
load or a store (read and write respectively) a MUX is needed at the address
input so that it is possible to send either the PC or another address. So,
during the first cycle we will be reading the instruction encoding from memory.
This is probably a good time to also calculate PC = PC + 1 as all instructions
use this (even branches require PC + 1 as part of their target calculation).
Here’s how this is done:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><u3:shape id="_x0000_i1026" type="#_x0000_t75" style="width:607.5pt;height:330pt"><u3:imagedata src="l20-multicycle-columns_files/image005.emz" o:title=""/></u3:shape><img
width=705 height=383 id="_x0000_i1026" src="l20-multicycle-columns_files/image006.gif"
u3:shapes="_x0000_i1026"></p>

<p class=MsoPlainText>In parallel with the memory access, we send the PC value
through the ALU1 <span class=SpellE>mux</span> to the ALU. As the second input
to the ALU we send the number 1 (input 001 of MUX ALU2). Finally, we set <span
class=SpellE>ALUop</span> to 000 (addition). As a result, the ALU will
calculate PC + 1. By setting <span class=SpellE>PCWrite</span> to 1, at the end
of the current clock cycle (negative edge), PC will change and will become PC +
1.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b>CYCLE 1 SUMMARY: </b>In summary the following actions
take place during the first cycle. This is often called the FETCH cycle.</p>

<p class=MsoPlainText><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [IR] = <span
class=SpellE><span class=GramE>Mem</span></span><span class=GramE>[</span> [PC]
] <o:p></o:p></b></p>

<p class=MsoPlainText><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [PC] = [PC] + 1<o:p></o:p></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>Note that because all instructions need to compute PC+1
it was possible to try to evaluate this as early as possible. This is one type
of optimization we can apply to reduce the number of cycles needed to execute
every instruction. Alternatively, we could have computed PC+1 after performing
all other actions.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b>-------<o:p></o:p></b></p>

<p class=MsoPlainText><b>CYCLE 2: </b>Decoding the instruction and reading from
the register file</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>During the second cycle, the control will be taking a
look at the instruction <span class=SpellE>opcode</span> in order to decide
what should happen during the next cycle. Because many instructions use the
registers specified in fields R1 and R2 of the instruction we also read these
registers from the register file. Note that some instructions do not use R1 or
R2. In this case, we would have read registers that we do not need. While this
is extra work we literally had nothing better to do during the second cycle. So,
it is OK in hardware to perform actions that may be useful and later ignore the
results if they are not needed. This is permissible as long as the extraneous
work does not change and machine state in an irreversible way (reads do not
change the register values so they are OK). In other words, reading the two
registers is a <b>speculative </b>optimization performed at the hardware level.
We guess that an action <b>might be useful </b>and perform it speculatively.
Later on, we will determine whether this speculation is successful. In the case
of reading these two registers, there is no harm when we <span class=SpellE>mispeculate</span>.
We simply have read two registers. There are many other forms of speculation in
modern processors, some of which require corrective action. Also note, that
should we have chosen to wait to <b>determine</b> whether we should read the
registers, those instructions that use them would require an extra cycle to
execute.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>It is important to note that during the <span
class=SpellE>seconnd</span> cycle the <span class=SpellE>datapath</span> cannot
take actions that depend on the actual instruction being executed. This is
because we assume that the control needs a full cycle to decode the <span
class=SpellE>opcode</span> and decide what needs to happen next. For our simple
instruction set this is probably a pessimistic assumption. Not so for other
architectures <span class=GramE>that have</span> many more instructions.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Note that because the R1 and R2 field always appear at
the same bit locations it is possible to blindly use them and access the
register file even through the control has not yet had enough time to check the
actual <span class=SpellE>opcode</span>.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Schematically, here’s what happens in the <span
class=SpellE>datapath</span>:<o:p></o:p></p>

<p class=MsoPlainText><u3:shape id="_x0000_i1027" type="#_x0000_t75" style="width:253.5pt;height:360.75pt"><u3:imagedata src="l20-multicycle-columns_files/image007.emz" o:title=""/></u3:shape><img
width=338 height=481 id="_x0000_i1027" src="l20-multicycle-columns_files/image008.gif"
u3:shapes="_x0000_i1027"></p>

<p class=MsoPlainText>Thus at the end of the 2nd cycle, registers R1 and R2 are
loaded with the values held by the registers identified by the instruction bit
fields R1 and R2 respectively.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b>CYCLE 2 <span class=GramE>SUMMARY</span>:<o:p></o:p></b></p>

<p class=MsoPlainText><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [R1] = <span
class=GramE>RF[</span>[IR7..6]]<o:p></o:p></b></p>

<p class=MsoPlainText><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [R2] = <span
class=GramE>RF[</span>[IR5..4]]<o:p></o:p></b></p>

<p class=MsoPlainText><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Instruction Decode<o:p></o:p></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>-----</p>

<p class=MsoPlainText><span style='font-size:14.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoPlainText><b><span style='font-size:14.0pt'>CYCLE 3 and after<o:p></o:p></span></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>What happens after cycle 2 depends on the actual
instruction.&nbsp; Accordingly we will consider each instruction in turn.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b><span style='font-size:14.0pt'>*** ADD, SUB and NAND<o:p></o:p></span></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>The execution of these three instruction proceeds into
additional steps:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>In cycle 3 we calculate the operation specified by the
instruction and at the end store the result into <span class=SpellE>ALUout</span>.
In cycle 4 we write the result into the register file:</p>

<table class=MsoTableGrid border=0 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;mso-padding-alt:0in 5.4pt 0in 5.4pt;
 mso-border-insideh:.5pt solid windowtext;mso-border-insidev:.5pt solid windowtext'>
 <tr style='mso-yfti-irow:0;mso-yfti-firstrow:yes'>
  <td width=502 valign=top style='width:376.8pt;border:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText>CYCLE 3<o:p></o:p></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td width=502 valign=top style='width:376.8pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;
  border-color:-moz-use-text-color windowtext windowtext'>
  <p class=MsoPlainText><u3:shape id="_x0000_i1028" type="#_x0000_t75" style="width:246.75pt;height:328.5pt"><u3:imagedata src="l20-multicycle-columns_files/image009.emz" o:title=""/></u3:shape><img
  width=329 height=438 id="_x0000_i1030" src="l20-multicycle-columns_files/image029.gif"
  u3:shapes="_x0000_i1028"></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td width=502 valign=top style='width:376.8pt;border:solid windowtext 1.0pt;
  border-top:none;mso-border-top-alt:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;
  border-color:-moz-use-text-color windowtext windowtext'>
  <p class=MsoPlainText><u3:shape id="_x0000_i1028" type="#_x0000_t75" style="width:246.75pt;height:328.5pt"><u3:imagedata src="l20-multicycle-columns_files/image009.emz" o:title=""/></u3:shape>CYCLE
  4</p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3;mso-yfti-lastrow:yes'>
  <td width=502 valign=top style='width:376.8pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0in 5.4pt 0in 5.4pt;border-color:-moz-use-text-color windowtext windowtext'>
  <p class=MsoPlainText><u3:shape id="_x0000_i1028" type="#_x0000_t75" style="width:246.75pt;height:328.5pt"><u3:imagedata src="l20-multicycle-columns_files/image009.emz" o:title=""/></u3:shape><img
  width=488 height=421 id="_x0000_i1031" src="l20-multicycle-columns_files/image030.gif"
  u3:shapes="_x0000_i1029"><o:p></o:p></p>
  </td>
 </tr>
</table>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b><span style='font-size:14.0pt'>*** SHIFT<o:p></o:p></span></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>Shift is almost identical to ADD, SUB and NAND. The only
difference is that during cycle 3 we do not use register R2 but the Imm3 field
from IR:</p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<table class=MsoTableGrid border=0 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;mso-padding-alt:0in 5.4pt 0in 5.4pt;
 mso-border-insideh:.5pt solid windowtext;mso-border-insidev:.5pt solid windowtext'>
 <tr style='mso-yfti-irow:0;mso-yfti-firstrow:yes'>
  <td width=614 valign=top style='width:6.4in;border:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText><b>CYCLE 3<o:p></o:p></b></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td width=614 valign=top style='width:6.4in;border-top:none;border-left:solid windowtext 1.0pt;
  border-bottom:none;border-right:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt;
  border-color:-moz-use-text-color windowtext windowtext'>
  <p class=MsoPlainText><u3:shape id="_x0000_i1030" type="#_x0000_t75" style="width:450pt;height:324pt"><u3:imagedata src="l20-multicycle-columns_files/image013.emz" o:title=""/></u3:shape><img
  width=600 height=432 id="_x0000_i1032" src="l20-multicycle-columns_files/image014.gif"
  u3:shapes="_x0000_i1030"><o:p></o:p></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td width=614 valign=top style='width:6.4in;border-top:none;border-left:solid windowtext 1.0pt;
  border-bottom:none;border-right:solid windowtext 1.0pt;padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText>CYCLE 4</p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3;mso-yfti-lastrow:yes'>
  <td width=614 valign=top style='width:6.4in;border:solid windowtext 1.0pt;
  border-top:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText><img width=488 height=421 id="_x0000_i1033"
  src="l20-multicycle-columns_files/image015.gif" u3:shapes="_x0000_i1031"></p>
  </td>
 </tr>
</table>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b><span style='font-size:14.0pt'>*** ORI<o:p></o:p></span></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>ORI uses an implied source/destination register operand. Accordingly,
the register we read in cycle 2 may not be the right one. For this reason, we
have to access the register file again and read K1, then in cycle 4 we can
perform the OR in the ALU and in cycle 5 write the result into the register
file:</p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<table class=MsoTableGrid border=0 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;mso-padding-alt:0in 5.4pt 0in 5.4pt;
 mso-border-insideh:.5pt solid windowtext;mso-border-insidev:.5pt solid windowtext'>
 <tr style='mso-yfti-irow:0;mso-yfti-firstrow:yes'>
  <td width=613 valign=top style='width:460.05pt;border:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText><b>CYCLE 3<o:p></o:p></b></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td width=613 valign=top style='width:460.05pt;border-top:none;border-left:
  solid windowtext 1.0pt;border-bottom:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border-color:-moz-use-text-color windowtext windowtext'>
  <p class=MsoPlainText><u3:shape id="_x0000_i1032" type="#_x0000_t75" style="width:234.75pt;height:340.5pt"><u3:imagedata src="l20-multicycle-columns_files/image016.emz" o:title=""/></u3:shape><img
  width=313 height=454 id="_x0000_i1034" src="l20-multicycle-columns_files/image017.gif"
  u3:shapes="_x0000_i1032"><o:p></o:p></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td width=613 valign=top style='width:460.05pt;border-top:none;border-left:
  solid windowtext 1.0pt;border-bottom:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText>CYCLE 4</p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3'>
  <td width=613 valign=top style='width:460.05pt;border-top:none;border-left:
  solid windowtext 1.0pt;border-bottom:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText><img width=599 height=432 id="_x0000_i1035"
  src="l20-multicycle-columns_files/image019.gif" u3:shapes="_x0000_i1033"></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:4'>
  <td width=613 valign=top style='width:460.05pt;border-top:none;border-left:
  solid windowtext 1.0pt;border-bottom:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText>CYCLE 5</p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:5;mso-yfti-lastrow:yes'>
  <td width=613 valign=top style='width:460.05pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText><img width=488 height=421 id="_x0000_i1036"
  src="l20-multicycle-columns_files/image020.gif" u3:shapes="_x0000_i1034"></p>
  </td>
 </tr>
</table>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b><span style='font-size:14.0pt'>*** LOAD<o:p></o:p></span></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>For a LOAD instruction we will be accessing memory during
cycle 3 and storing the returned value into MDR. Then in cycle 4 we can write
this value in the register file.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<table class=MsoTableGrid border=0 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;mso-padding-alt:0in 5.4pt 0in 5.4pt;
 mso-border-insideh:.5pt solid windowtext;mso-border-insidev:.5pt solid windowtext'>
 <tr style='mso-yfti-irow:0;mso-yfti-firstrow:yes'>
  <td width=624 valign=top style='width:468.3pt;border:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText><b>CYCLE 3<o:p></o:p></b></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1'>
  <td width=624 valign=top style='width:468.3pt;border-top:none;border-left:
  solid windowtext 1.0pt;border-bottom:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt;border-color:-moz-use-text-color windowtext windowtext'>
  <p class=MsoPlainText><u3:shape id="_x0000_i1035" type="#_x0000_t75" style="width:457.5pt;height:343.5pt"><u3:imagedata src="l20-multicycle-columns_files/image021.emz" o:title=""/></u3:shape><img
  width=610 height=458 id="_x0000_i1037" src="l20-multicycle-columns_files/image022.gif"
  u3:shapes="_x0000_i1035"><o:p></o:p></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:2'>
  <td width=624 valign=top style='width:468.3pt;border-top:none;border-left:
  solid windowtext 1.0pt;border-bottom:none;border-right:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText><b>CYCLE 4</b></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:3;mso-yfti-lastrow:yes'>
  <td width=624 valign=top style='width:468.3pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText><img width=324 height=421 id="_x0000_i1038"
  src="l20-multicycle-columns_files/image024.gif" u3:shapes="_x0000_i1036"></p>
  </td>
 </tr>
</table>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText><b><span style='font-size:14.0pt'>*** STORE<o:p></o:p></span></b></p>

<p class=MsoPlainText><b><span style='font-size:14.0pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoPlainText>For a STORE instruction we will be accessing memory
during cycle 3 to write the value into memory:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<table class=MsoTableGrid border=0 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;mso-padding-alt:0in 5.4pt 0in 5.4pt;
 mso-border-insideh:.5pt solid windowtext;mso-border-insidev:.5pt solid windowtext'>
 <tr style='mso-yfti-irow:0;mso-yfti-firstrow:yes'>
  <td width=655 valign=top style='width:490.9pt;border:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText><b>CYCLE 3<o:p></o:p></b></p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1;mso-yfti-lastrow:yes'>
  <td width=655 valign=top style='width:490.9pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0in 5.4pt 0in 5.4pt;border-color:-moz-use-text-color windowtext windowtext'>
  <p class=MsoPlainText><u3:shape id="_x0000_i1037" type="#_x0000_t75" style="width:426.75pt;height:309.75pt"><u3:imagedata src="l20-multicycle-columns_files/image025.emz" o:title=""/></u3:shape><img
  width=569 height=413 id="_x0000_i1028" src="l20-multicycle-columns_files/image026.gif"
  u3:shapes="_x0000_i1037"></p>
  </td>
 </tr>
</table>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b><span style='font-size:14.0pt'>*** BRANCHES<o:p></o:p></span></b></p>

<p class=MsoPlainText><b><span style='font-size:14.0pt'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoPlainText>For branch instructions in cycle 3 we will calculate PC +
1 + Sign-Extended (Imm4) and at the end of the cycle depending on whether the
condition is true or not we will write this value into the PC. Recall that
during cycle 1 we changed the PC to PC’ = PC + 1, so now we need to calculate
PC’ + Sign-<span class=GramE>Extended(</span>imm4):</p>

<table class=MsoTableGrid border=0 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;mso-padding-alt:0in 5.4pt 0in 5.4pt;
 mso-border-insideh:.5pt solid windowtext;mso-border-insidev:.5pt solid windowtext'>
 <tr style='mso-yfti-irow:0;mso-yfti-firstrow:yes'>
  <td width=655 valign=top style='width:490.9pt;border:solid windowtext 1.0pt;
  padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoPlainText>CYCLE 3</p>
  </td>
 </tr>
 <tr style='mso-yfti-irow:1;mso-yfti-lastrow:yes'>
  <td width=655 valign=top style='width:490.9pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0in 5.4pt 0in 5.4pt;border-color:-moz-use-text-color windowtext windowtext'>
  <p class=MsoPlainText><u3:shape id="_x0000_i1038" type="#_x0000_t75" style="width:612.75pt;height:333pt"><u3:imagedata src="l20-multicycle-columns_files/image027.emz" o:title=""/></u3:shape><img
  width=817 height=444 id="_x0000_i1029" src="l20-multicycle-columns_files/image028.gif"
  u3:shapes="_x0000_i1038"></p>
  </td>
 </tr>
</table>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>The decision on whether to change the PC will be taken by
the control. The decision can be enforced by setting the <span class=SpellE>PCWrite</span>
signal (1 for changing PC 0 for keeping the PC + 1).</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

</div>

</body>

</html>
