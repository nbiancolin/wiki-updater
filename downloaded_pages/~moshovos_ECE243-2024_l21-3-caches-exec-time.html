<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1253">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="l21-3-caches-exec-time_files/filelist.xml">
<title>Determining Hits &amp; Misses with Caches</title>
<!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>150</w:Zoom>
  <w:GrammarState>Clean</w:GrammarState>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 65.95pt 1.0in 65.95pt;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]-->
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoPlainText>Determining Hits &amp; Misses with Caches</p>

<p class=MsoPlainText>Andreas Moshovos</p>

<p class=MsoPlainText>Spring 2008</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>In this set of lectures we will look at how, given (1) a
piece of assembly code and (2) a memory hierarchy, we can determine how many
hits and misses will occur and thus how long it will take for the code to
execute. To simplify the discussion we make the following assumptions:</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'>1.<span
style='font-size:7.0pt;font-family:"Times New Roman"'>&nbsp;&nbsp;&nbsp; </span><span
class=GramE>Assuming</span> that memory is ideally fast all instructions
execute within a single cycle.</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:-.25in'>2.<span
style='font-size:7.0pt;font-family:"Times New Roman"'>&nbsp;&nbsp;&nbsp; </span>We
ignore the memory accesses needed for fetching instructions (because we want to
avoid having to figure out how many bytes each m68k instruction takes and
because adding these references will make it harder to understand what is
happening without really enhancing the material).</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText><b>Example #1: Linear access of array elements</b></p>

<p class=MsoPlainText><b>&nbsp;</b></p>

<p class=MsoPlainText>Let’s see what will happen when the following code
executes:</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>movia</span>
&nbsp;&nbsp;&nbsp; r8, array&nbsp; ; base of the array</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>add</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r9, r0, r0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; sum = 0</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>add</span><span
style='mso-tab-count:1'>   </span><span style='mso-spacerun:yes'>   
</span>r10, r0, r0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
counts the number of elements processed thus far</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>addi</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r11, r0, 4096&nbsp;&nbsp; ; number of array elements</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText><span class=GramE>loop</span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=GramE>ldw</span><span style='mso-tab-count:2'>         </span>r12, 0(r8)</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=GramE>add</span><span style='mso-tab-count:2'>         </span>r9, r9, r12<span
style='mso-tab-count:1'> </span>; sum = sum + next element of the array</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>addi</span><span
style='mso-tab-count:1'>  </span><span style='mso-tab-count:1'>      </span>r8,
r8, 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; make a0 point to the next element</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>addi</span><span
style='mso-tab-count:2'>        </span>r10, r10, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; one more element processed</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>bne</span><span
style='mso-tab-count:1'>   </span><span style='mso-tab-count:1'>      </span>r10,
r11, loop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; have we processed all elements?</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>When this code executes, and ignoring instruction
fetches, it will access memory via the instruction “ldw r12, 0(r8)”. It will
access the following addresses:</p>

<p class=MsoPlainText>0, 4, 8, 16<span class=GramE>, ...,</span> 4092
(decimal).</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText><b>Execution time with ideal memory (single cycle
latency):</b></p>

<p class=MsoPlainText><b>&nbsp;</b></p>

<p class=MsoPlainText>Assuming that each instruction takes a single cycle to execute
the aforementioned code will execute in the following number of cycles:</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>4 + 4096 x 5 cycles</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>The first four cycles are for the first four instructions
that execute only once. <span class=GramE>Each loop iteration</span> comprises
five instructions. The loop iterates 4096 times (r10 counting from 0 to 4096). </p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText><b>Execution time with a Cache</b></p>

<p class=MsoPlainText><b>&nbsp;</b></p>

<p class=MsoPlainText>Let’s now determine how long it will take for the code to
execute with a realistic memory hierarchy. For this purpose let us assume that
a memory reference completes in a single cycle if it hits in the cache (cache
latency = 1 cycle). It takes 100 cycles in total to complete a reference when
it misses in the cache (1 cycle for determining that this is a miss plus 99 <span
class=GramE>cycle</span> to go to memory). Let’s assume that the data cache is
direct mapped, 16Kbytes (data capacity – notice that many more bits are needed
for implementing the cache since it contains the tags, valid bits and possibly
dirty bits – these are often not included in the data cache size – the latter
refers to the useful capacity of the cache). The data cache has 32 byte frames.
</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>Let us further assume that array (the base address of the
array) is divisible by 16K, that is (array modulo 16K) = 0. This assumption
will allow us to determine which set access will map to. Because array is
divisible by 16k this implies that the last 14 bits (that’s because 2^14 = 16K)
are zeroes. So, array = x...x0...0 where the x...x = 18 bits and 0...0 = 14
bits.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>First we need to determine how the cache is indexed. That
is given a 32 bit address from the CPU how do we determine which set and frame
this may map to.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>We know that:</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>#frames = Capacity / bytes_per_frame = 16K / 32 = 2^14 /
2^5 = 2^9 = 512 </p>

<p class=MsoPlainText>#sets = #frames / associativity = 2^9 / 1 = 2^9</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>So, our cache has 512 sets with one frame per set. Each
frame contains 32 bytes. Thus, the 32-bit address is divided into three fields:</p>

<p class=MsoPlainText>Offset: total 5 bits because each frame holds 32 bytes <span
style='font-family:Wingdings'>&agrave;</span> bits 4 through bit 0 (the least
significant ones)</p>

<p class=MsoPlainText>Set: total 9 bits because there are 2^9 sets in the cache
<span style='font-family:Wingdings'>&agrave;</span> bits 13 through 5
(immediately next to offset)</p>

<p class=MsoPlainText>Tag: what is left, so 32 – 9 – 5 = 18 bits, or bits 31
through 14.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>Now that we know how addresses are mapped onto the cache
we can determine how many are hits and how many are misses.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>Access #1: address array + 0 <span style='font-family:
Wingdings'>&agrave;</span> this maps to tag x...x, set 0, and offset 0 <span
style='font-family:Wingdings'>&agrave;</span> the cache is initially empty
hence this is a miss <span style='font-family:Wingdings'>&agrave;</span>
latency 100 cycles</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Note the tag<span class=GramE>&nbsp; is</span> x...x the upper 18 bits of the
“array” address.</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Because this is a miss, the whole block will be fetched from memory in the 100
cycles. The block includes the bytes in addresses 0 through 31 (32 bytes in
total).</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Recall that the assignment of addresses into blocks is static. Addresses 0
through 31 belong to block 0, 32 to 63 to block 1, 64 trough 95 to block 2 and
so on.</p>

<p class=MsoPlainText>Access #2: address array + 4 <span style='font-family:
Wingdings'>&agrave;</span> tag x...x, set 0, offset 4 <span style='font-family:
Wingdings'>&agrave;</span> this is a hit since we brought in this data when we
missed on the first access <span style='font-family:Wingdings'>&agrave;</span>
latency is 1</p>

<p class=MsoPlainText>Access #3: address array + 8 <span style='font-family:
Wingdings'>&agrave;</span> <span class=GramE>tag</span> x...x, set 0, offset 8 <span
style='font-family:Wingdings'>&agrave;</span> hit <span style='font-family:
Wingdings'>&agrave;</span> latency 1 cycle</p>

<p class=MsoPlainText>...</p>

<p class=MsoPlainText>Access #8: address array + 28 <span style='font-family:
Wingdings'>&agrave;</span> <span class=GramE>tag</span> x...x, set 0, offset 28
<span style='font-family:Wingdings'>&agrave;</span> hit <span style='font-family:
Wingdings'>&agrave;</span> latency 1 cycle</p>

<p class=MsoPlainText>Access #9: address array + 32 <span style='font-family:
Wingdings'>&agrave;</span> tag x...x, set 1, offset 0 <span style='font-family:
Wingdings'>&agrave;</span> miss since this belongs to block 1 and this is the
first access to an address within block 1 <span style='font-family:Wingdings'>&agrave;</span>
latency 100 cycles</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
This will bring in the data at addresses array + 32 ... array + 63</p>

<p class=MsoPlainText>Access #10: address array + 36 <span style='font-family:
Wingdings'>&agrave;</span> <span class=GramE>tag</span> x...x, set 1, offset 4 <span
style='font-family:Wingdings'>&agrave;</span> hit <span style='font-family:
Wingdings'>&agrave;</span> latency 1 cycle</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>If we continue this way we will see a repeating pattern
of 1 miss and 7 hits per block.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>So our execution time will be:</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>4 (for the first four instructions) + 4096 x 4 (for the
four instructions in the loop that do not access memory) + 4096 (7/8 x 1 (for
the 7 hits per block) 1/8 x 100 (for the one miss per block))</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText><span class=GramE>if</span> the above code was to be
executed twice with the same cache, the second time the array elements are
accessed they will all be hits since the full array has been cached. This is
possible because the cache’s capacity is sufficient to hold <span class=GramE>all
of the</span> array (which is 4096 x 4 = 16Kbytes). The same will hold true for
caches that have higher capacity. If the cache was 8Kbytes, then accesses to
elements 2048 through 4095 would replace elements 0 through 2047 from the
cache. So, next time around 0 through 2047 are accessed they will observe the 1
miss – 7 hit pattern.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText><b>Example #2: Accessing two aligned arrays</b></p>

<p class=MsoPlainText><b>&nbsp;</b></p>

<p class=MsoPlainText>Let’s <span class=GramE>us</span> now look at another
example where we access two arrays simultaneously:</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText style='text-indent:.5in'><span class=GramE>movia</span>&nbsp;&nbsp;&nbsp;&nbsp;
r8, aA&nbsp;&nbsp;&nbsp;&nbsp; <span style='mso-tab-count:2'>         </span>;
array A</p>

<p class=MsoPlainText style='text-indent:.5in'><span class=GramE>movia</span>&nbsp;&nbsp;&nbsp;&nbsp;
r9, aB&nbsp;&nbsp;&nbsp;&nbsp; <span style='mso-tab-count:2'>         </span>;
array B</p>

<p class=MsoPlainText style='text-indent:.5in'><span class=GramE>addi</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
r10, r10, 4096&nbsp;&nbsp; <span style='mso-tab-count:1'>   </span>; elements
per array</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>addi</span><span
style='mso-tab-count:2'>        </span>r11, r0, r0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
; elements processed thus far</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>addi</span>
<span style='mso-tab-count:2'>       </span>r12, r0, r0&nbsp;&nbsp;&nbsp;&nbsp;
<span style='mso-tab-count:1'>  </span>; sum = 0</p>

<p class=MsoPlainText><span class=GramE>loop</span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=GramE>ldw</span><span style='mso-tab-count:2'>         </span>r13, 0(r8) <span
style='mso-tab-count:1'> </span><span style='mso-tab-count:1'>      </span>;
sum = sum + element of array a</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>ldw</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style='mso-tab-count:1'>  </span>r14, 0(r9)&nbsp;&nbsp;&nbsp; <span
style='mso-tab-count:1'>    </span>; sum = sum + element of array b</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>add</span><span
style='mso-tab-count:2'>         </span>r12, r12, r13</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=GramE>add</span><span style='mso-tab-count:2'>         </span>r12, r12,
r14</p>

<p class=MsoPlainText style='text-indent:.5in'><span class=GramE>addi</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style='mso-tab-count:1'>  </span>r11, r11, 1<span style='mso-tab-count:
1'> </span><span style='mso-tab-count:1'>      </span>; one more element per
array processed</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>addi</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style='mso-tab-count:1'>  </span>r8, r8, 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='mso-tab-count:1'>   </span>; point to next element of array a</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>addi</span><span
style='mso-tab-count:1'>  </span><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>r9, r9, 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
style='mso-tab-count:1'>   </span>; point to next element of array b</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=GramE>bne</span><span
style='mso-tab-count:1'>   </span><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>r10, r11, loop&nbsp;&nbsp;&nbsp;&nbsp;; all
elements processed?</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p class=MsoPlainText>If we assume an ideal memory system then this many cycles
will be needed:</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>5 (for the initialization) + 4096 (iterations) x 8
(instructions in loop body)</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>Let’s assume that <span class=GramE>aA</span> modulo 16K
=0 and aB modulo 16K = 0 hence aA = x...x0...0 and bB=y...y0...0 where the
0...0 portions comprise 14 bits and the x...x and y...y are each 18 bits. The
exact values of x...x and y...y are not important.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>As before let us assume a 16Kbyte cache, with 32 bytes
per frame and that is direct mapped. Here’s the sequence of accesses and what
happens during each one of them:</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>Access #1: aA + 0 <span style='font-family:Wingdings'>&agrave;</span>
tag x...x, set 0, offset 0 <span style='font-family:Wingdings'>&agrave;</span>
miss –-&gt; 100 cycles <span style='font-family:Wingdings'>&agrave;</span>
brings in data from aA + 0 through aA + 31<br>
Access #2: bB+ 0 <span style='font-family:Wingdings'>&agrave;</span> tag y...y,
set 0, offset 0 <span style='font-family:Wingdings'>&agrave;</span> miss <span
style='font-family:Wingdings'>&agrave;</span> 100 cycles <span
style='font-family:Wingdings'>&agrave;</span> brings in data from aB + 0
through bB + 31 <span style='font-family:Wingdings'>&agrave;</span> replaces
data in the frame (those fetched from the previous access)</p>

<p class=MsoPlainText>Access #3: aA + 4 <span style='font-family:Wingdings'>&agrave;</span>
tag x...x, set 0, offset 4 <span style='font-family:Wingdings'>&agrave;</span> miss
<span style='font-family:Wingdings'>&agrave;</span> 100 cycles <span
style='font-family:Wingdings'>&agrave;</span> brings in data from aA+0 through
aA + 31 <span style='font-family:Wingdings'>&agrave;</span> replaces data from
previous reference</p>

<p class=MsoPlainText>Access #4: bB + 4 <span style='font-family:Wingdings'>&agrave;</span>
tag y...y, set 0, offset 4 <span style='font-family:Wingdings'>&agrave;</span>
miss <span style='font-family:Wingdings'>&agrave;</span> 100 cycles – brings in
data from aB + 0 through bB + 31 <span style='font-family:Wingdings'>&agrave;</span>
replaces data from previous reference</p>

<p class=MsoPlainText>And so on.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>As we see no access results in a hit as consecutive
addresses map onto the same cache frame but to different blocks and hence they
evict each other.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>What if the cache was 2-way set associative? In this
case, the case will have 256 sets where each set will contain 2 frames. In this
case, the tag is 19 bits long and the set 8 bits long. The offset still is 5
bits long since each frame is still 32 bytes long.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>So it will take this many cycles for the code to execute:</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>5 (for initialization) + 4096 x 3 (for the loop body
instructions that do not access memory) + 4096 x 2 x 100 (for the two
instructions that access memory)</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>Here’s what happens at each access:</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>Access #1: aA + 0 <span style='font-family:Wingdings'>&agrave;</span>
tag x...x0, set 0, offset 0 <span style='font-family:Wingdings'>&agrave;</span>
miss –-&gt; 100 cycles <span style='font-family:Wingdings'>&agrave;</span> brings
in data from aA + 0 through aA + 31, placed in frame 0 of set 0<br>
Access #2: bB+ 0 <span style='font-family:Wingdings'>&agrave;</span> tag
y...y0, set 0, offset 0 <span style='font-family:Wingdings'>&agrave;</span>
miss <span style='font-family:Wingdings'>&agrave;</span> 100 cycles <span
style='font-family:Wingdings'>&agrave;</span> brings in data from aB + 0
through bB + 31 <span style='font-family:Wingdings'>&agrave;</span> placed in
frame 1 of set 0</p>

<p class=MsoPlainText>Access #3: <span class=GramE>aA</span> + 4 <span
style='font-family:Wingdings'>&agrave;</span> tag x...x0, set 0, offset 4 <span
style='font-family:Wingdings'>&agrave;</span> hit</p>

<p class=MsoPlainText>Access #4: bB + 4 <span style='font-family:Wingdings'>&agrave;</span>
tag y...y0, set 0, offset 4 <span style='font-family:Wingdings'>&agrave;</span>
hit</p>

<p class=MsoPlainText>...</p>

<p class=MsoPlainText>Access #15: <span class=GramE>aA</span> + 28 <span
style='font-family:Wingdings'>&agrave;</span> tag x...x0, set 0, offset 28 <span
style='font-family:Wingdings'>&agrave;</span> hit</p>

<p class=MsoPlainText>Access #16: bB + 28 <span style='font-family:Wingdings'>&agrave;</span>
tag y...y0, set 0, offset 28 <span style='font-family:Wingdings'>&agrave;</span>
hit</p>

<p class=MsoPlainText>Access #17: aA + 32 <span style='font-family:Wingdings'>&agrave;</span>
tag x...x0, set 1, offset 0 <span style='font-family:Wingdings'>&agrave;</span>
miss –-&gt; 100 cycles <span style='font-family:Wingdings'>&agrave;</span> brings
in data from aA + 32 through aA + 63, placed in frame 0 of set 1<br>
Access #18: bB+ 32 <span style='font-family:Wingdings'>&agrave;</span> tag
y...y0, set 1, offset 0 <span style='font-family:Wingdings'>&agrave;</span>
miss <span style='font-family:Wingdings'>&agrave;</span> 100 cycles <span
style='font-family:Wingdings'>&agrave;</span> brings in data from aB + 32
through bB + 63 <span style='font-family:Wingdings'>&agrave;</span> placed in
frame 1 of set 1</p>

<p class=MsoPlainText>And so on.</p>

<p class=MsoPlainText>&nbsp;</p>

<p class=MsoPlainText>5 + 4096 x 6 + 4096 x <span class=GramE>( 1</span> / 8 x
100 + 7 / 8 x 1) x 2 (two instructions experiencing one miss and seven hits per
eight references).</p>

<p class=MsoPlainText>&nbsp;</p>

</div>

</body>

</html>
