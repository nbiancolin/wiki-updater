<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0053)http://docs.sun.com/source/806-3568/ncg_goldberg.html -->
<HTML><HEAD><TITLE>What Every Computer Scientist Should Know About Floating-Point Arithmetic</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.5730.11" name=GENERATOR>
<META content=SunLook1.0 name=TEMPLATEBASE>
<META content="Wed Apr 05 20:07:16 2000" name=LASTUPDATED></HEAD>
<BODY bgColor=#ffffff><!-- BEGINNING OF NAVIGATION BAR ------------------------------------------------- -->
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR bgColor=#cccccc>
    <TD align=left>&nbsp;&nbsp;<FONT face=helvetica,arial size=2>Numerical 
      Computation Guide</FONT> </TD>
    <TD vAlign=top align=right><A href="http://docs.sun.com/index.html"><IMG 
      height=26 alt=Home 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/home01.gif" 
      width=30 border=0></A><A 
      href="http://docs.sun.com/source/806-3568/ncgTOC.html"><IMG height=26 
      alt=Contents 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/toc01.gif" 
      width=30 border=0></A><A 
      href="http://docs.sun.com/source/806-3568/ncg_x86.html"><IMG height=26 
      alt=Previous 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/prev01.gif" 
      width=30 border=0></A><A 
      href="http://docs.sun.com/source/806-3568/ncg_compliance.html"><IMG 
      height=26 alt=Next 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/next01.gif" 
      width=30 border=0></A><A 
      href="http://docs.sun.com/source/806-3568/ncgIX.html"><IMG height=26 
      alt=Index 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/index01.gif" 
      width=30 border=0></A></TD></TR></TBODY></TABLE><!-- END OF NAVIGATION BAR ------------------------------------------------------- --><BR 
clear=all>
<HR>

<BLOCKQUOTE>
  <DIV align=center>
  <H1 align=left><A name=4675></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" color=#003366>Appendix D 
  </FONT></H1></DIV>
  <H1 align=left><A name=674></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" color=#003366>What Every Computer 
  Scientist Should Know About Floating-Point Arithmetic</FONT> </H1>
  <P>
  <HR noShade SIZE=1>
  <A name=678></A><FONT face="Verdana, Arial, Helvetica, sans-serif"><B>Note – 
  </B>This appendix is an edited reprint of the paper <EM>What Every Computer 
  Scientist Should Know About Floating-Point Arithmetic</EM>, by David Goldberg, 
  published in the March, 1991 issue of Computing Surveys. Copyright 1991, 
  Association for Computing Machinery, Inc., reprinted by permission. </FONT>
  <HR noShade SIZE=1>

  <P></P>
  <H2><A name=852></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Abstract</FONT> </H2>
  <P><A name=764></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Floating-point arithmetic is 
  considered an esoteric subject by many people. This is rather surprising 
  because floating-point is ubiquitous in computer systems. Almost every 
  language has a floating-point datatype; computers from PCs to supercomputers 
  have floating-point accelerators; most compilers will be called upon to 
  compile floating-point algorithms from time to time; and virtually every 
  operating system must respond to floating-point exceptions such as overflow. 
  This paper presents a tutorial on those aspects of floating-point that have a 
  direct impact on designers of computer systems. It begins with background on 
  floating-point representation and rounding error, continues with a discussion 
  of the IEEE floating-point standard, and concludes with numerous examples of 
  how computer builders can better support floating-point.</FONT> </P>
  <P><A name=765></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Categories and Subject 
  Descriptors: (Primary) C.0 [Computer Systems Organization]: General -- 
  <EM>instruction set design</EM>; D.3.4 [Programming Languages]: Processors -- 
  <EM>compilers, optimization</EM>; G.1.0 [Numerical Analysis]: General -- 
  <EM>computer arithmetic, error analysis, numerical algorithms</EM> (Secondary) 
  </FONT></P>
  <P><A name=751></A><FONT face="Verdana, Arial, Helvetica, sans-serif">D.2.1 
  [Software Engineering]: Requirements/Specifications -- <EM>languages</EM>; 
  D.3.4 Programming Languages]: Formal Definitions and Theory -- 
  <EM>semantics</EM>; D.4.1 Operating Systems]: Process Management -- 
  <EM>synchronization</EM>.</FONT> </P>
  <P><A name=769></A><FONT face="Verdana, Arial, Helvetica, sans-serif">General 
  Terms: Algorithms, Design, Languages</FONT> </P>
  <P><A name=771></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Additional Key Words and Phrases: 
  Denormalized number, exception, floating-point, floating-point standard, 
  gradual underflow, guard digit, NaN, overflow, relative error, rounding error, 
  rounding mode, ulp, underflow.</FONT> </P>
  <H2><A name=731></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Introduction</FONT> </H2>
  <P><A name=679></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Builders 
  of computer systems often need information about floating-point arithmetic. 
  There are, however, remarkably few sources of detailed information about it. 
  One of the few books on the subject, <EM>Floating-Point Computation</EM> by 
  Pat Sterbenz, is long out of print. This paper is a tutorial on those aspects 
  of floating-point arithmetic (<EM>floating-point </EM>hereafter) that have a 
  direct connection to systems building. It consists of three loosely connected 
  parts. The first section, <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#680">Rounding 
  Error</A>, discusses the implications of using different rounding strategies 
  for the basic operations of addition, subtraction, multiplication and 
  division. It also contains background information on the two methods of 
  measuring rounding error, ulps and <CODE>relative</CODE> <CODE>error</CODE>. 
  The second part discusses the IEEE floating-point standard, which is becoming 
  rapidly accepted by commercial hardware manufacturers. Included in the IEEE 
  standard is the rounding method for basic operations. The discussion of the 
  standard draws on the material in the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#680">Rounding 
  Error</A>. The third part discusses the connections between floating-point and 
  the design of various aspects of computer systems. Topics include instruction 
  set design, optimizing compilers and exception handling. </FONT></P>
  <P><A name=675></A><FONT face="Verdana, Arial, Helvetica, sans-serif">I have 
  tried to avoid making statements about floating-point without also giving 
  reasons why the statements are true, especially since the justifications 
  involve nothing more complicated than elementary calculus. Those explanations 
  that are not central to the main argument have been grouped into a section 
  called "The Details," so that they can be skipped if desired. In particular, 
  the proofs of many of the theorems appear in this section. The end of each 
  proof is marked with the <FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=1>z</FONT> symbol. When a proof is not included, the <FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT> appears 
  immediately following the statement of the theorem. </FONT></P>
  <H2><A name=680></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Rounding Error </FONT></H2>
  <P><A name=681></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Squeezing infinitely many real 
  numbers into a finite number of bits requires an approximate representation. 
  Although there are infinitely many integers, in most programs the result of 
  integer computations can be stored in 32 bits. In contrast, given any fixed 
  number of bits, most calculations with real numbers will produce quantities 
  that cannot be exactly represented using that many bits. Therefore the result 
  of a floating-point calculation must often be rounded in order to fit back 
  into its finite representation. This rounding error is the characteristic 
  feature of floating-point computation. The section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#689">Relative 
  Error and Ulps</A> describes how it is measured. </FONT></P>
  <P><A name=676></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Since 
  most floating-point calculations have rounding error anyway, does it matter if 
  the basic arithmetic operations introduce a little bit more rounding error 
  than necessary? That question is a main theme throughout this section. The 
  section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#693">Guard 
  Digits</A> discusses<EM> guard </EM>digits, a means of reducing the error when 
  subtracting two nearby numbers. Guard digits were considered sufficiently 
  important by IBM that in 1968 it added a guard digit to the double precision 
  format in the System/360 architecture (single precision already had a guard 
  digit), and retrofitted all existing machines in the field. Two examples are 
  given to illustrate the utility of guard digits. </FONT></P>
  <P><A name=1362></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  IEEE standard goes further than just requiring the use of a guard digit. It 
  gives an algorithm for addition, subtraction, multiplication, division and 
  square root, and requires that implementations produce the same result as that 
  algorithm. Thus, when a program is moved from one machine to another, the 
  results of the basic operations will be the same in every bit if both machines 
  support the IEEE standard. This greatly simplifies the porting of programs. 
  Other uses of this precise specification are given in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#704">Exactly 
  Rounded Operations</A>. </FONT></P>
  <H3><A name=682></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Floating-point Formats </FONT></H3>
  <P><A name=683></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Several 
  different representations of real numbers have been proposed, but by far the 
  most widely used is the floating-point representation.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1370"><SUP>1</SUP></A> 
  Floating-point representations have a base <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  (which is always assumed to be even) and a precision <FONT 
  face=Arial,Helvetica><EM>p</EM></FONT>. If <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10 and <FONT face=Arial,Helvetica><EM>p</EM></FONT> = 3, then the number 0.1 
  is represented as 1.00 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-1</SUP>. If 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2 and <FONT face=Arial,Helvetica><EM>p</EM></FONT>&nbsp;=&nbsp;24, then the 
  decimal number 0.1 cannot be represented exactly, but is approximately 
  1.10011001100110011001101<FONT face="Verdana, Arial, Helvetica, sans-serif"> 
  ×</FONT> 2<SUP>-4</SUP>. </FONT></P>
  <P><A name=10061></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In 
  general, a floating-point number will be represented as <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">±</FONT> <FONT 
  face=Arial,Helvetica><EM>d.dd... d</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">× <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP>, 
  where <FONT face=Arial,Helvetica><EM>d.dd... d</EM></FONT> is called the 
  <EM>significand<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1377"><SUP>2</SUP></A></EM> 
  and has<EM> </EM><FONT face=Arial,Helvetica><EM>p</EM></FONT> digits. More 
  precisely <FONT face="Verdana, Arial, Helvetica, sans-serif">±</FONT> <FONT 
  face=Arial,Helvetica><EM>d</EM></FONT><SUB>0</SUB><FONT 
  face=Arial,Helvetica><EM> . d</EM></FONT><SUB>1</SUB><FONT 
  face=Arial,Helvetica><EM> d</EM></FONT><SUB>2</SUB> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
  face=Arial,Helvetica><EM>d</EM></FONT><SUB>p-1</SUB> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP> 
  represents the number </FONT></P><A name=687></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(1) <IMG height=25 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg283.gif" 
  width=260> .<BR></FONT>
  <P><A name=13488></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  term <EM>floating-point number</EM> will be used to mean a real number that 
  can be exactly represented in the format under discussion. Two other 
  parameters associated with floating-point representations are the largest and 
  smallest allowable exponents, <FONT 
  face=Arial,Helvetica><EM>e</EM></FONT><SUB>max</SUB> and <FONT 
  face=Arial,Helvetica><EM>e</EM></FONT><SUB>min</SUB>. Since there are <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>p</SUP> 
  possible significands, and <FONT 
  face=Arial,Helvetica><EM>e</EM></FONT><SUB>max</SUB> - <FONT 
  face=Arial,Helvetica><EM>e</EM></FONT><SUB>min</SUB> + 1 possible exponents, a 
  floating-point number can be encoded in</FONT> </P><A name=1366></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg278.gif" 
  width=212> <BR></FONT>
  <P><A name=1371></A><FONT face="Verdana, Arial, Helvetica, sans-serif">bits, 
  where the final +1 is for the sign bit. The precise encoding is not important 
  for now. </FONT></P>
  <P><A name=1372></A><FONT face="Verdana, Arial, Helvetica, sans-serif">There 
  are two reasons why a real number might not be exactly representable as a 
  floating-point number. The most common situation is illustrated by the decimal 
  number 0.1. Although it has a finite decimal representation, in binary it has 
  an infinite repeating representation. Thus when <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, the number 0.1 lies strictly between two floating-point numbers and is 
  exactly representable by neither of them. A less common situation is that a 
  real number is out of range, that is, its absolute value is larger than <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg213.gif" 
  width=28> or smaller than 1.0 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg218.gif" 
  width=27> . Most of this paper discusses issues due to the first reason. 
  However, numbers that are out of range will be discussed in the sections <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#918">Infinity</A> 
  and <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#929">Denormalized 
  Numbers</A>. </FONT></P>
  <P><A name=684></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Floating-point representations 
  are not necessarily unique. For example, both 0.01&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;10<SUP>1</SUP> and 
  1.00 <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
  10<SUP>-1</SUP> represent 0.1. If the leading digit is nonzero (<FONT 
  face=Arial,Helvetica><EM>d</EM></FONT><SUB>0</SUB> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/notequal.gif"></FONT> 
  0 in equation <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#687">(1)</A> 
  above), then the representation is said to be <EM>normalized</EM>. The 
  floating-point number 1.00 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-1</SUP> is 
  normalized, while 0.01 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>1</SUP> is not. 
  When <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>&nbsp;= 
  2, <FONT face=Arial,Helvetica><EM>p</EM></FONT> = 3, <FONT 
  face=Arial,Helvetica><EM>e</EM></FONT><SUB>min</SUB>&nbsp;= -1 and <FONT 
  face=Arial,Helvetica><EM>e</EM></FONT><SUB>max</SUB> = 2 there are 16 
  normalized floating-point numbers, as shown in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1374">FIGURE&nbsp;D-1</A>. 
  The bold hash marks correspond to numbers whose significand is 1.00. Requiring 
  that a floating-point representation be normalized makes the representation 
  unique. Unfortunately, this restriction makes it impossible to represent zero! 
  A natural way to represent 0 is with 1.0&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg304.gif" 
  width=42> , since<SUP> </SUP>this preserves the fact that the numerical 
  ordering of nonnegative real numbers corresponds to the lexicographic ordering 
  of their floating-point representations.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#685"><SUP>3</SUP></A> 
  When the exponent is stored in a <FONT face=Arial,Helvetica><EM>k</EM></FONT> 
  bit field, that means that only 2<SUP><EM>k</EM></SUP> - 1 values are 
  available for use as exponents, since one must be reserved to represent 0. 
  </FONT></P>
  <P><A name=691></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Note 
  that the <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> in a 
  floating-point number is part of the notation, and different from a 
  floating-point multiply operation. The meaning of the <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> symbol should be clear 
  from the context. For example, the expression (2.5 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-3</SUP>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> (4.0 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>2</SUP>) involves 
  only a single floating-point multiplication.</FONT> </P><A name=1373></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=71 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg251.gif" 
  width=700> <BR></FONT><A name=1374></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>FIGURE D-1 Normalized 
  numbers when <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, <FONT face=Arial,Helvetica><EM>p</EM></FONT> = 3,<FONT 
  face=Arial,Helvetica><EM> e</EM></FONT><SUB>min</SUB> = -1, <FONT 
  face=Arial,Helvetica><EM>e</EM></FONT><SUB>max</SUB> = 2<BR></FONT>
  <H3><A name=689></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Relative Error and Ulps </FONT></H3>
  <P><A name=688></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Since 
  rounding error is inherent in floating-point computation, it is important to 
  have a way to measure this error. Consider the floating-point format with 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>&nbsp;= 
  10 and <FONT face=Arial,Helvetica><EM>p</EM></FONT> = 3, which will be used 
  throughout this section. If the result of a floating-point computation is 3.12 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-2</SUP>, 
  and the answer when computed to infinite precision is .0314, it is clear that 
  this is in error by 2 units in the last place. Similarly, if the real number 
  .0314159 is represented as 3.14 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-2</SUP>, then it 
  is in error by .159 units in the last place. In general, if the floating-point 
  number <FONT face=Arial,Helvetica><EM>d.d</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
  face=Arial,Helvetica><EM>d</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP> 
  is used to represent <FONT face=Arial,Helvetica><EM>z</EM></FONT>, then it is 
  in error by <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakmidl.gif"></FONT><FONT 
  face=Arial,Helvetica><EM>d.d</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
  face=Arial,Helvetica><EM>d</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> - </FONT>(<FONT 
  face=Arial,Helvetica><EM>z</EM></FONT>/<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP>)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakmidl.gif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>p-1 
  </EM></SUP>units in the last place.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#690"><SUP>4</SUP></A><SUP>,</SUP> 
  <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#728"><SUP>5</SUP></A> 
  The term <EM>ulps</EM> will be used as shorthand for "units in the last 
  place." If the result of a calculation is the floating-point number nearest to 
  the correct result, it still might be in error by as much as .5 ulp. Another 
  way to measure the difference between a floating-point number and the real 
  number it is approximating is <EM>relative error</EM>, which is simply the 
  difference between the two numbers divided by the real number. For example the 
  relative error committed when approximating 3.14159 by 3.14 × 10<SUP>0</SUP> 
  is .00159/3.14159&nbsp;<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  .0005. </FONT></P>
  <P><A name=714></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To 
  compute the relative error that corresponds to .5 ulp, observe that when a 
  real number is approximated by the closest possible floating-point number<EM> 
  </EM><FONT face=Arial,Helvetica><EM>d.dd</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
  face=Arial,Helvetica><EM>dd</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> ×</FONT><STRONG> </STRONG><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP>,<STRONG> 
  </STRONG>the error can be as large as 0.00<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>00<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>'<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> × <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP>, 
  where <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>' 
  is the digit <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2, 
  there are <FONT face=Arial,Helvetica><EM>p</EM></FONT> units in the 
  significand of the floating-point number, and <FONT 
  face=Arial,Helvetica><EM>p</EM></FONT><EM> </EM>units of 0 in the significand 
  of the error. This error is ((<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>-p</EM></SUP>) 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP>. 
  Since numbers of the form <FONT face=Arial,Helvetica><EM>d.dd</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
  face=Arial,Helvetica><EM>dd</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP> 
  all have the same absolute error, but have values that range between <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP> 
  and <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP>, 
  the relative error ranges between ((<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>-p</EM></SUP>) 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">× <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP>/<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP> 
  and ((<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>-p</EM></SUP>) 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">× <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP>/<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e+1</EM></SUP>. 
  That is, </FONT></P><A name=5736></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(2) <IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg36.gif" 
  width=105> <BR></FONT>
  <P><A name=716></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In 
  particular, the relative error corresponding to .5 ulp can vary by a factor of 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>. 
  This factor is called the <EM>wobble</EM>. Setting <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  = (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>-p</EM></SUP> 
  to the largest of the bounds in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5736">(2)</A> 
  above, we can say that when a real number is rounded to the closest 
  floating-point number, the relative error is always bounded by <FONT 
  face=Arial,Helvetica><EM>e</EM></FONT>, which is referred to as <EM>machine 
  epsilon</EM>. </FONT></P>
  <P><A name=4695></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In the 
  example above, the relative error was .00159/3.14159 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  .0005. In order to avoid such small numbers, the relative error is normally 
  written as a factor times <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>, 
  which in this case is <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  = (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>-p</EM></SUP> 
  = 5(10)<SUP>-3</SUP> = .005. Thus the relative error would be expressed as 
  (.00159/3.14159)/.005) <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"> 
  <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  0.1<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  </FONT></P>
  <P><A name=4698></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To 
  illustrate the difference between ulps and relative error, consider the real 
  number <FONT face=Arial,Helvetica><EM>x</EM></FONT> = 12.35. It is 
  approximated by <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg298.gif" 
  width=10> = 1.24<FONT face="Verdana, Arial, Helvetica, sans-serif"> ×</FONT> 
  10<SUP>1</SUP>. The error is 0.5 ulps, the relative error is 0.<FONT 
  face=Arial,Helvetica><EM>8</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  Next consider the computation 8<IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg302.gif" 
  width=10> . The exact value is 8<FONT face=Arial,Helvetica><EM>x</EM></FONT> = 
  98.8, while the computed value is 8<IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg126.gif" 
  width=10> = 9.92 <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
  10<SUP>1</SUP>. The error is now 4.0 ulps, but the relative error is still 
  0.<FONT face=Arial,Helvetica><EM>8</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  The error measured in ulps is 8 times larger, even though the relative error 
  is the same. In general, when the base is <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>, 
  a fixed relative error expressed in ulps can wobble by a factor of up to <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>. 
  And conversely, as equation <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5736">(2)</A> 
  above shows, a fixed error of .5 ulps results in a relative error that can 
  wobble by <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>.</FONT> 
  </P>
  <P><A name=4701></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  most natural way to measure rounding error is in ulps. For example rounding to 
  the nearest floating-point number corresponds to an error of less than or 
  equal to .5 ulp. However, when analyzing the rounding error caused by various 
  formulas, relative error is a better measure. A good illustration of this is 
  the analysis in the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1129">Theorem 
  9</A>. Since <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  can overestimate the effect of rounding to the nearest floating-point number 
  by the wobble factor of <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>, 
  error estimates of formulas will be tighter on machines with a small <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>. 
  </FONT></P>
  <P><A name=4702></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
  only the order of magnitude of rounding error is of interest, ulps and <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  may be used interchangeably, since they differ by at most a factor of <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>. 
  For example, when a floating-point number is in error by <FONT 
  face=Arial,Helvetica><EM>n</EM></FONT> ulps, that means that the number of 
  contaminated digits is log<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><FONT 
  face=Arial,Helvetica><EM> n</EM></FONT>. If the relative error in a 
  computation is <FONT face=Arial,Helvetica><EM>n</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>, 
  then </FONT></P><A name=1378></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(3) contaminated digits 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  log<SUB><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></SUB><FONT 
  face=Arial,Helvetica><EM> n</EM></FONT>.<BR></FONT>
  <H3><A name=693></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Guard Digits </FONT></H3>
  <P><A name=694></A><FONT face="Verdana, Arial, Helvetica, sans-serif">One 
  method of computing the difference between two floating-point numbers is to 
  compute the difference exactly and then round it to the nearest floating-point 
  number. This is very expensive if the operands differ greatly in size. 
  Assuming <FONT face=Arial,Helvetica><EM>p</EM></FONT> = 3, 2.15 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>12</SUP> - 1.25 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-5</SUP> 
  would be calculated as </FONT></P>
  <DL>
    <DL>
      <DT><A name=1379></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>x</EM></FONT> = 2.15<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"> ×</FONT> 10<SUP>12 
      <BR></SUP><FONT face=Arial,Helvetica><EM>y</EM></FONT> = 
      .0000000000000000125<FONT face="Verdana, Arial, Helvetica, sans-serif"> 
      ×</FONT> 10<SUP>12<BR></SUP><FONT face=Arial,Helvetica><EM>x</EM></FONT> - 
      <FONT face=Arial,Helvetica><EM>y</EM></FONT> = 2.1499999999999999875 <FONT 
      face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
      10<SUP>12</SUP></FONT> </DT></DL></DL>
  <P><A name=695></A><FONT face="Verdana, Arial, Helvetica, sans-serif">which 
  rounds to 2.15 <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
  10<SUP>12</SUP>. Rather than using all these digits, floating-point hardware 
  normally operates on a fixed number of digits. Suppose that the number of 
  digits kept is <FONT face=Arial,Helvetica><EM>p</EM></FONT>, and that when the 
  smaller operand is shifted right, digits are simply discarded (as opposed to 
  rounding). Then 2.15&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;10<SUP>12</SUP>&nbsp;-&nbsp;1.25&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;10<SUP>-5</SUP> 
  becomes </FONT></P>
  <DL>
    <DL>
      <DT><A name=1382></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>x</EM></FONT> = 2.15<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"> ×</FONT> 10<SUP>12 
      <BR></SUP><FONT face=Arial,Helvetica><EM>y</EM></FONT> = 0.00<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"> ×</FONT> 
      10<SUP>12<BR></SUP><FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
      face=Arial,Helvetica><EM>y</EM></FONT> = 2.15 <FONT 
      face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
      10<SUP>12</SUP></FONT> </DT></DL></DL>
  <P><A name=696></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  answer is exactly the same as if the difference had been computed exactly and 
  then rounded. Take another example: 10.1 - 9.93. This becomes </FONT></P>
  <DL>
    <DL>
      <DT><A name=1383></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>x</EM></FONT> = 1.01 <FONT 
      face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>1 
      <BR></SUP><FONT face=Arial,Helvetica><EM>y</EM></FONT> = 0.99<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"> ×</FONT> 
      10<SUP>1<BR></SUP><FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
      face=Arial,Helvetica><EM>y</EM></FONT> = .02<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"> ×</FONT> 
      10<SUP>1</SUP></FONT> </DT></DL></DL>
  <P><A name=697></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  correct answer is .17, so the computed difference is off by 30 ulps and is 
  wrong in every digit! How bad can the error be?</FONT> </P>
  <H4><A name=1367></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 1 </FONT></H4>
  <DL>
    <DT><A name=1381></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>Using a floating-point 
    format with parameters </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><EM> 
    </EM><EM>and</EM><EM> </EM><FONT face=Arial,Helvetica><EM>p</EM></FONT><EM>, 
    and computing differences using </EM><FONT 
    face=Arial,Helvetica><EM>p</EM></FONT><EM> </EM><EM>digits, the relative 
    error of the result can be as large as</EM><EM> </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><EM> 
    </EM>-<EM> 1</EM>. </FONT></DT></DL>
  <H4><A name=1368></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H4>
  <DL>
    <DT><A name=1380></A><FONT face="Verdana, Arial, Helvetica, sans-serif">A 
    relative error of <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
    - 1 in the expression <FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT> occurs when <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> = 1.00<FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT>0 and <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT>&nbsp;=&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif">.<IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/rho.gif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/rho.gif">...<IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/rho.gif"></FONT>, 
    where <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/rho.gif"></FONT> 
    = <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
    - 1. Here <FONT face=Arial,Helvetica><EM>y</EM></FONT> has <FONT 
    face=Arial,Helvetica><EM>p</EM></FONT> digits (all equal to <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/rho.gif"></FONT>). 
    The exact difference is <FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT> = <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP>. 
    However, when computing the answer using only <FONT 
    face=Arial,Helvetica><EM>p</EM></FONT> digits, the rightmost digit of <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT> gets shifted off, and so the computed 
    difference is <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP><SUP>+1</SUP>. 
    Thus the error is <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP>&nbsp;- 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP><SUP>+1</SUP> 
    = <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP> 
    (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
    - 1), and the relative error is <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP>(<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
    - 1)/<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP> 
    = <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
    - 1. <FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=1>z</FONT></FONT> </DT></DL>
  <P><A name=1369></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>=2, 
  the relative error can be as large as the result, and when <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>=10, 
  it can be 9 times larger. Or to put it another way, when <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>=2, 
  equation <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1378">(3)</A> 
  shows that the number of contaminated digits is log<SUB>2</SUB>(1/<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>) 
  = log<SUB>2</SUB>(2<SUP><EM>p</EM></SUP>) = <FONT 
  face=Arial,Helvetica><EM>p</EM></FONT>. That is, all of the <FONT 
  face=Arial,Helvetica><EM>p</EM></FONT> digits in the result are wrong! Suppose 
  that one extra digit is added to guard against this situation (a <EM>guard 
  digit</EM>). That is, the smaller number is truncated to <FONT 
  face=Arial,Helvetica><EM>p</EM></FONT> + 1 digits, and then the result of the 
  subtraction is rounded to <FONT face=Arial,Helvetica><EM>p</EM></FONT> digits. 
  With a guard digit, the previous example becomes </FONT></P>
  <DL>
    <DL>
      <DT><A name=9503></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>x</EM></FONT> = 1.01<FONT 
      face="Verdana, Arial, Helvetica, sans-serif">0 ×</FONT> 
      10<SUP>1<BR></SUP><FONT face=Arial,Helvetica><EM>y</EM></FONT> = 
      0.993<FONT face="Verdana, Arial, Helvetica, sans-serif"> ×</FONT> 
      10<SUP>1<BR></SUP><FONT face=Arial,Helvetica><EM>x</EM></FONT> - y = .017 
      <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
      10<SUP>1</SUP></FONT> </DT></DL></DL>
  <P><A name=698></A><FONT face="Verdana, Arial, Helvetica, sans-serif">and the 
  answer is exact. With a single guard digit, the relative error of the result 
  may be greater than <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>, 
  as in 110 - 8.59. </FONT></P>
  <DL>
    <DL>
      <DT><A name=677></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>x</EM></FONT> = 1.1<FONT 
      face="Verdana, Arial, Helvetica, sans-serif">0 ×</FONT> 10<SUP>2 
      <BR></SUP><FONT face=Arial,Helvetica><EM>y</EM></FONT> = .085<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"> ×</FONT> 
      10<SUP>2<BR></SUP><FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
      face=Arial,Helvetica><EM>y</EM></FONT> = 1.015 <FONT 
      face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
      10<SUP>2</SUP></FONT> </DT></DL></DL>
  <P><A name=706></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
  rounds to 102, compared with the correct answer of 101.41, for a relative 
  error of .006, which is greater than <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  = .005. In general, the relative error of the result can be only slightly 
  larger than <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  More precisely, </FONT></P>
  <H4><A name=699></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 2 </FONT></H4>
  <DL>
    <DT><A name=1385></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>If </EM><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><EM> and </EM><FONT 
    face=Arial,Helvetica><EM>y</EM></FONT><EM> are floating-point numbers in a 
    format with parameters </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><EM> 
    </EM><EM>and </EM><FONT face=Arial,Helvetica><EM>p</EM></FONT><EM>, and if 
    subtraction is done with </EM><FONT 
    face=Arial,Helvetica><EM>p</EM></FONT><EM> + 1 digits (i.e. one guard 
    digit), then the relative rounding error in the result is less than 
    2</EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    </FONT></DT></DL>
  <P><A name=1388></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
  theorem will be proven in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1127">Rounding 
  Error</A>. Addition is included in the above theorem since <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> and <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT> can be positive or negative. 
</FONT></P>
  <H3><A name=700></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Cancellation</FONT> </H3>
  <P><A name=701></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The last 
  section can be summarized by saying that without a guard digit, the relative 
  error committed when subtracting two nearby quantities can be very large. In 
  other words, the evaluation of any expression containing a subtraction (or an 
  addition of quantities with opposite signs) could result in a relative error 
  so large that <EM>all</EM> the digits are meaningless (Theorem 1). When 
  subtracting nearby quantities, the most significant digits in the operands 
  match and cancel each other. There are two kinds of cancellation: catastrophic 
  and benign. </FONT></P>
  <P><A name=9518></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><EM>Catastrophic 
  cancellation</EM> occurs when the operands are subject to rounding errors. For 
  example in the quadratic formula, the expression <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> - 4<FONT 
  face=Arial,Helvetica><EM>ac</EM></FONT> occurs. The quantities <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> and 4<FONT 
  face=Arial,Helvetica><EM>ac</EM></FONT> are subject to rounding errors since 
  they are the results of floating-point multiplications. Suppose that they are 
  rounded to the nearest floating-point number, and so are accurate to within 
  <EM>.5 </EM>ulp. When they are subtracted, cancellation can cause many of the 
  accurate digits to disappear, leaving behind mainly digits contaminated by 
  rounding error. Hence the difference might have an error of many ulps. For 
  example, consider <FONT face=Arial,Helvetica><EM>b</EM></FONT> = 3.34, <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT>&nbsp;= 1.22, and <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> = 2.28. The exact value of <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP>&nbsp;-&nbsp;4<FONT 
  face=Arial,Helvetica><EM>ac</EM></FONT> is .0292. But <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> rounds to 11.2 and 4<FONT 
  face=Arial,Helvetica><EM>ac </EM></FONT>rounds to 11.1, hence the final answer 
  is .1 which is an error by 70 ulps, even though 11.2 - 11.1 is exactly equal 
  to .1<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#9521"><SUP>6</SUP></A>. 
  The subtraction did not introduce any error, but rather exposed the error 
  introduced in the earlier multiplications.</FONT> </P>
  <P><A name=707></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><EM>Benign cancellation</EM> 
  occurs when subtracting exactly known quantities. If <EM>x</EM> and <EM>y</EM> 
  have no rounding error, then by Theorem 2 if the subtraction is done with a 
  guard digit, the difference <EM>x</EM>-y has a very small relative error (less 
  than 2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>).</FONT> 
  </P>
  <P><A name=708></A><FONT face="Verdana, Arial, Helvetica, sans-serif">A 
  formula that exhibits catastrophic cancellation can sometimes be rearranged to 
  eliminate the problem. Again consider the quadratic formula </FONT></P><A 
  name=5751></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(4) 
  <IMG height=37 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg122.gif" 
  width=233> <BR></FONT>
  <P><A name=1391></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
  <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg11.gif" 
  width=40> , then <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg16.gif" 
  width=47> does not involve a cancellation and</FONT> </P><A 
  name=11563></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG 
  height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg46.gif" 
  width=75> . <BR></FONT>
  <P><A name=11565></A><FONT face="Verdana, Arial, Helvetica, sans-serif">But 
  the other addition (subtraction) in one of the formulas will have a 
  catastrophic cancellation. To avoid this, multiply the numerator and 
  denominator of <FONT face=Arial,Helvetica><EM>r</EM></FONT><SUB>1</SUB> 
  by</FONT> </P><A name=11566></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg51.gif" 
  width=84> <BR></FONT>
  <P><A name=11568></A><FONT face="Verdana, Arial, Helvetica, sans-serif">(and 
  similarly for <FONT face=Arial,Helvetica><EM>r</EM></FONT><SUB>2</SUB>) to 
  obtain </FONT></P><A name=5811></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(5) <IMG height=37 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg56.gif" 
  width=233> <BR></FONT>
  <P><A name=10672></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If 
  <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg60.gif" 
  width=40> and <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg10.gif" 
  width=29> , then computing <FONT 
  face=Arial,Helvetica><EM>r</EM></FONT><SUB>1</SUB> using formula <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5751">(4)</A> will 
  involve a cancellation. Therefore, use formula <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5811">(5)</A> for 
  computing <FONT face=Arial,Helvetica><EM>r</EM></FONT><SUB>1</SUB> and <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5751">(4)</A> for 
  <FONT face=Arial,Helvetica><EM>r</EM></FONT><SUB>2</SUB>. On the other hand, 
  if <FONT face=Arial,Helvetica><EM>b</EM></FONT> &lt; 0, use <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5751">(4)</A> for 
  computing <FONT face=Arial,Helvetica><EM>r</EM></FONT><SUB>1</SUB> and <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5811">(5)</A> for 
  <FONT face=Arial,Helvetica><EM>r</EM></FONT><SUB>2</SUB>. </FONT></P>
  <P><A name=1393></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  expression <EM>x</EM><SUP>2</SUP> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUP>2</SUP> is another formula that 
  exhibits catastrophic cancellation. It is more accurate to evaluate it as 
  (<FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>)(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>).<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1397"><SUP>7</SUP></A> 
  Unlike the quadratic formula, this improved form still has a subtraction, but 
  it is a benign cancellation of quantities without rounding error, not a 
  catastrophic one. By Theorem 2, the relative error in 
  <EM>x</EM>&nbsp;-&nbsp;<FONT face=Arial,Helvetica><EM>y</EM></FONT> is at most 
  2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  The same is true of <EM>x</EM> +<FONT face=Arial,Helvetica><EM> y</EM></FONT>. 
  Multiplying two quantities with a small relative error results in a product 
  with a small relative error (see the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1127">Rounding 
  Error</A>). </FONT></P>
  <P><A name=725></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In order 
  to avoid confusion between exact and computed values, the following notation 
  is used. Whereas <EM>x</EM> - <FONT face=Arial,Helvetica><EM>y</EM></FONT> 
  denotes the exact difference of <EM>x</EM> and <EM>y</EM>, <EM>x</EM> <IMG 
  height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg199.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT> denotes the computed 
  difference (i.e., with rounding error). Similarly <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT>, 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT>, 
  and <IMG height=12 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg209.gif" 
  width=11> denote computed addition, multiplication, and division, 
  respectively. All caps indicate the computed value of a function, as in 
  <CODE>LN(x)</CODE> or <CODE>SQRT(x)</CODE>. Lowercase functions and 
  traditional mathematical notation denote their exact values as in ln(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) and <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg41.gif" 
  width=18> . </FONT></P>
  <P><A name=11589></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Although (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg26.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>x</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT>) is an excellent approximation to 
  <EM>x</EM><SUP>2</SUP> - y<SUP>2</SUP>, the floating-point numbers <EM>x</EM> 
  and <EM>y</EM> might themselves be approximations to some true quantities <IMG 
  height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg35.gif" 
  width=10> and <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg40.gif" 
  width=10> . For example, <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg45.gif" 
  width=10> and <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg50.gif" 
  width=10> might be exactly known decimal numbers that cannot be expressed 
  exactly in binary. In this case, even though <EM>x</EM>&nbsp;<IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg55.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>&nbsp;y</EM></FONT> is a good 
  approximation to <FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>, it can have a huge relative error 
  compared to the true expression <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg74.gif" 
  width=28> , and so the advantage of (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>)(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) over <EM>x</EM><SUP>2</SUP> - 
  y<SUP>2</SUP> is not as dramatic. Since computing (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;+<FONT 
  face=Arial,Helvetica><EM>&nbsp;y</EM></FONT>)(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> -<FONT face=Arial,Helvetica><EM> 
  y</EM></FONT>) is about the same amount of work as computing 
  <EM>x</EM><SUP>2</SUP>&nbsp;-&nbsp;y<SUP>2</SUP>, it is clearly the preferred 
  form in this case. In general, however, replacing a catastrophic cancellation 
  by a benign one is not worthwhile if the expense is large, because the input 
  is often (but not always) an approximation. But eliminating a cancellation 
  entirely (as in the quadratic formula) is worthwhile even if the data are not 
  exact. Throughout this paper, it will be assumed that the floating-point 
  inputs to an algorithm are exact and that the results are computed as 
  accurately as possible.</FONT> </P>
  <P><A name=711></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  expression <EM>x</EM><SUP>2</SUP> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUP>2</SUP> is more accurate when 
  rewritten as (<FONT face=Arial,Helvetica><EM>x</EM></FONT> -<FONT 
  face=Arial,Helvetica><EM> y</EM></FONT>)(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> +<FONT face=Arial,Helvetica><EM> 
  y</EM></FONT>) because a catastrophic cancellation is replaced with a benign 
  one. We next present more interesting examples of formulas exhibiting 
  catastrophic cancellation that can be rewritten to exhibit only benign 
  cancellation. </FONT></P>
  <P><A name=1402></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  area of a triangle can be expressed directly in terms of the lengths of its 
  sides <FONT face=Arial,Helvetica><EM>a</EM></FONT>, <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>, and <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> as </FONT></P><A name=1403></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(6) <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg263.gif" 
  width=287> <BR></FONT>
  <P><A name=10676></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">(Suppose the triangle is very 
  flat; that is, <FONT face=Arial,Helvetica><EM>a</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>b</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT>. Then <FONT 
  face=Arial,Helvetica><EM>s</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>a</EM></FONT>, and the term (<FONT 
  face=Arial,Helvetica><EM>s</EM></FONT>&nbsp;-&nbsp;<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT>) in formula <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1403">(6)</A> 
  subtracts two nearby numbers, one of which may have rounding error. For 
  example, if <FONT face=Arial,Helvetica><EM>a</EM></FONT> = 9.0, <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> =<FONT face=Arial,Helvetica><EM> 
  c</EM></FONT> = 4.53, the correct value of <FONT 
  face=Arial,Helvetica><EM>s</EM></FONT> is 9.03 and <FONT 
  face=Arial,Helvetica><EM>A</EM></FONT> is 2.342.... Even though the computed 
  value of <FONT face=Arial,Helvetica><EM>s</EM></FONT> (9.05) is in error by 
  only 2 ulps, the computed value of <FONT 
  face=Arial,Helvetica><EM>A</EM></FONT> is 3.04, an error of 70 ulps. 
  </FONT></P>
  <P><A name=1404></A><FONT face="Verdana, Arial, Helvetica, sans-serif">There 
  is a way to rewrite formula <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1403">(6)</A> so 
  that it will return accurate results even for flat triangles [Kahan 1986]. It 
  is </FONT></P><A name=1405></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(7) <IMG height=35 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg279.gif" 
  width=350> <BR></FONT>
  <P><A name=10678></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If 
  <FONT face=Arial,Helvetica><EM>a</EM></FONT>, <FONT 
  face=Arial,Helvetica><EM>b, </EM></FONT>and <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> do not satisfy <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>b</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>c</EM></FONT>, rename them before applying <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1405">(7)</A>. It 
  is straightforward to check that the right-hand sides of <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1403">(6)</A> and 
  <A href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1405">(7)</A> 
  are algebraically identical. Using the values of <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT>, <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>, and <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> above gives a computed area of 2.35, 
  which is 1 ulp in error and much more accurate than the first formula.</FONT> 
  </P>
  <P><A name=712></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Although 
  formula <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1405">(7)</A> is 
  much more accurate than <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1403">(6)</A> for 
  this example, it would be nice to know how well <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1405">(7)</A> 
  performs in general. </FONT></P>
  <H4><A name=1409></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 3 </FONT></H4>
  <DL>
    <DT><A name=1407></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>The rounding error incurred 
    when using <A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1405">(7)</A> to 
    compute the area of a triangle is at most 11<IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif" size=3>, provided that 
    subtraction is performed with a guard digit, e&nbsp;</FONT><EM><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif" size=3>&nbsp;.005, and that 
    square roots are computed to within 1/2 </FONT>ulp<EM>. </EM></FONT></DT></DL>
  <P><A name=1408></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  condition that <FONT face=Arial,Helvetica><EM>e</EM></FONT> &lt; .005 is met 
  in virtually every actual floating-point system. For example when <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, <EM>p</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
  8 ensures that <FONT face=Arial,Helvetica><EM>e</EM></FONT> &lt; .005, and 
  when <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10, <EM>p</EM>&nbsp;<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT>&nbsp;3 
  is enough. </FONT></P>
  <P><A name=1410></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In 
  statements like Theorem 3 that discuss the relative error of an expression, it 
  is understood that the expression is computed using floating-point arithmetic. 
  In particular, the relative error is actually of the expression </FONT></P><A 
  name=1411></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(8) 
  <CODE>SQRT</CODE>((<FONT face=Arial,Helvetica><EM>a </EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"> 
  (</FONT><FONT face=Arial,Helvetica><EM>b</EM></FONT> <EM><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></EM><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> </FONT><FONT 
  face=Arial,Helvetica><EM>c</EM></FONT>)) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"> 
  (</FONT><FONT face=Arial,Helvetica><EM>c</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg65.gif" 
  width=13> <FONT face="Verdana, Arial, Helvetica, sans-serif">(</FONT><FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg289.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>b)) </EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>c </EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT><FONT 
  face=Arial,Helvetica><EM> </EM></FONT>(<FONT face=Arial,Helvetica><EM>a 
  </EM></FONT><IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberga.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>b</EM></FONT>)) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT><FONT 
  face=Arial,Helvetica><EM> (a </EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT><FONT 
  face=Arial,Helvetica><EM> </EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg190.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>c</EM></FONT>))) <IMG height=12 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg28.gif" 
  width=11> <FONT face=Arial,Helvetica><EM>4</EM></FONT><BR></FONT>
  <P><A name=1412></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Because 
  of the cumbersome nature of <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1411">(8)</A>, in 
  the statement of theorems we will usually say <EM>the computed value of 
  </EM><FONT face=Arial,Helvetica><EM>E</EM></FONT> rather than writing out 
  <FONT face=Arial,Helvetica><EM>E</EM></FONT> with circle notation.</FONT> </P>
  <P><A name=713></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Error 
  bounds are usually too pessimistic. In the numerical example given above, the 
  computed value of <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1405">(7)</A> is 
  2.35, compared with a true value of 2.34216 for a relative error of 0.7<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>, 
  which is much less than 11<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  The main reason for computing error bounds is not to get precise bounds but 
  rather to verify that the formula does not contain numerical problems. 
  </FONT></P>
  <P><A name=715></A><FONT face="Verdana, Arial, Helvetica, sans-serif">A final 
  example of an expression that can be rewritten to use benign cancellation is 
  (1&nbsp;+&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)<SUP><EM>n</EM></SUP>, where <IMG 
  height=17 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg15.gif" 
  width=35> . This expression arises in financial calculations. Consider 
  depositing $100 every day into a bank account that earns an annual interest 
  rate of 6%, compounded daily. If <FONT face=Arial,Helvetica><EM>n</EM></FONT> 
  = 365 and <FONT face=Arial,Helvetica><EM>i</EM></FONT> = .06, the amount of 
  money accumulated at the end of one year is </FONT></P><A name=5952></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>100<IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg78.gif" 
  width=68> <BR></FONT>
  <P><A name=10682></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">dollars. If this is computed 
  using <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2 and <EM>p</EM> = 24, the result is $37615.45 compared to the exact answer 
  of $37614.05, a discrepancy of $1.40. The reason for the problem is easy to 
  see. The expression 1 +<FONT face=Arial,Helvetica><EM> i</EM></FONT>/<FONT 
  face=Arial,Helvetica><EM>n</EM></FONT> involves adding 1 to .0001643836, so 
  the low order bits of <FONT face=Arial,Helvetica><EM>i</EM></FONT>/<FONT 
  face=Arial,Helvetica><EM>n</EM></FONT> are lost. This rounding error is 
  amplified when 1 + <FONT face=Arial,Helvetica><EM>i</EM></FONT>/<FONT 
  face=Arial,Helvetica><EM>n</EM></FONT> is raised to the <FONT 
  face=Arial,Helvetica><EM>n</EM></FONT>th power. </FONT></P>
  <P><A name=719></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  troublesome expression (1 + <FONT face=Arial,Helvetica><EM>i</EM></FONT>/<FONT 
  face=Arial,Helvetica><EM>n</EM></FONT>)<SUP><EM>n</EM></SUP> can be rewritten 
  as <FONT face=Arial,Helvetica><EM>e</EM></FONT><SUP>nln(1 + 
  </SUP><SUP><EM>i</EM></SUP><SUP>/</SUP><SUP><EM>n</EM></SUP><SUP>)</SUP>, 
  where now the problem is to compute ln(1 + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) for small <EM>x</EM>. One approach is 
  to use the approximation ln(1 + <FONT face=Arial,Helvetica><EM>x</EM></FONT>) 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT>, in which case the payment 
  becomes $37617.26, which is off by $3.21 and even less accurate than the 
  obvious formula. But there is a way to compute ln(1 + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) very accurately, as Theorem 4 shows 
  [Hewlett-Packard 1982]. This formula yields $37614.07, accurate to within two 
  cents! </FONT></P>
  <P><A name=1413></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Theorem 
  4 assumes that <CODE>LN(x)</CODE> approximates ln(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) to within 1/2 ulp. The problem it 
  solves is that when <EM>x</EM> is small, <CODE>LN</CODE>(1 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT>) is not close to ln(1 + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) because 1 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT> has lost the information in the 
  low order bits of <EM>x</EM>. That is, the computed value of 
  ln(1&nbsp;+&nbsp;<FONT face=Arial,Helvetica><EM>x</EM></FONT>) is not close to 
  its actual value when <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg47.gif" 
  width=28> . </FONT></P>
  <H4><A name=1202></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 4 </FONT></H4>
  <DL>
    <DT><A name=720></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>If ln(1 + x) is computed 
    using the formula </EM></FONT>
    <DL>
      <DT><A name=11644></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"></FONT></DT></DL></DT></DL><A 
  name=5998></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG 
  height=67 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg101.gif" 
  width=233> <BR></FONT>
  <DL>
    <DL>
      <DT><A name=11645></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"></FONT></DT></DL></DL>
  <DL>
    <DT><A name=1416></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>the relative error is at 
    most 5</EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif" size=3> when 0 </FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif" size=3> x &lt; 3/4, provided 
    subtraction is performed with a guard digit, e &lt; 0.1, and ln is computed 
    to within 1/2 ulp. </FONT></FONT></DT></DL>
  <P><A name=1414></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
  formula will work for any value of <EM>x</EM> but is only interesting for <IMG 
  height=17 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg61.gif" 
  width=35> , which is where catastrophic cancellation occurs in the naive 
  formula ln(1 + <FONT face=Arial,Helvetica><EM>x</EM></FONT>). Although the 
  formula may seem mysterious, there is a simple explanation for why it works. 
  Write ln(1 + <FONT face=Arial,Helvetica><EM>x</EM></FONT>) as</FONT> </P><A 
  name=5972></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG 
  height=36 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg70.gif" 
  width=118> . <BR></FONT>
  <P><A name=10680></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  left hand factor can be computed exactly, but the right hand factor <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)&nbsp;=&nbsp;ln(1&nbsp;+&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)/<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> will suffer a large rounding error when 
  adding 1 to <EM>x</EM>. However, <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">µ</FONT> is almost constant, 
  since ln(1 + <FONT face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT>. So changing <EM>x</EM> slightly 
  will not introduce much error. In other words, if <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg75.gif" 
  width=29> , computing <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg80.gif" 
  width=34> will be a good approximation to <EM>x</EM><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)&nbsp;=&nbsp;ln(1&nbsp;+&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>). Is there a value for <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg89.gif" 
  width=10> for which <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg86.gif" 
  width=10> and <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg99.gif" 
  width=29> can be computed accurately? There is; namely <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg95.gif" 
  width=10> = (1 <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT><FONT 
  face=Arial,Helvetica><EM> x</EM></FONT>) <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg284.gif" 
  width=13> 1, because then 1 + <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg67.gif" 
  width=10> is exactly equal to 1 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT>. </FONT></P>
  <P><A name=1415></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  results of this section can be summarized by saying that a guard digit 
  guarantees accuracy when nearby precisely known quantities are subtracted 
  (benign cancellation). Sometimes a formula that gives inaccurate results can 
  be rewritten to have much higher numerical accuracy by using benign 
  cancellation; however, the procedure only works if subtraction is performed 
  using a guard digit. The price of a guard digit is not high, because it merely 
  requires making the adder one bit wider. For a 54 bit double precision adder, 
  the additional cost is less than 2%. For this price, you gain the ability to 
  run many algorithms such as formula <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1403">(6)</A> for 
  computing the area of a triangle and the expression ln(1&nbsp;+&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>). Although most modern computers have a 
  guard digit, there are a few (such as Cray systems) that do not. </FONT></P>
  <H3><A name=704></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Exactly Rounded Operations </FONT></H3>
  <P><A name=705></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
  floating-point operations are done with a guard digit, they are not as 
  accurate as if they were computed exactly then rounded to the nearest 
  floating-point number. Operations performed in this manner will be called 
  <EM>exactly rounded</EM>.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#729"><SUP>8</SUP></A> 
  The example immediately preceding Theorem 2 shows that a single guard digit 
  will not always give exactly rounded results. The previous section gave 
  several examples of algorithms that require a guard digit in order to work 
  properly. This section gives examples of algorithms that require exact 
  rounding. </FONT></P>
  <P><A name=1417></A><FONT face="Verdana, Arial, Helvetica, sans-serif">So far, 
  the definition of rounding has not been given. Rounding is straightforward, 
  with the exception of how to round halfway cases; for example, should 12.5 
  round to 12 or 13? One school of thought divides the 10 digits in half, 
  letting {0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4} round down, and {5, 6, 7, 8, 9} 
  round up; thus 12.5 would round to 13. This is how rounding works on Digital 
  Equipment Corporation's VAX computers. Another school of thought says that 
  since numbers ending in 5 are halfway between two possible roundings, they 
  should round down half the time and round up the other half. One way of 
  obtaining this 50% behavior to require that the rounded result have its least 
  significant digit be even. Thus 12.5 rounds to 12 rather than 13 because 2 is 
  even. Which of these methods is best, round up or round to even? Reiser and 
  Knuth [1975] offer the following reason for preferring round to even. 
  </FONT></P>
  <H4><A name=1419></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 5 </FONT></H4>
  <DL>
    <DT><A name=1418></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>Let x and y be 
    floating-point numbers, and define x</EM><SUB>0</SUB><EM> = x, 
    x</EM><SUB>1</SUB><EM> = (x</EM><SUB>0</SUB><EM> </EM><IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg303.gif" 
    width=13> <EM>y) </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT><EM> 
    y, </EM><FONT face="Verdana, Arial, Helvetica, sans-serif">...</FONT><EM>, 
    x</EM><SUB>n</SUB><EM>&nbsp;= (x</EM><SUB>n-1</SUB><EM>&nbsp;</EM><IMG 
    height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg293.gif" 
    width=13> <EM>&nbsp;y) </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT><EM> 
    y. If </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT><EM> 
    and </EM><IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg6.gif" 
    width=13> <EM>are exactly rounded using round to even, then either 
    x</EM><SUB>n</SUB><EM> = x for all n or x</EM><SUB>n</SUB><EM> = 
    x</EM><SUB>1</SUB><EM> for all n</EM> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
    1. z</FONT> </DT></DL>
  <P><A name=722></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To 
  clarify this result, consider <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10, <EM>p</EM> = 3 and let <EM>x</EM> = 1.00, <EM>y</EM> = -.555. When 
  rounding up, the sequence becomes</FONT> </P><A name=11653></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><EM>x</EM><SUB>0</SUB> 
  <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg84.gif" 
  width=13> y = 1.56, <EM>x</EM><SUB>1</SUB> = 1.56 <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg93.gif" 
  width=13> .555 = 1.01, <EM>x</EM><SUB>1</SUB>&nbsp;<IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg103.gif" 
  width=13> &nbsp;y = 1.01 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  .555 = 1.57,<BR></FONT>
  <P><A name=11655></A><FONT face="Verdana, Arial, Helvetica, sans-serif">and 
  each successive value of <EM>x</EM><SUB>n</SUB> increases by .01, until 
  <EM>x</EM><SUB>n</SUB> = 9.45 (n <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  845)<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#730"><SUP>9</SUP></A>. 
  Under round to even, <EM>x</EM><SUB>n</SUB> is always 1.00. This example 
  suggests that when using the round up rule, computations can gradually drift 
  upward, whereas when using round to even the theorem says this cannot happen. 
  Throughout the rest of this paper, round to even will be used. </FONT></P>
  <P><A name=742></A><FONT face="Verdana, Arial, Helvetica, sans-serif">One 
  application of exact rounding occurs in multiple precision arithmetic. There 
  are two basic approaches to higher precision. One approach represents 
  floating-point numbers using a very large significand, which is stored in an 
  array of words, and codes the routines for manipulating these numbers in 
  assembly language. The second approach represents higher precision 
  floating-point numbers as an array of ordinary floating-point numbers, where 
  adding the elements of the array in infinite precision recovers the high 
  precision floating-point number. It is this second approach that will be 
  discussed here. The advantage of using an array of floating-point numbers is 
  that it can be coded portably in a high level language, but it requires 
  exactly rounded arithmetic.</FONT> </P>
  <P><A name=744></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The key 
  to multiplication in this system is representing a product <EM>x</EM>y as a 
  sum, where each summand has the same precision as <EM>x</EM> and <EM>y</EM>. 
  This can be done by splitting <EM>x</EM> and <EM>y</EM>. Writing <EM>x</EM> = 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT><SUB>h</SUB> + 
  x<SUB><EM>l</EM></SUB> and <EM>y</EM> = <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUB>h</SUB> + y<SUB><EM>l</EM></SUB>, 
  the exact product is</FONT> </P><A name=11662></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><EM>x</EM><FONT 
  face=Arial,Helvetica><EM>y</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>h</SUB><FONT 
  face=Arial,Helvetica><EM>&nbsp;y</EM></FONT><SUB>h</SUB> + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>h</SUB> <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUB>l</SUB> + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>l</SUB> <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUB>h</SUB> + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>l</SUB> <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUB>l</SUB>. <BR></FONT>
  <P><A name=11664></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If 
  <EM>x</EM> and <EM>y</EM> have <EM>p</EM> bit significands, the summands will 
  also have <EM>p</EM> bit significands provided that <EM>x</EM><SUB>l</SUB>, 
  <EM>x</EM><SUB>h</SUB>, <EM>y</EM><SUB>h</SUB>, <EM>y</EM><SUB>l</SUB> can be 
  represented using <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">[</FONT><FONT 
  face=Arial,Helvetica><EM>p</EM></FONT>/2<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">]</FONT> bits. When <FONT 
  face=Arial,Helvetica><EM>p</EM></FONT> is even, it is easy to find a 
  splitting. The number <EM>x</EM><SUB>0</SUB>.<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <EM>x</EM><SUB>p - 
  1</SUB> can be written as the sum of <EM>x</EM><SUB>0</SUB>.<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>p/2 - 1</SUB> and 0.0 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT> 0<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>p/2</SUB> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>p&nbsp;-&nbsp;1</SUB>. When 
  <EM>p</EM> is odd, this simple splitting method will not work. An extra bit 
  can, however, be gained by using negative numbers. For example, if <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, <EM>p</EM> = 5, and <EM>x</EM> = .10111, <EM>x</EM> can be split as 
  <EM>x</EM><SUB>h</SUB> = .11 and <EM>x</EM><SUB>l</SUB>&nbsp;=&nbsp;-.00001. 
  There is more than one way to split a number. A splitting method that is easy 
  to compute is due to Dekker [1971], but it requires more than a single guard 
  digit. </FONT></P>
  <H4><A name=745></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 6</FONT> </H4>
  <DL>
    <DT><A name=746></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>Let p be the floating-point 
    precision, with the restriction that p is even when </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>&nbsp;&gt;&nbsp;2<EM>, 
    and assume that floating-point operations are exactly rounded. Then if 
    </EM><FONT 
    face=Arial,Helvetica><EM>k</EM></FONT><EM>&nbsp;=&nbsp;</EM>[p/2]<EM> is 
    half the precision (rounded up) and m = </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><EM> 
    + </EM>1<EM>, x can be split as x = x</EM><SUB>h</SUB><EM> + 
    x</EM><SUB>l</SUB><EM>, where </EM></FONT></DT></DL><A name=13096></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><EM>x</EM><SUB>h</SUB><EM> 
  = (m </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT><EM>&nbsp;x)&nbsp;</EM><IMG 
  height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg112.gif" 
  width=13> <EM>&nbsp;(m </EM><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT><EM> 
  x </EM><IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg138.gif" 
  width=13> <EM>x), x</EM><SUB>l</SUB><EM> = x </EM><IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg144.gif" 
  width=13> <EM>x</EM><SUB>h</SUB><EM>, </EM><BR></FONT>
  <P><A name=13097></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><EM>and each 
  x</EM><SUB>i</SUB><EM> is representable using</EM> [p/2]<EM> bits of 
  precision.</EM> </FONT></P>
  <P><A name=8119></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To see 
  how this theorem works in an example, let <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10, <EM>p</EM> = 4, <FONT face=Arial,Helvetica><EM>b</EM></FONT> = 3.476, 
  <FONT face=Arial,Helvetica><EM>a</EM></FONT> = 3.463, and <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> = 3.479. Then <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> - <FONT 
  face=Arial,Helvetica><EM>ac</EM></FONT> rounded to the nearest floating-point 
  number is .03480, while <FONT face=Arial,Helvetica><EM>b</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT><FONT 
  face=Arial,Helvetica><EM> b</EM></FONT> = 12.08, <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>c</EM></FONT> = 12.05, and so the computed 
  value of <FONT face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> - <FONT 
  face=Arial,Helvetica><EM>ac</EM></FONT> is .03. This is an error of 480 ulps. 
  Using Theorem 6 to write <FONT face=Arial,Helvetica><EM>b</EM></FONT> = 3.5 - 
  .024, <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT>&nbsp;=&nbsp;3.5&nbsp;-&nbsp;.037, and 
  <FONT face=Arial,Helvetica><EM>c</EM></FONT>&nbsp;=&nbsp;3.5&nbsp;- .021, 
  <FONT face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> becomes 
  3.5<SUP>2</SUP> - 2 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 3.5 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> .024 + .024<SUP>2</SUP>. 
  Each summand is exact, so <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP>&nbsp;=&nbsp;12.25 - .168 + 
  .000576, where the sum is left unevaluated at this point. Similarly, <FONT 
  face=Arial,Helvetica><EM>ac</EM></FONT> = 3.5<SUP>2</SUP> - (3.5 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> .037 + 3.5 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> .021) + .037 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> .021 = 12.25 - .2030 
  +.000777. Finally, subtracting these two series term by term gives an estimate 
  for <FONT face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> - <FONT 
  face=Arial,Helvetica><EM>ac</EM></FONT> of 0&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT>&nbsp;.0350&nbsp;<IMG 
  height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg154.gif" 
  width=13> &nbsp;.000201 = .03480, which is identical to the exactly rounded 
  result. To show that Theorem 6 really requires exact rounding, consider 
  <EM>p</EM> = 3, <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, and <EM>x</EM> = 7. Then <FONT 
  face=Arial,Helvetica><EM>m</EM></FONT>&nbsp;=&nbsp;5, <FONT 
  face=Arial,Helvetica><EM>mx</EM></FONT> = 35, and <FONT 
  face=Arial,Helvetica><EM>m</EM></FONT>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT>&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;= 32. If subtraction is performed 
  with a single guard digit, then (<FONT 
  face=Arial,Helvetica><EM>m</EM></FONT>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT>&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)&nbsp;<IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg165.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>x</EM></FONT> = 28. Therefore, 
  <EM>x</EM><SUB>h</SUB> = 4 and <EM>x</EM><SUB>l</SUB> = 3, hence 
  <EM>x</EM><SUB>l</SUB> is not representable with <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">[</FONT><FONT 
  face=Arial,Helvetica><EM>p</EM></FONT><EM>/2</EM>] = 1 bit. </FONT></P>
  <P><A name=8130></A><FONT face="Verdana, Arial, Helvetica, sans-serif">As a 
  final example of exact rounding, consider dividing <FONT 
  face=Arial,Helvetica><EM>m</EM></FONT> by 10. The result is a floating-point 
  number that will in general not be equal to <FONT 
  face=Arial,Helvetica><EM>m</EM></FONT>/10. When <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, multiplying <FONT face=Arial,Helvetica><EM>m</EM></FONT>/10 by 10 will 
  restore <FONT face=Arial,Helvetica><EM>m</EM></FONT>, provided exact rounding 
  is being used. Actually, a more general fact (due to Kahan) is true. The proof 
  is ingenious, but readers not interested in such details can skip ahead to 
  section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#799">The IEEE 
  Standard</A>.</FONT> </P>
  <H4><A name=780></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 7</FONT> </H4>
  <DL>
    <DT><A name=781></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>When </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><EM> 
    = </EM>2<EM>, if </EM><FONT face=Arial,Helvetica><EM>m</EM></FONT><EM> and 
    </EM><FONT face=Arial,Helvetica><EM>n</EM></FONT><EM> are integers with |m| 
    &lt; </EM>2<SUP><EM>p - 1</EM></SUP><EM> and </EM><FONT 
    face=Arial,Helvetica><EM>n</EM></FONT><EM> has the special form n = 
    </EM>2<SUP><EM>i</EM></SUP><EM> + </EM>2<SUP><EM>j</EM></SUP><EM>, then (m 
    </EM><IMG height=12 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg69.gif" 
    width=11> <EM>n) </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT><EM> 
    n = m, provided floating-point operations are exactly rounded.</EM> 
    </FONT></DT></DL>
  <H4><A name=783></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H4>
  <DL>
    <DT><A name=784></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Scaling by a power of two is 
    harmless, since it changes only the exponent, not the significand. If <FONT 
    face=Arial,Helvetica><EM>q</EM></FONT> = <FONT 
    face=Arial,Helvetica><EM>m</EM></FONT>/<FONT 
    face=Arial,Helvetica><EM>n</EM></FONT>, then scale <FONT 
    face=Arial,Helvetica><EM>n</EM></FONT> so that 2<SUP><EM>p</EM></SUP><SUP> - 
    1</SUP> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>n</EM></FONT> &lt; 2<SUP><EM>p</EM></SUP> and 
    scale <FONT face=Arial,Helvetica><EM>m</EM></FONT> so that 1/2 &lt; <FONT 
    face=Arial,Helvetica><EM>q</EM></FONT> &lt; 1. Thus, 
    2<SUP><EM>p</EM></SUP><SUP> - 2</SUP> &lt; <FONT 
    face=Arial,Helvetica><EM>m</EM></FONT> &lt; 2<SUP><EM>p</EM></SUP>. Since 
    <FONT face=Arial,Helvetica><EM>m</EM></FONT> has <EM>p</EM> significant 
    bits, it has at most one bit to the right of the binary point. Changing the 
    sign of <FONT face=Arial,Helvetica><EM>m</EM></FONT> is harmless, so assume 
    that <FONT face=Arial,Helvetica><EM>q</EM></FONT> &gt; 0.</FONT> 
    <DT><A name=786></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If 
    <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg113.gif" 
    width=10> = <EM>m </EM><IMG height=12 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg82.gif" 
    width=11> <EM>n</EM>, to prove the theorem requires showing that 
  </FONT></DT></DL><A name=787></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(9) <IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg118.gif" 
  width=64> <BR></FONT>
  <DL>
    <DT><A name=788></A><FONT face="Verdana, Arial, Helvetica, sans-serif">That 
    is because <FONT face=Arial,Helvetica><EM>m</EM></FONT> has at most 1 bit 
    right of the binary point, so <FONT 
    face=Arial,Helvetica><EM>n</EM></FONT><IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg140.gif" 
    width=10> will round to <FONT face=Arial,Helvetica><EM>m</EM></FONT>. To 
    deal with the halfway case when |<FONT 
    face=Arial,Helvetica><EM>n</EM></FONT><IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg145.gif" 
    width=10> - <FONT face=Arial,Helvetica><EM>m</EM></FONT>| = 1/4, note that 
    since the initial unscaled <FONT face=Arial,Helvetica><EM>m</EM></FONT> had 
    |<FONT face=Arial,Helvetica><EM>m</EM></FONT>| &lt; 
    2<SUP><EM>p</EM></SUP><SUP> - 1</SUP>, its low-order bit was 0, so the 
    low-order bit of the scaled <FONT face=Arial,Helvetica><EM>m</EM></FONT> is 
    also 0. Thus, halfway cases will round to <FONT 
    face=Arial,Helvetica><EM>m</EM></FONT>. </FONT>
    <DT><A name=1199></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Suppose that <FONT 
    face=Arial,Helvetica><EM>q</EM></FONT> = .<FONT 
    face=Arial,Helvetica><EM>q</EM></FONT><SUB>1</SUB><FONT 
    face=Arial,Helvetica><EM>q</EM></FONT><SUB>2</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT>, and let <IMG 
    height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg170.gif" 
    width=10> = .<FONT face=Arial,Helvetica><EM>q</EM></FONT><SUB>1</SUB><FONT 
    face=Arial,Helvetica><EM>q</EM></FONT><SUB>2</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
    face=Arial,Helvetica><EM>q</EM></FONT><SUB>p</SUB>1. To estimate |<FONT 
    face=Arial,Helvetica><EM>n</EM></FONT><IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg175.gif" 
    width=10> - <FONT face=Arial,Helvetica><EM>m</EM></FONT>|, first 
    compute</FONT> </DT></DL><A name=11670></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>|<IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg180.gif" 
  width=10> - <FONT face=Arial,Helvetica><EM>q</EM></FONT>| = |<FONT 
  face=Arial,Helvetica><EM>N</EM></FONT>/2<SUP><EM>p</EM></SUP><SUP> + 1</SUP> - 
  <FONT face=Arial,Helvetica><EM>m</EM></FONT>/<FONT 
  face=Arial,Helvetica><EM>n</EM></FONT>|, <BR></FONT>
  <DL>
    <DT><A name=11672></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">where <FONT 
    face=Arial,Helvetica><EM>N</EM></FONT> is an odd integer. Since <FONT 
    face=Arial,Helvetica><EM>n</EM></FONT> = 
    2<SUP><EM>i</EM></SUP>&nbsp;+&nbsp;2<SUP><EM>j</EM></SUP> and 
    2<SUP><EM>p</EM></SUP><SUP> - 1</SUP> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>n</EM></FONT> &lt; 2<SUP><EM>p</EM></SUP>, it 
    must be that <FONT face=Arial,Helvetica><EM>n</EM></FONT> = 
    2<SUP><EM>p</EM></SUP><SUP>&nbsp;-&nbsp;1</SUP>&nbsp;+ 
    2<SUP><EM>k</EM></SUP> for some k <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>p - </EM></FONT>2, and thus</FONT> 
    <DL>
      <DT><A name=11703></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"></FONT></DT></DL></DT></DL><A 
  name=11680></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG 
  height=35 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg21.gif" 
  width=298> .<BR></FONT>
  <DL>
    <DL>
      <DT><A name=11681></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"></FONT></DT></DL></DL>
  <DL>
    <DT><A name=11685></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
    numerator is an integer, and since <FONT 
    face=Arial,Helvetica><EM>N</EM></FONT> is odd, it is in fact an odd integer. 
    Thus,</FONT> </DT></DL><A name=11704></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>|<IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg185.gif" 
  width=10> - <FONT face=Arial,Helvetica><EM>q</EM></FONT>| <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
  1/(<FONT face=Arial,Helvetica><EM>n</EM></FONT>2<SUP><EM>p</EM></SUP><SUP> + 1 
  - </SUP><SUP><EM>k</EM></SUP>). <BR></FONT>
  <DL>
    <DT><A name=11706></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Assume <FONT 
    face=Arial,Helvetica><EM>q</EM></FONT> &lt; <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg200.gif" 
    width=10> (the case <FONT face=Arial,Helvetica><EM>q</EM></FONT> &gt; <IMG 
    height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg204.gif" 
    width=10> is similar).<A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#11697"><SUP>10</SUP></A> 
    Then <FONT face=Arial,Helvetica><EM>n</EM></FONT><IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg231.gif" 
    width=10> &lt; <FONT face=Arial,Helvetica><EM>m</EM></FONT>, and 
  </FONT></DT></DL><A name=793></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>|<EM>m-n<IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg247.gif" 
  width=10> </EM>|= <EM>m-n<IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg252.gif" 
  width=10> </EM>=<EM> n</EM>(<EM>q-<IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg258.gif" 
  width=10> </EM>) = <EM>n</EM>(<EM>q</EM>-(<IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg269.gif" 
  width=10> -2<SUP><EM>-p-1</EM></SUP>))<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"> 
  </FONT><IMG height=37 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg273.gif" 
  width=118> <BR></FONT><A name=9915></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" 
  size=2>=(2<SUP><EM>p</EM></SUP><SUP>-1</SUP>+2<SUP><EM>k</EM></SUP>)2<SUP><EM>-p-1</EM></SUP>-2<SUP><EM>-p-1+k</EM></SUP> 
  = <IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg240.gif" 
  width=10> <BR></FONT>
  <DL>
    <DT><A name=9922></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
    establishes <A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#787">(9)</A> and 
    proves the theorem.<A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#9921"><SUP>11</SUP></A> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT></FONT> 
    </DT></DL>
  <P><A name=9923></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  theorem holds true for any base <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>, 
  as long as 2<SUP><EM>i</EM></SUP> + 2<SUP><EM>j</EM></SUP> is replaced by 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>i</EM></SUP> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>j</EM></SUP>. 
  As <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  gets larger, however, denominators of the form <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>i</EM></SUP> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>j</EM></SUP> 
  are farther and farther apart. </FONT></P>
  <P><A name=798></A><FONT face="Verdana, Arial, Helvetica, sans-serif">We are 
  now in a position to answer the question, Does it matter if the basic 
  arithmetic operations introduce a little more rounding error than necessary? 
  The answer is that it does matter, because accurate basic operations enable us 
  to prove that formulas are "correct" in the sense they have a small relative 
  error. The section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#700">Cancellation</A> 
  discussed several algorithms that require guard digits to produce correct 
  results in this sense. If the input to those formulas are numbers representing 
  imprecise measurements, however, the bounds of Theorems 3 and 4 become less 
  interesting. The reason is that the benign cancellation <EM>x</EM> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT> can become catastrophic if <EM>x</EM> 
  and <EM>y</EM> are only approximations to some measured quantity. But accurate 
  operations are useful even in the face of inexact data, because they enable us 
  to establish exact relationships like those discussed in Theorems 6 and 7. 
  These are useful even if every floating-point variable is only an 
  approximation to some actual value. </FONT></P>
  <H2><A name=799></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>The IEEE Standard </FONT></H2>
  <P><A name=800></A><FONT face="Verdana, Arial, Helvetica, sans-serif">There 
  are two different IEEE standards for floating-point computation. IEEE 754 is a 
  binary standard that requires <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, <EM>p</EM> = 24 for single precision and <EM>p</EM> = 53 for double 
  precision [IEEE 1987]. It also specifies the precise layout of bits in a 
  single and double precision. IEEE 854 allows either <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2 or <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10 and unlike 754, does not specify how floating-point numbers are encoded 
  into bits [Cody et al. 1984]. It does not require a particular value for 
  <EM>p</EM>, but instead it specifies constraints on the allowable values of 
  <EM>p</EM> for single and double precision. The term <EM>IEEE Standard</EM> 
  will be used when discussing properties common to both standards. </FONT></P>
  <P><A name=801></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
  section provides a tour of the IEEE standard. Each subsection discusses one 
  aspect of the standard and why it was included. It is not the purpose of this 
  paper to argue that the IEEE standard is the best possible floating-point 
  standard but rather to accept the standard as given and provide an 
  introduction to its use. For full details consult the standards themselves 
  [IEEE 1987; Cody et al. 1984]. </FONT></P>
  <H3><A name=802></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Formats and Operations </FONT></H3>
  <H4><A name=803></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Base </FONT></H4>
  <P><A name=804></A><FONT face="Verdana, Arial, Helvetica, sans-serif">It is 
  clear why IEEE 854 allows <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10. Base ten is how humans exchange and think about numbers. Using <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10 is especially appropriate for calculators, where the result of each 
  operation is displayed by the calculator in decimal. </FONT></P>
  <P><A name=805></A><FONT face="Verdana, Arial, Helvetica, sans-serif">There 
  are several reasons why IEEE 854 requires that if the base is not 10, it must 
  be 2. The section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#689">Relative 
  Error and Ulps</A> mentioned one reason: the results of error analyses are 
  much tighter when <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  is 2 because a rounding error of .5 ulp wobbles by a factor of <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  when computed as a relative error, and error analyses are almost always 
  simpler when based on relative error. A related reason has to do with the 
  effective precision for large bases. Consider <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 16, <EM>p</EM>&nbsp;=&nbsp;1 compared to <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, <EM>p</EM> = 4. Both systems have 4 bits of significand. Consider the 
  computation of 15/8. When <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, 15 is represented as 1.111 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 2<SUP>3</SUP>, and 15/8 
  as 1.111 <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
  2<SUP>0</SUP>. So 15/8 is exact. However, when <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 16, 15 is represented as <FONT face=Arial,Helvetica><EM>F</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 16<SUP>0</SUP>, where 
  <FONT face=Arial,Helvetica><EM>F</EM></FONT> is the hexadecimal digit for 15. 
  But 15/8 is represented as 1 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 16<SUP>0</SUP>, which 
  has only one bit correct. In general, base 16 can lose up to 3 bits, so that a 
  precision of <EM>p</EM> hexadecimal digits can have an effective precision as 
  low as 4<FONT face=Arial,Helvetica><EM>p</EM></FONT> - 3 rather than 4<FONT 
  face=Arial,Helvetica><EM>p</EM></FONT> binary bits. Since large values of 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  have these problems, why did IBM choose <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 16 for its system/370? Only IBM knows for sure, but there are two possible 
  reasons. The first is increased exponent range. Single precision on the 
  system/370 has <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 16, <EM>p</EM> = 6. Hence the significand requires 24 bits. Since this must 
  fit into 32 bits, this leaves 7 bits for the exponent and one for the sign 
  bit. Thus the magnitude of representable numbers ranges from about <IMG 
  height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg42.gif" 
  width=31> to about <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg52.gif" 
  width=26> = <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg57.gif" 
  width=19> . To get a similar exponent range when <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2 would require 9 bits of exponent, leaving only 22 bits for the 
  significand. However, it was just pointed out that when <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 16, the effective precision can be as low as 4<FONT 
  face=Arial,Helvetica><EM>p</EM></FONT> -&nbsp;3&nbsp;=&nbsp;21 bits. Even 
  worse, when <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2 it is possible to gain an extra bit of precision (as explained later in 
  this section), so the <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2 machine has 23 bits of precision to compare with a range of 
  21&nbsp;-&nbsp;24 bits for the <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 16 machine. </FONT></P>
  <P><A name=806></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Another 
  possible explanation for choosing <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 16 has to do with shifting. When adding two floating-point numbers, if their 
  exponents are different, one of the significands will have to be shifted to 
  make the radix points line up, slowing down the operation. In the <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 16, <EM>p</EM> = 1 system, all the numbers between 1 and 15 have the same 
  exponent, and so no shifting is required when adding any of the (<IMG 
  height=24 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg177.gif" 
  width=16> ) = 105 possible pairs of distinct numbers from this set. However, 
  in the <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, <EM>p</EM> = 4 system, these numbers have exponents ranging from 0 to 3, 
  and shifting is required for 70 of the 105 pairs. </FONT></P>
  <P><A name=807></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In most 
  modern hardware, the performance gained by avoiding a shift for a subset of 
  operands is negligible, and so the small wobble of <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2 makes it the preferable base. Another advantage of using <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2 is that there is a way to gain an extra bit of significance.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#808"><SUP>12</SUP></A> 
  Since floating-point numbers are always normalized, the most significant bit 
  of the significand is always 1, and there is no reason to waste a bit of 
  storage representing it. Formats that use this trick are said to have a 
  <EM>hidden</EM> bit. It was already pointed out in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#682">Floating-point 
  Formats</A> that this requires a special convention for 0. The method given 
  there was that an exponent of <EM>e</EM><SUB>min</SUB> - 1 and a significand 
  of all zeros represents not <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg114.gif" 
  width=70> , but rather 0. </FONT></P>
  <P><A name=809></A><FONT face="Verdana, Arial, Helvetica, sans-serif">IEEE 754 
  single precision is encoded in 32 bits using 1 bit for the sign, 8 bits for 
  the exponent, and 23 bits for the significand. However, it uses a hidden bit, 
  so the significand is 24 bits (<EM>p</EM> = 24), even though it is encoded 
  using only 23 bits. </FONT></P>
  <H4><A name=810></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Precision </FONT></H4>
  <P><A name=811></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The IEEE 
  standard defines four different precisions: single, double, single-extended, 
  and double-extended. In IEEE 754, single and double precision correspond 
  roughly to what most floating-point hardware provides. Single precision 
  occupies a single 32 bit word, double precision two consecutive 32 bit words. 
  Extended precision is a format that offers at least a little extra precision 
  and exponent range (<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#812">TABLE&nbsp;D-1</A>).
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1><A name=812></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1><B>TABLE D-1 </B>&nbsp;&nbsp;IEEE 754 Format 
    Parameters</FONT></FONT></B></CAPTION>
    <TBODY>
    <TR bgColor=#cccccc>
      <DIV align=center></DIV>
      <TH rowSpan=2><FONT face="Verdana, Arial, Helvetica, sans-serif" 
        color=#003366><A name=817></A>Parameter</FONT></TH>
      <TH colSpan=4><FONT face="Verdana, Arial, Helvetica, sans-serif" 
        color=#003366><A name=818></A>Format</FONT></TH>
      <DIV></DIV></TR>
    <TR bgColor=#cccccc>
      <DIV align=center></DIV>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=823></A>Single</FONT></TH>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=824></A>Single-Extended</FONT></TH>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=825></A>Double</FONT></TH>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=826></A>Double-Extended</FONT></TH>
      <DIV></DIV></TR>
    <TR>
      <TD><A name=827></A><FONT face=Arial,Helvetica><EM>p </EM></FONT></TD>
      <TD><A name=828></A>24 </TD>
      <TD><A name=829></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
        32 </TD>
      <TD><A name=830></A>53 </TD>
      <TD><A name=831></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
        64 </TD></TR>
    <TR>
      <TD><A name=832></A><FONT face=Arial,Helvetica><EM>e</EM></FONT><SUB>max 
        </SUB></TD>
      <TD><A name=833></A>+127 </TD>
      <TD><A name=834></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
        1023 </TD>
      <TD><A name=835></A>+1023 </TD>
      <TD><A name=836></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif">&gt;</FONT> 16383 </TD></TR>
    <TR>
      <TD><A name=837></A><FONT 
        face=Arial,Helvetica><EM>e</EM></FONT><SUB>min</SUB> </TD>
      <TD><A name=838></A>-126 </TD>
      <TD><A name=839></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
        -1022 </TD>
      <TD><A name=840></A>-1022 </TD>
      <TD><A name=841></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"> 
        </FONT>-16382 </TD></TR>
    <TR>
      <TD><A name=842></A>Exponent width in bits </TD>
      <TD><A name=843></A>8 </TD>
      <TD><A name=844></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
        11 </TD>
      <TD><A name=845></A>11 </TD>
      <TD><A name=846></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
        15 </TD></TR>
    <TR>
      <TD><A name=847></A>Format width in bits </TD>
      <TD><A name=848></A>32 </TD>
      <TD><A name=849></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
        43 </TD>
      <TD><A name=850></A>64 </TD>
      <TD><A name=851></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
        79 </TD></TR></TBODY></TABLE></P><BR></FONT>
  <P></P>
  <P><A name=853></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The IEEE 
  standard only specifies a lower bound on how many extra bits extended 
  precision provides. The minimum allowable double-extended format is sometimes 
  referred to as <EM>80-bit format</EM>, even though the table shows it using 79 
  bits. The reason is that hardware implementations of extended precision 
  normally do not use a hidden bit, and so would use 80 rather than 79 bits.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#854"><SUP>13</SUP></A> 
  </FONT></P>
  <P><A name=855></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  standard puts the most emphasis on extended precision, making no 
  recommendation concerning double precision, but strongly recommending that 
  <EM>Implementations should support the extended format corresponding to the 
  widest basic format supported, </EM><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT></FONT> </P>
  <P><A name=857></A><FONT face="Verdana, Arial, Helvetica, sans-serif">One 
  motivation for extended precision comes from calculators, which will often 
  display 10 digits, but use 13 digits internally. By displaying only 10 of the 
  13 digits, the calculator appears to the user as a "black box" that computes 
  exponentials, cosines, etc. to 10 digits of accuracy. For the calculator to 
  compute functions like exp, log and cos to within 10 digits with reasonable 
  efficiency, it needs a few extra digits to work with. It is not hard to find a 
  simple rational expression that approximates log with an error of 500 units in 
  the last place. Thus computing with 13 digits gives an answer correct to 10 
  digits. By keeping these extra 3 digits hidden, the calculator presents a 
  simple model to the operator. </FONT></P>
  <P><A name=858></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Extended 
  precision in the IEEE standard serves a similar function. It enables libraries 
  to efficiently compute quantities to within about .5 ulp in single (or double) 
  precision, giving the user of those libraries a simple model, namely that each 
  primitive operation, be it a simple multiply or an invocation of log, returns 
  a value accurate to within about .5 ulp. However, when using extended 
  precision, it is important to make sure that its use is transparent to the 
  user. For example, on a calculator, if the internal representation of a 
  displayed value is not rounded to the same precision as the display, then the 
  result of further operations will depend on the hidden digits and appear 
  unpredictable to the user. </FONT></P>
  <P><A name=859></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To 
  illustrate extended precision further, consider the problem of converting 
  between IEEE 754 single precision and decimal. Ideally, single precision 
  numbers will be printed with enough digits so that when the decimal number is 
  read back in, the single precision number can be recovered. It turns out that 
  9 decimal digits are enough to recover a single precision binary number (see 
  the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1251">Binary to 
  Decimal Conversion</A>). When converting a decimal number back to its unique 
  binary representation, a rounding error as small as 1 ulp is fatal, because it 
  will give the wrong answer. Here is a situation where extended precision is 
  vital for an efficient algorithm. When single-extended is available, a very 
  straightforward method exists for converting a decimal number to a single 
  precision binary one. First read in the 9 decimal digits as an integer <FONT 
  face=Arial,Helvetica><EM>N</EM></FONT>, ignoring the decimal point. From <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#812">TABLE&nbsp;D-1</A>, 
  <EM>p</EM>&nbsp;<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT>&nbsp;32, 
  and since 10<SUP>9</SUP>&nbsp;&lt;&nbsp;2<SUP>32</SUP> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  4.3 <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
  10<SUP>9</SUP>, <FONT face=Arial,Helvetica><EM>N</EM></FONT> can be 
  represented exactly in single-extended. Next find the appropriate power 
  10<SUP><EM>P</EM></SUP> necessary to scale <FONT 
  face=Arial,Helvetica><EM>N</EM></FONT>. This will be a combination of the 
  exponent of the decimal number, together with the position of the (up until 
  now) ignored decimal point. Compute 
  10<SUP>|</SUP><SUP><EM>P</EM></SUP><SUP>|</SUP>. If |<FONT 
  face=Arial,Helvetica><EM>P</EM></FONT>|&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT>&nbsp;13, 
  then this is also represented exactly, because 10<SUP>13</SUP> = 
  2<SUP>13</SUP>5<SUP>13</SUP>, and 
  5<SUP>13</SUP>&nbsp;&lt;&nbsp;2<SUP>32</SUP>. Finally multiply (or divide if 
  <EM>p</EM> &lt; 0) <FONT face=Arial,Helvetica><EM>N</EM></FONT> and 
  10<SUP>|</SUP><SUP><EM>P</EM></SUP><SUP>|</SUP>. If this last operation is 
  done exactly, then the closest binary number is recovered. The section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1251">Binary to 
  Decimal Conversion</A> shows how to do the last multiply (or divide) exactly. 
  Thus for |<FONT face=Arial,Helvetica><EM>P</EM></FONT>| <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  13, the use of the single-extended format enables 9-digit decimal numbers to 
  be converted to the closest binary number (i.e. exactly rounded). If |<FONT 
  face=Arial,Helvetica><EM>P</EM></FONT>| &gt; 13, then single-extended is not 
  enough for the above algorithm to always compute the exactly rounded binary 
  equivalent, but Coonen [1984] shows that it is enough to guarantee that the 
  conversion of binary to decimal and back will recover the original binary 
  number. </FONT></P>
  <P><A name=860></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If 
  double precision is supported, then the algorithm above would be run in double 
  precision rather than single-extended, but to convert double precision to a 
  17-digit decimal number and back would require the double-extended format. 
  </FONT></P>
  <H4><A name=861></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Exponent </FONT></H4>
  <P><A name=862></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Since 
  the exponent can be positive or negative, some method must be chosen to 
  represent its sign. Two common methods of representing signed numbers are 
  sign/magnitude and two's complement. Sign/magnitude is the system used for the 
  sign of the significand in the IEEE formats: one bit is used to hold the sign, 
  the rest of the bits represent the magnitude of the number. The two's 
  complement representation is often used in integer arithmetic. In this scheme, 
  a number in the range [-2<SUP>p-1</SUP>, 2<SUP>p-1</SUP> - 1] is represented 
  by the smallest nonnegative number that is congruent to it modulo 
  2<SUP>p</SUP>. </FONT></P>
  <P><A name=863></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The IEEE 
  binary standard does not use either of these methods to represent the 
  exponent, but instead uses a <FONT face=Arial,Helvetica><EM>biased</EM></FONT> 
  representation. In the case of single precision, where the exponent is stored 
  in 8 bits, the bias is 127 (for double precision it is 1023). What this means 
  is that if <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg150.gif" 
  width=9> is the value of the exponent bits interpreted as an unsigned integer, 
  then the exponent of the floating-point number is <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg156.gif" 
  width=9> - 127. This is often called the <EM>unbiased exponent</EM> to 
  distinguish from the biased exponent <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg161.gif" 
  width=9> . </FONT></P>
  <P><A name=864></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Referring to <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#812">TABLE&nbsp;D-1</A>, 
  single precision has <EM>e</EM><SUB>max</SUB> = 127 and 
  <EM>e</EM><SUB>min</SUB>&nbsp;=&nbsp;-126. The reason for having 
  |<EM>e</EM><SUB>min</SUB>| &lt; <EM>e</EM><SUB>max</SUB> is so that the 
  reciprocal of the smallest number <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg166.gif" 
  width=51> will not overflow. Although it is true that the reciprocal of the 
  largest number will underflow, underflow is usually less serious than 
  overflow. The section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#803">Base</A> 
  explained that <EM>e</EM><SUB>min</SUB> - 1 is used for representing 0, and <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#875">Special 
  Quantities</A> will introduce a use for <EM>e</EM><SUB>max</SUB> + 1. In IEEE 
  single precision, this means that the biased exponents range between 
  <EM>e</EM><SUB>min</SUB> - 1 = -127 and <EM>e</EM><SUB>max</SUB> + 1 = 128, 
  whereas the unbiased exponents range between 0 and 255, which are exactly the 
  nonnegative numbers that can be represented using 8 bits. </FONT></P>
  <H4><A name=865></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Operations </FONT></H4>
  <P><A name=866></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The IEEE 
  standard requires that the result of addition, subtraction, multiplication and 
  division be exactly rounded. That is, the result must be computed exactly and 
  then rounded to the nearest floating-point number (using round to even). The 
  section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#693">Guard 
  Digits</A> pointed out that computing the exact difference or sum of two 
  floating-point numbers can be very expensive when their exponents are 
  substantially different. That section introduced guard digits, which provide a 
  practical way of computing differences while guaranteeing that the relative 
  error is small. However, computing with a single guard digit will not always 
  give the same answer as computing the exact result and then rounding. By 
  introducing a second guard digit and a third <EM>sticky</EM> bit, differences 
  can be computed at only a little more cost than with a single guard digit, but 
  the result is the same as if the difference were computed exactly and then 
  rounded [Goldberg 1990]. Thus the standard can be implemented efficiently. 
  </FONT></P>
  <P><A name=867></A><FONT face="Verdana, Arial, Helvetica, sans-serif">One 
  reason for completely specifying the results of arithmetic operations is to 
  improve the portability of software. When a program is moved between two 
  machines and both support IEEE arithmetic, then if any intermediate result 
  differs, it must be because of software bugs, not from differences in 
  arithmetic. Another advantage of precise specification is that it makes it 
  easier to reason about floating-point. Proofs about floating-point are hard 
  enough, without having to deal with multiple cases arising from multiple kinds 
  of arithmetic. Just as integer programs can be proven to be correct, so can 
  floating-point programs, although what is proven in that case is that the 
  rounding error of the result satisfies certain bounds. Theorem 4 is an example 
  of such a proof. These proofs are made much easier when the operations being 
  reasoned about are precisely specified. Once an algorithm is proven to be 
  correct for IEEE arithmetic, it will work correctly on any machine supporting 
  the IEEE standard. </FONT></P>
  <P><A name=868></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Brown 
  [1981] has proposed axioms for floating-point that include most of the 
  existing floating-point hardware. However, proofs in this system cannot verify 
  the algorithms of sections <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#700">Cancellation</A> 
  and <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#704">Exactly 
  Rounded Operations</A>, which require features not present on all hardware. 
  Furthermore, Brown's axioms are more complex than simply defining operations 
  to be performed exactly and then rounded. Thus proving theorems from Brown's 
  axioms is usually more difficult than proving them assuming operations are 
  exactly rounded. </FONT></P>
  <P><A name=12892></A><FONT face="Verdana, Arial, Helvetica, sans-serif">There 
  is not complete agreement on what operations a floating-point standard should 
  cover. In addition to the basic operations +, -, <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> and /, the IEEE standard 
  also specifies that square root, remainder, and conversion between integer and 
  floating-point be correctly rounded. It also requires that conversion between 
  internal formats and decimal be correctly rounded (except for very large 
  numbers). Kulisch and Miranker [1986] have proposed adding inner product to 
  the list of operations that are precisely specified. They note that when inner 
  products are computed in IEEE arithmetic, the final answer can be quite wrong. 
  For example sums are a special case of inner products, and the sum ((2 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-30</SUP> + 
  10<SUP>30</SUP>) - 10<SUP>30</SUP>) - 10<SUP>-30</SUP> is exactly equal to 
  10<SUP>-30</SUP>, but on a machine with IEEE arithmetic the computed result 
  will be -10<SUP>-30</SUP>. It is possible to compute inner products to within 
  1 ulp with less hardware than it takes to implement a fast multiplier 
  [Kirchner and Kulish 1987].<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#12895"><SUP>14</SUP></A> 
  <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#12898"><SUP>15</SUP></A></FONT> 
  </P>
  <P><A name=872></A><FONT face="Verdana, Arial, Helvetica, sans-serif">All the 
  operations mentioned in the standard are required to be exactly rounded except 
  conversion between decimal and binary. The reason is that efficient algorithms 
  for exactly rounding all the operations are known, except conversion. For 
  conversion, the best known efficient algorithms produce results that are 
  slightly worse than exactly rounded ones [Coonen 1984]. </FONT></P>
  <P><A name=873></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The IEEE 
  standard does not require transcendental functions to be exactly rounded 
  because of the <EM>table maker's dilemma</EM>. To illustrate, suppose you are 
  making a table of the exponential function to 4 places. Then 
  exp(1.626)&nbsp;=&nbsp;5.0835. Should this be rounded to 5.083 or 5.084? If 
  exp(1.626) is computed more carefully, it becomes 5.08350. And then 5.083500. 
  And then 5.0835000. Since exp is transcendental, this could go on arbitrarily 
  long before distinguishing whether exp(1.626) is 5.083500<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>0<FONT 
  face=Arial,Helvetica><EM>ddd</EM></FONT> or 5.0834999<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>9<FONT 
  face=Arial,Helvetica><EM>ddd</EM></FONT>. Thus it is not practical to specify 
  that the precision of transcendental functions be the same as if they were 
  computed to infinite precision and then rounded. Another approach would be to 
  specify transcendental functions algorithmically. But there does not appear to 
  be a single algorithm that works well across all hardware architectures. 
  Rational approximation, CORDIC,<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#874"><SUP>16</SUP></A> 
  and large tables are three different techniques that are used for computing 
  transcendentals on contemporary machines. Each is appropriate for a different 
  class of hardware, and at present no single algorithm works acceptably over 
  the wide range of current hardware.</FONT> </P>
  <H3><A name=875></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Special Quantities </FONT></H3>
  <P><A name=876></A><FONT face="Verdana, Arial, Helvetica, sans-serif">On some 
  floating-point hardware every bit pattern represents a valid floating-point 
  number. The IBM System/370 is an example of this. On the other hand, the 
  VAX<FONT size=-1><SUP>TM</SUP></FONT> reserves some bit patterns to represent 
  special numbers called <FONT face=Arial,Helvetica><EM>reserved 
  operands</EM></FONT>. This idea goes back to the CDC 6600, which had bit 
  patterns for the special quantities <CODE>INDEFINITE</CODE> and 
  <CODE>INFINITY</CODE>. </FONT></P>
  <P><A name=877></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The IEEE 
  standard continues in this tradition and has NaNs (<EM>Not a Number</EM>) and 
  infinities. Without any special quantities, there is no good way to handle 
  exceptional situations like taking the square root of a negative number, other 
  than aborting computation. Under IBM System/370 FORTRAN, the default action in 
  response to computing the square root of a negative number like -4 results in 
  the printing of an error message. Since every bit pattern represents a valid 
  number, the return value of square root must be some floating-point number. In 
  the case of System/370 FORTRAN, <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg171.gif" 
  width=51> is returned. In IEEE arithmetic, a NaN is returned in this 
  situation. </FONT></P>
  <P><A name=754></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The IEEE 
  standard specifies the following special values (see <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#878">TABLE&nbsp;D-2</A>): 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">±</FONT> 0, denormalized 
  numbers, <FONT face="Verdana, Arial, Helvetica, sans-serif">±<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  and NaNs (there is more than one NaN, as explained in the next section). These 
  special values are all encoded with exponents of either 
  <EM>e</EM><SUB>max</SUB>&nbsp;+&nbsp;1 or <EM>e</EM><SUB>min</SUB> - 1 (it was 
  already pointed out that 0 has an exponent of <EM>e</EM><SUB>min</SUB> - 1). 
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1><A name=878></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1><B>TABLE D-2 </B>&nbsp;&nbsp;IEEE 754 Special 
    Values</FONT></FONT></B></CAPTION>
    <TBODY>
    <TR bgColor=#cccccc>
      <DIV align=center></DIV>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=881></A>Exponent</FONT></TH>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=882></A>Fraction</FONT></TH>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=883></A>Represents</FONT></TH>
      <DIV></DIV></TR>
    <TR>
      <TD><A name=884></A><EM>e</EM> =<EM> e</EM><SUB>min</SUB> - 1 </TD>
      <TD><A name=885></A><FONT face=Arial,Helvetica><EM>f</EM></FONT> = 0 </TD>
      <TD><A name=886></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif">±</FONT>0 </TD></TR>
    <TR>
      <TD><A name=887></A><EM>e</EM> = <EM>e</EM><SUB>min</SUB> - 1 </TD>
      <TD><A name=888></A><FONT face=Arial,Helvetica><EM>f</EM></FONT> <FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/notequal.gif"> 
        </FONT>0<FONT face=Arial,Helvetica><EM> </EM></FONT></TD>
      <TD><A name=889></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG height=20 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg176.gif" 
        width=57> </FONT></TD></TR>
    <TR>
      <TD><A name=890></A><SUB></SUB><EM>e</EM><SUB>min</SUB> <FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"> 
        </FONT><EM>e</EM> <FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"> 
        </FONT><EM>e</EM><SUB>max </SUB></TD>
      <TD><A name=891></A>-- </TD>
      <TD><A name=892></A>1.<FONT face=Arial,Helvetica><EM>f</EM></FONT> <FONT 
        face="Verdana, Arial, Helvetica, sans-serif">× 2</FONT><SUP><EM>e 
        </EM></SUP></TD></TR>
    <TR>
      <TD><A name=893></A><FONT 
        face=Arial,Helvetica><EM></EM></FONT><EM>e</EM> = 
        <EM>e</EM><SUB>max</SUB> + 1 </TD>
      <TD><A name=894></A><FONT face=Arial,Helvetica><EM>f</EM></FONT> = 0 </TD>
      <TD><A name=895></A>±<FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"> 
        </FONT></TD></TR>
    <TR>
      <TD><A name=896></A><EM>e</EM> = <EM>e</EM><SUB>max</SUB> + 1 </TD>
      <TD><A name=897></A><FONT face=Arial,Helvetica><EM>f</EM></FONT> <FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/notequal.gif"> 
        </FONT>0 </TD>
      <TD><A name=898></A><CODE></CODE>NaN </TD></TR></TBODY></TABLE></P><BR></FONT>
  <P></P>
  <H3><A name=899></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>NaNs </FONT></H3>
  <P><A name=4986></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Traditionally, the computation of 
  0/0 or <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg130.gif" 
  width=25> has been treated as an unrecoverable error which causes a 
  computation to halt. However, there are examples where it makes sense for a 
  computation to continue in such a situation. Consider a subroutine that finds 
  the zeros of a function <FONT face=Arial,Helvetica><EM>f</EM></FONT>, say 
  <CODE>zero(f)</CODE>. Traditionally, zero finders require the user to input an 
  interval [<FONT face=Arial,Helvetica><EM>a</EM></FONT>, <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>] on which the function is defined and 
  over which the zero finder will search. That is, the subroutine is called as 
  <CODE>zero(f</CODE>, <CODE>a</CODE>, <CODE>b)</CODE>. A more useful zero 
  finder would not require the user to input this extra information. This more 
  general zero finder is especially appropriate for calculators, where it is 
  natural to simply key in a function, and awkward to then have to specify the 
  domain. However, it is easy to see why most zero finders require a domain. The 
  zero finder does its work by probing the function <CODE>f</CODE> at various 
  values. If it probed for a value outside the domain of <CODE>f</CODE>, the 
  code for <CODE>f</CODE> might well compute 0/0 or <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg133.gif" 
  width=25> , and the computation would halt, unnecessarily aborting the zero 
  finding process. </FONT></P>
  <P><A name=4991></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
  problem can be avoided by introducing a special value called NaN, and 
  specifying that the computation of expressions like 0/0 and <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg246.gif" 
  width=25> produce NaN, rather than halting. A list of some of the situations 
  that can cause a NaN are given in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5001">TABLE&nbsp;D-3</A>. 
  Then when <CODE>zero(f)</CODE> probes outside the domain of <CODE>f</CODE>, 
  the code for <CODE>f</CODE> will return NaN, and the zero finder can continue. 
  That is, <CODE>zero(f)</CODE> is not "punished" for making an incorrect guess. 
  With this example in mind, it is easy to see what the result of combining a 
  NaN with an ordinary floating-point number should be. Suppose that the final 
  statement of <CODE>f</CODE> is 
  <CODE>return(-b&nbsp;+</CODE>&nbsp;<CODE>sqrt(d))/(2*a)</CODE>. If <FONT 
  face=Arial,Helvetica><EM>d</EM></FONT> &lt; 0, then <CODE>f</CODE> should 
  return a NaN. Since <FONT 
  face=Arial,Helvetica><EM>d</EM></FONT>&nbsp;&lt;&nbsp;0, <CODE>sqrt(d)</CODE> 
  is a NaN, and <CODE>-b&nbsp;+&nbsp;sqrt(d)</CODE> will be a NaN, if the sum of 
  a NaN and any other number is a NaN. Similarly if one operand of a division 
  operation is a NaN, the quotient should be a NaN. In general, whenever a NaN 
  participates in a floating-point operation, the result is another NaN. 
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1><A name=5001></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1><B>TABLE D-3 </B>&nbsp;&nbsp;Operations That Produce a 
    NaN</FONT></FONT></B></CAPTION>
    <TBODY>
    <TR bgColor=#cccccc>
      <DIV align=center></DIV>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=5005></A>Operation</FONT></TH>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=5007></A><CODE>NaN</CODE> Produced By</FONT></TH>
      <DIV></DIV></TR>
    <TR>
      <TD><A name=5009></A><FONT face=Arial,Helvetica><EM>+ </EM></FONT></TD>
      <TD><A name=5011></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
        + (- <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>) 
      </TD></TR>
    <TR>
      <TD><A name=5013></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif">× </FONT></TD>
      <TD><A name=5015></A>0 <FONT 
        face="Verdana, Arial, Helvetica, sans-serif">× <IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"> 
        </FONT></TD></TR>
    <TR>
      <TD><A name=5017></A>/ </TD>
      <TD><A name=5019></A>0/0, <FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>/<FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"> 
        </FONT></TD></TR>
    <TR>
      <TD><A name=5021></A><CODE>REM </CODE></TD>
      <TD><A name=5023></A><FONT face=Arial,Helvetica><EM>x</EM></FONT> 
        <CODE>REM</CODE> 0, <FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"> 
        </FONT><CODE>REM</CODE> <FONT face=Arial,Helvetica><EM>y 
    </EM></FONT></TD></TR>
    <TR>
      <TD><A name=5028></A><IMG height=19 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg22.gif" 
        width=16> </TD>
      <TD><A name=5033></A><IMG height=23 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg27.gif" 
        width=19> (when <FONT face=Arial,Helvetica><EM>x &lt; </EM></FONT>0) 
    </TD></TR></TBODY></TABLE></P><BR></FONT>
  <P></P>
  <P><A name=916></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Another 
  approach to writing a zero solver that doesn't require the user to input a 
  domain is to use signals. The zero-finder could install a signal handler for 
  floating-point exceptions. Then if <CODE>f</CODE> was evaluated outside its 
  domain and raised an exception, control would be returned to the zero solver. 
  The problem with this approach is that every language has a different method 
  of handling signals (if it has a method at all), and so it has no hope of 
  portability. </FONT></P>
  <P><A name=917></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In IEEE 
  754, NaNs are often represented as floating-point numbers with the exponent 
  <EM>e</EM><SUB>max</SUB> + 1 and nonzero significands. Implementations are 
  free to put system-dependent information into the significand. Thus there is 
  not a unique NaN, but rather a whole family of NaNs. When a NaN and an 
  ordinary floating-point number are combined, the result should be the same as 
  the NaN operand. Thus if the result of a long computation is a NaN, the 
  system-dependent information in the significand will be the information that 
  was generated when the first NaN in the computation was generated. Actually, 
  there is a caveat to the last statement. If both operands are NaNs, then the 
  result will be one of those NaNs, but it might not be the NaN that was 
  generated first. </FONT></P>
  <H4><A name=918></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Infinity </FONT></H4>
  <P><A name=919></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Just as 
  NaNs provide a way to continue a computation when expressions like 0/0 or <IMG 
  height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg32.gif" 
  width=25> are encountered, infinities provide a way to continue when an 
  overflow occurs. This is much safer than simply returning the largest 
  representable number. As an example, consider computing <IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg223.gif" 
  width=48> , when <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>&nbsp;=&nbsp;10, 
  <EM>p</EM> = 3, and <EM>e</EM><SUB>max</SUB> = 98. If 
  <EM>x</EM>&nbsp;=&nbsp;3&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;10<SUP>70</SUP> and 
  <EM>y</EM> = 4 <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
  10<SUP>70</SUP>, then <EM>x</EM><SUP>2</SUP> will overflow, and be replaced by 
  9.99 <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
  10<SUP>98</SUP>. Similarly <EM>y</EM><SUP>2</SUP>, and <EM>x</EM><SUP>2</SUP> 
  + <FONT face=Arial,Helvetica><EM>y</EM></FONT><SUP>2</SUP> will each overflow 
  in turn, and be replaced by 9.99 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>98</SUP>. So the 
  final result will be <IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg227.gif" 
  width=148> , which is drastically wrong: the correct answer is 5&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;10<SUP>70</SUP>. In 
  IEEE arithmetic, the result of <EM>x</EM><SUP>2</SUP> is <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  as is <EM>y</EM><SUP>2</SUP>, <EM>x</EM><SUP>2</SUP> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUP>2</SUP> and <IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg232.gif" 
  width=48> . So the final result is <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  which is safer than returning an ordinary floating-point number that is 
  nowhere near the correct answer.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#920"><SUP>17</SUP></A></FONT> 
  </P>
  <P><A name=921></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  division of 0 by 0 results in a NaN. A nonzero number divided by 0, however, 
  returns infinity: 1/0 = <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  -1/0 = -<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  The reason for the distinction is this: if <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  0 and <FONT face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  0 as <EM>x</EM> approaches some limit, then <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)/<FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) could have any value. For example, 
  when <FONT face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) = sin <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> and <FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>, then <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)/<FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  1 as <EM>x</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  0. But when <FONT face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)&nbsp;=&nbsp;1 - cos <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>, <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)/<FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  0. When thinking of 0/0 as the limiting situation of a quotient of two very 
  small numbers, 0/0 could represent anything. Thus in the IEEE standard, 0/0 
  results in a NaN. But when <FONT face=Arial,Helvetica><EM>c</EM></FONT> &gt; 
  0, <FONT face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>c</EM></FONT>, <FONT 
  face=Arial,Helvetica><EM>and g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT>0, 
  then <FONT face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)/<FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">±<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  for any analytic functions f and g. If <FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">&lt;</FONT> 0 for small 
  <EM>x</EM>, then <FONT face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)/<FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  -<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  otherwise the limit is +<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  So the IEEE standard defines <FONT face=Arial,Helvetica><EM>c</EM></FONT>/0 = 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">±<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  as long as <FONT face=Arial,Helvetica><EM>c</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/notequal.gif"></FONT> 
  0. The sign of <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  depends on the signs of <FONT face=Arial,Helvetica><EM>c</EM></FONT> and 0 in 
  the usual way, so that -10/0 = -<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  and -10/-0&nbsp;=&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">+<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  You can distinguish between getting <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  because of overflow and getting <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  because of division by zero by checking the status flags (which will be 
  discussed in detail in section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#989">Flags</A>). 
  The overflow flag will be set in the first case, the division by zero flag in 
  the second. </FONT></P>
  <P><A name=922></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The rule 
  for determining the result of an operation that has infinity as an operand is 
  simple: replace infinity with a finite number <EM>x</EM> and take the limit as 
  <EM>x</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"> 
  <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  Thus 3/<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>&nbsp;=&nbsp;0, 
  because</FONT> </P><A name=6075></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=25 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg237.gif" 
  width=76> . <BR></FONT>
  <P><A name=6077></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Similarly, 4 - <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  = -<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  and <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg242.gif" 
  width=21> &nbsp;=&nbsp;<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  When the limit doesn't exist, the result is a NaN, so <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>/<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  will be a NaN (<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5001">TABLE&nbsp;D-3</A> 
  has additional examples). This agrees with the reasoning used to conclude that 
  0/0 should be a NaN. </FONT></P>
  <P><A name=923></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When a 
  subexpression evaluates to a NaN, the value of the entire expression is also a 
  NaN. In the case of <FONT face="Verdana, Arial, Helvetica, sans-serif">±<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  however, the value of the expression might be an ordinary floating-point 
  number because of rules like 1/<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  = 0. Here is a practical example that makes use of the rules for infinity 
  arithmetic. Consider computing the function <EM>x</EM>/(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP>&nbsp;+&nbsp;1). This is a 
  bad formula, because not only will it overflow when <EM>x</EM> is larger than 
  <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg248.gif" 
  width=55> , but infinity arithmetic will give the wrong answer because it will 
  yield 0, rather than a number near 1/<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>. However, <EM>x</EM>/(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP> + 1) can be rewritten as 
  1/(<FONT face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;+ <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>-1</SUP>). This improved expression 
  will not overflow prematurely and because of infinity arithmetic will have the 
  correct value when <EM>x&nbsp;</EM>=&nbsp;0: 1/(0 + 0<SUP>-1</SUP>) = 1/(0 + 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>) 
  = 1/<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  = 0. Without infinity arithmetic, the expression 1/(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>-1</SUP>) requires a test for 
  <EM>x</EM>&nbsp;=&nbsp;0, which not only adds extra instructions, but may also 
  disrupt a pipeline. This example illustrates a general fact, namely that 
  infinity arithmetic often avoids the need for special case checking; however, 
  formulas need to be carefully inspected to make sure they do not have spurious 
  behavior at infinity (as <EM>x</EM>/(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP>&nbsp;+&nbsp;1) did). 
  </FONT></P>
  <H4><A name=924></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Signed Zero </FONT></H4>
  <P><A name=925></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Zero is 
  represented by the exponent <EM>e</EM><SUB>min</SUB> - 1 and a zero 
  significand. Since the sign bit can take on two different values, there are 
  two zeros, +0 and -0. If a distinction were made when comparing +0 and -0, 
  simple tests like 
  <CODE>if</CODE>&nbsp;<CODE>(x</CODE>&nbsp;<CODE>=</CODE>&nbsp;<CODE>0)</CODE> 
  would have very unpredictable behavior, depending on the sign of 
  <CODE>x</CODE>. Thus the IEEE standard defines comparison so that +0 = -0, 
  rather than -0 &lt; +0. Although it would be possible always to ignore the 
  sign of zero, the IEEE standard does not do so. When a multiplication or 
  division involves a signed zero, the usual sign rules apply in computing the 
  sign of the answer. Thus 3<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">·</FONT>(+0) = +0, and +0/-3 = 
  -0. If zero did not have a sign, then the relation 1/(1/<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> would fail to hold when <EM>x</EM> 
  =<FONT face="Verdana, Arial, Helvetica, sans-serif"> ±<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  The reason is that 1/-<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  and 1/+<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  both result in 0, and 1/0 results in +<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  the sign information having been lost. One way to restore the identity 
  1/(1/<FONT face=Arial,Helvetica><EM>x</EM></FONT>) = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> is to only have one kind of infinity, 
  however that would result in the disastrous consequence of losing the sign of 
  an overflowed quantity. </FONT></P>
  <P><A name=926></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Another 
  example of the use of signed zero concerns underflow and functions that have a 
  discontinuity at 0, such as log. In IEEE arithmetic, it is natural to define 
  log 0&nbsp;= -<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  and log <FONT face=Arial,Helvetica><EM>x</EM></FONT> to be a NaN when 
  <EM>x</EM> &lt; 0. Suppose that <EM>x</EM> represents a small negative number 
  that has underflowed to zero. Thanks to signed zero, <EM>x</EM> will be 
  negative, so log can return a NaN. However, if there were no signed zero, the 
  log function could not distinguish an underflowed negative number from 0, and 
  would therefore have to return -<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  Another example of a function with a discontinuity at zero is the signum 
  function, which returns the sign of a number. </FONT></P>
  <P><A name=927></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Probably 
  the most interesting use of signed zero occurs in complex arithmetic. To take 
  a simple example, consider the equation <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg253.gif" 
  width=90> . This is certainly true when <FONT 
  face=Arial,Helvetica><EM>z</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
  0. If <FONT face=Arial,Helvetica><EM>z</EM></FONT> = -1, the obvious 
  computation gives <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg259.gif" 
  width=114> and <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg264.gif" 
  width=117> . Thus, <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg270.gif" 
  width=83> ! The problem can be traced to the fact that square root is 
  multi-valued, and there is no way to select the values so that it is 
  continuous in the entire complex plane. However, square root is continuous if 
  a <EM>branch cut</EM> consisting of all negative real numbers is excluded from 
  consideration. This leaves the problem of what to do for the negative real 
  numbers, which are of the form -<FONT face=Arial,Helvetica><EM>x</EM></FONT> + 
  <EM>i</EM>0, where <EM>x</EM> &gt; 0. Signed zero provides a perfect way to 
  resolve this problem. Numbers of the form <EM>x</EM> + <FONT 
  face=Arial,Helvetica><EM>i</EM></FONT>(+0) have one sign <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg274.gif" 
  width=33> and numbers of the form <EM>x</EM> + <FONT 
  face=Arial,Helvetica><EM>i</EM></FONT>(-0) on the other side of the branch cut 
  have the other sign <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg280.gif" 
  width=39> . In fact, the natural formulas for computing <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg285.gif" 
  width=16> will give these results. </FONT></P>
  <P><A name=928></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Back to 
  <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg290.gif" 
  width=90> . If <FONT face=Arial,Helvetica><EM>z</EM></FONT> =1 = -1 + <FONT 
  face=Arial,Helvetica><EM>i</EM></FONT>0, then</FONT> </P><A 
  name=11237></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2>1/<FONT face=Arial,Helvetica><EM>z</EM></FONT> = 1/(-1 + <FONT 
  face=Arial,Helvetica><EM>i</EM></FONT>0) = [(-1-<FONT 
  face=Arial,Helvetica><EM>&nbsp;i</EM></FONT>0)]/[(-1 + <FONT 
  face=Arial,Helvetica><EM>i</EM></FONT>0)(-1 - <FONT 
  face=Arial,Helvetica><EM>i</EM></FONT>0)] = (-1 -- <FONT 
  face=Arial,Helvetica><EM>i</EM></FONT>0)/((-1)<SUP>2</SUP> - 0<SUP>2</SUP>) = 
  -1 + <FONT face=Arial,Helvetica><EM>i</EM></FONT>(-0),<BR></FONT>
  <P><A name=11239></A><FONT face="Verdana, Arial, Helvetica, sans-serif">and so 
  <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg294.gif" 
  width=146> , while <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg299.gif" 
  width=109> . Thus IEEE arithmetic preserves this identity for all <FONT 
  face=Arial,Helvetica><EM>z</EM></FONT>. Some more sophisticated examples are 
  given by Kahan [1987]. Although distinguishing between +0 and -0 has 
  advantages, it can occasionally be confusing. For example, signed zero 
  destroys the relation <EM>x</EM>&nbsp;=&nbsp;<FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwdbbo.gif"></FONT>&nbsp;1/<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> = 1/<FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>, which is false when <EM>x</EM> = +0 
  and <EM>y</EM> = -0. However, the IEEE committee decided that the advantages 
  of utilizing the sign of zero outweighed the disadvantages.</FONT> </P>
  <H4><A name=929></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Denormalized Numbers </FONT></H4>
  <P><A name=930></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Consider 
  normalized floating-point numbers with <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10, <EM>p </EM>= 3, and <EM>e</EM><SUB>min</SUB>&nbsp;=&nbsp;-98. The 
  numbers <EM>x</EM> = 6.87 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-97</SUP> and 
  <EM>y</EM> = 6.81<FONT face="Verdana, Arial, Helvetica, sans-serif"> ×</FONT> 
  10<SUP>-97</SUP> appear to be perfectly ordinary floating-point numbers, which 
  are more than a factor of 10 larger than the smallest floating-point number 
  1.00 <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
  10<SUP>-98</SUP>. They have a strange property, however: <EM>x</EM> <IMG 
  height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg174.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT> = 0 even though 
  <EM>x</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/notequal.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT>! The reason is that 
  <EM>x</EM>&nbsp;-&nbsp;<FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>&nbsp;=&nbsp;.06&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;10<SUP>&nbsp;-97</SUP>&nbsp; 
  =&nbsp;6.0&nbsp;<FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
  10<SUP>-99</SUP> is too small to be represented as a normalized number, and so 
  must be flushed to zero. How important is it to preserve the property 
  </FONT></P><A name=932></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2>(10) <FONT face=Arial,Helvetica><EM>x = y </EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwdbbo.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x - y = </EM></FONT>0 ?<BR></FONT>
  <P><A name=933></A><FONT face="Verdana, Arial, Helvetica, sans-serif">It's 
  very easy to imagine writing the code fragment, 
  <CODE>if</CODE>&nbsp;<CODE>(x</CODE>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/notequal.gif"></FONT>&nbsp;<CODE>y)</CODE>&nbsp;<CODE>then</CODE>&nbsp;<CODE>z</CODE>&nbsp;<CODE>=</CODE>&nbsp;<CODE>1/(x-y)</CODE>, 
  and much later having a program fail due to a spurious division by zero. 
  Tracking down bugs like this is frustrating and time consuming. On a more 
  philosophical level, computer science textbooks often point out that even 
  though it is currently impractical to prove large programs correct, designing 
  programs with the idea of proving them often results in better code. For 
  example, introducing invariants is quite useful, even if they aren't going to 
  be used as part of a proof. Floating-point code is just like any other code: 
  it helps to have provable facts on which to depend. For example, when 
  analyzing formula <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1403">(6)</A>, it 
  was very helpful to know that <EM>x</EM>/2&nbsp;&lt;&nbsp;<FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>&nbsp;&lt;&nbsp;2<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwdbrt.gif"></FONT>&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;<IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg184.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>. Similarly, knowing that <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#932">(10)</A> is 
  true makes writing reliable floating-point code easier. If it is only true for 
  most numbers, it cannot be used to prove anything. </FONT></P>
  <P><A name=936></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The IEEE 
  standard uses denormalized<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#935"><SUP>18</SUP></A> 
  numbers, which guarantee <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#932">(10)</A>, as 
  well as other useful relations. They are the most controversial part of the 
  standard and probably accounted for the long delay in getting 754 approved. 
  Most high performance hardware that claims to be IEEE compatible does not 
  support denormalized numbers directly, but rather traps when consuming or 
  producing denormals, and leaves it to software to simulate the IEEE 
  standard.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#937"><SUP>19</SUP></A> 
  The idea behind denormalized numbers goes back to Goldberg [1967] and is very 
  simple. When the exponent is <EM>e</EM><SUB>min</SUB>, the significand does 
  not have to be normalized, so that when <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10, <EM>p</EM> = 3 and <EM>e</EM><SUB>min</SUB> = -98, 1.00 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-98</SUP> is no 
  longer the smallest floating-point number, because 0.98 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-98</SUP> is also 
  a floating-point number. </FONT></P>
  <P><A name=938></A><FONT face="Verdana, Arial, Helvetica, sans-serif">There is 
  a small snag when <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2 and a hidden bit is being used, since a number with an exponent of 
  <EM>e</EM><SUB>min</SUB> will always have a significand greater than or equal 
  to 1.0 because of the implicit leading bit. The solution is similar to that 
  used to represent 0, and is summarized in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#878">TABLE&nbsp;D-2</A>. 
  The exponent <EM>e</EM><SUB>min</SUB> is used to represent denormals. More 
  formally, if the bits in the significand field are <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>1</SUB>,<FONT 
  face=Arial,Helvetica><EM> b</EM></FONT><SUB>2</SUB>, <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>, <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>p&nbsp;-1</SUB>, and the value of 
  the exponent is <EM>e</EM>, then when <EM>e</EM> &gt; <EM>e</EM><SUB>min</SUB> 
  - 1, the number being represented is 1.<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>1</SUB><FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>2</SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>p - 1</SUB> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 2<SUP><EM>e</EM></SUP> 
  whereas when <EM>e</EM> = <EM>e</EM><SUB>min</SUB> - 1, the number being 
  represented is 0.<FONT face=Arial,Helvetica><EM>b</EM></FONT><SUB>1</SUB><FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>2</SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>p - 1</SUB> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 
  2<SUP><EM>e</EM></SUP><SUP> + 1</SUP>. The&nbsp;+1 in the exponent is needed 
  because denormals have an exponent of <EM>e</EM><SUB>min</SUB>, not 
  <EM>e</EM><SUB>min</SUB>&nbsp;-&nbsp;1. </FONT></P>
  <P><A name=939></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Recall 
  the example of <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10, <EM>p</EM> = 3, <EM>e</EM><SUB>min</SUB> = -98, <EM>x</EM> = 6.87 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-97</SUP> and 
  <EM>y</EM>&nbsp;=&nbsp;6.81&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;10<SUP>-97</SUP> 
  presented at the beginning of this section. With denormals, <EM>x</EM> -<FONT 
  face=Arial,Helvetica><EM>&nbsp;y</EM></FONT> does not flush to zero but is 
  instead represented by the denormalized number .6&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;10<SUP>-98</SUP>. 
  This behavior is called gradual <EM>underflow</EM>. It is easy to verify that 
  <A href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#932">(10)</A> 
  always holds when using gradual underflow. </FONT></P><A name=942></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=152 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg23.gif" 
  width=700> <BR></FONT><A name=943></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>FIGURE D-2 Flush To Zero 
  Compared With Gradual Underflow<BR></FONT>
  <P><A name=944></A><FONT face="Verdana, Arial, Helvetica, sans-serif"><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#943">FIGURE&nbsp;D-2</A> 
  illustrates denormalized numbers. The top number line in the figure shows 
  normalized floating-point numbers. Notice the gap between 0 and the smallest 
  normalized number <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg146.gif" 
  width=56> . If the result of a floating-point calculation falls into this 
  gulf, it is flushed to zero. The bottom number line shows what happens when 
  denormals are added to the set of floating-point numbers. The "gulf" is filled 
  in, and when the result of a calculation is less than <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg151.gif" 
  width=56> , it is represented by the nearest denormal. When denormalized 
  numbers are added to the number line, the spacing between adjacent 
  floating-point numbers varies in a regular way: adjacent spacings are either 
  the same length or differ by a factor of <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>. 
  Without denormals, the <BR>spacing abruptly changes from <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg157.gif" 
  width=63> to <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg162.gif" 
  width=27> , which is a factor of <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg167.gif" 
  width=31> , rather than the orderly change by a factor of <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>. 
  Because of this, many algorithms that can have large relative error for 
  normalized numbers close to the underflow threshold are well-behaved in this 
  range when gradual underflow is used. </FONT></P>
  <P><A name=945></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Without 
  gradual underflow, the simple expression <EM>x</EM> <FONT 
  face=Arial,Helvetica><EM>- y</EM></FONT> can have a very large relative error 
  for normalized inputs, as was seen above for <EM>x</EM> = 6.87 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 10<SUP>-97</SUP> and 
  <EM>y</EM>&nbsp;=&nbsp;6.81&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;10<SUP>-97</SUP>. 
  Large relative errors can happen even without cancellation, as the following 
  example shows [Demmel 1984]. Consider dividing two complex numbers, <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> +<FONT face=Arial,Helvetica><EM> 
  ib</EM></FONT> and <FONT face=Arial,Helvetica><EM>c</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>id</EM></FONT>. The obvious formula </FONT></P><A 
  name=946></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG 
  height=33 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg172.gif" 
  width=146> <EM></EM><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">·</FONT><EM> i</EM><BR></FONT>
  <P><A name=702></A><FONT face="Verdana, Arial, Helvetica, sans-serif">suffers 
  from the problem that if either component of the denominator <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> +<FONT face=Arial,Helvetica><EM> 
  id</EM></FONT> is larger than <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg208.gif" 
  width=56> , the formula will overflow, even though the final result may be 
  well within range. A better method of computing the quotients is to use 
  Smith's formula:</FONT> </P>
  <DL>
    <DL>
      <DT><A name=12010></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"></FONT></DT></DL></DL><A 
  name=1158></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(11) 
  <IMG height=89 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg212.gif" 
  width=282> <BR></FONT>
  <DL>
    <DL>
      <DT><A name=12011></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"></FONT></DT></DL></DL>
  <P><A name=692></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Applying 
  Smith's formula to (2 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">·</FONT> 10<SUP>-98</SUP> +<FONT 
  face=Arial,Helvetica><EM> i</EM></FONT>10<SUP>-98</SUP>)/(4 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">·</FONT> 10<SUP>-98</SUP> + <FONT 
  face=Arial,Helvetica><EM>i</EM></FONT>(2 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">·</FONT> 10<SUP>-98</SUP>)) gives 
  the correct answer of 0.5 with gradual underflow. It yields 0.4 with flush to 
  zero, an error of 100 ulps. It is typical for denormalized numbers to 
  guarantee error bounds for arguments all the way down to 1.0 x<IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg236.gif" 
  width=27> . </FONT></P>
  <H3><A name=950></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Exceptions, Flags and Trap Handlers </FONT></H3>
  <P><A name=951></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When an 
  exceptional condition like division by zero or overflow occurs in IEEE 
  arithmetic, the default is to deliver a result and continue. Typical of the 
  default results are NaN for 0/0 and <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg182.gif" 
  width=25> , and <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  for 1/0 and overflow. The preceding sections gave examples where proceeding 
  from an exception with these default values was the reasonable thing to do. 
  When any exception occurs, a status flag is also set. Implementations of the 
  IEEE standard are required to provide users with a way to read and write the 
  status flags. The flags are "sticky" in that once set, they remain set until 
  explicitly cleared. Testing the flags is the only way to distinguish 1/0, 
  which is a genuine infinity from an overflow. </FONT></P>
  <P><A name=952></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Sometimes continuing execution in 
  the face of exception conditions is not appropriate. The section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#918">Infinity</A> 
  gave the example of <EM>x</EM>/(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP> + 1). When <EM>x</EM> &gt; 
  <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg187.gif" 
  width=55> , the denominator is infinite, resulting in a final answer of 0, 
  which is totally wrong. Although for this formula the problem can be solved by 
  rewriting it as 1/(<FONT face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>-1</SUP>), rewriting may not always 
  solve the problem. The IEEE standard strongly recommends that implementations 
  allow trap handlers to be installed. Then when an exception occurs, the trap 
  handler is called instead of setting the flag. The value returned by the trap 
  handler will be used as the result of the operation. It is the responsibility 
  of the trap handler to either clear or set the status flag; otherwise, the 
  value of the flag is allowed to be undefined. </FONT></P>
  <P><A name=5376></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  IEEE standard divides exceptions into 5 classes: overflow, underflow, division 
  by zero, invalid operation and inexact. There is a separate status flag for 
  each class of exception. The meaning of the first three exceptions is 
  self-evident. Invalid operation covers the situations listed in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5001">TABLE&nbsp;D-3</A>, 
  and any comparison that involves a NaN. The default result of an operation 
  that causes an invalid exception is to return a NaN, but the converse is not 
  true. When one of the operands to an operation is a NaN, the result is a NaN 
  but no invalid exception is raised unless the operation also satisfies one of 
  the conditions in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5001">TABLE&nbsp;D-3</A>.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5385"><SUP>20</SUP></A> 

  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1><A name=5585></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1><B>TABLE D-4 </B>&nbsp;&nbsp;Exceptions in IEEE 
    754*</FONT></FONT></B></CAPTION>
    <TBODY>
    <TR bgColor=#cccccc>
      <DIV align=center></DIV>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=5633></A>Exception</FONT></TH>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=5627></A>Result when traps disabled</FONT></TH>
      <TH><FONT face="Verdana, Arial, Helvetica, sans-serif" color=#003366><A 
        name=5646></A>Argument to trap handler</FONT></TH>
      <DIV></DIV></TR>
    <TR>
      <TD><A name=5597></A>overflow </TD>
      <TD><A name=5599></A><FONT 
        face="Verdana, Arial, Helvetica, sans-serif">±<IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
        or <FONT 
        face="Verdana, Arial, Helvetica, sans-serif">±</FONT><EM>x</EM><SUB>max 
        </SUB></TD>
      <TD><A name=5665></A>round(<EM>x</EM>2<SUP>-</SUP><FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/alpha.gif"></FONT>) 
      </TD></TR>
    <TR>
      <TD><A name=5603></A>underflow </TD>
      <TD><A name=5674></A>0, <IMG height=20 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg181.gif" 
        width=33> or denormal </TD>
      <TD><A name=5652></A>round(<EM>x</EM>2<FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/alpha.gif"></FONT>) 
      </TD></TR>
    <TR>
      <TD><A name=5609></A>divide by zero </TD>
      <TD><A name=5692></A>±<FONT 
        face="Verdana, Arial, Helvetica, sans-serif"><IMG 
        src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"> 
        </FONT></TD>
      <TD><A name=5613></A>operands </TD></TR>
    <TR>
      <TD><A name=5615></A>invalid </TD>
      <TD><A name=5617></A>NaN </TD>
      <TD><A name=5619></A>operands </TD></TR>
    <TR>
      <TD><A name=5621></A>inexact </TD>
      <TD><A name=5623></A>round(<EM>x</EM>) </TD>
      <TD><A name=5625></A>round(<EM>x</EM>) 
  </TD></TR></TBODY></TABLE></P><BR></FONT>
  <P></P>
  <P><A name=5253></A><FONT face="Verdana, Arial, Helvetica, sans-serif">*<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> is the exact result of the operation, 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/alpha.gif"></FONT> 
  = 192 for single precision, 1536 for double, and <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>max</SUB> = 1.11 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>11 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg186.gif" 
  width=27> </FONT>.</FONT> </P>
  <P><A name=977></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  inexact exception is raised when the result of a floating-point operation is 
  not exact. In the <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10, <EM>p</EM> = 3 system, 3.5 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  4.2 = 14.7 is exact, but 3.5&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT>&nbsp;4.3&nbsp;=&nbsp;15.0 
  is not exact (since 3.5 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">·</FONT> 4.3 = 15.05), and raises 
  an inexact exception. <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1251">Binary to 
  Decimal Conversion</A> discusses an algorithm that uses the inexact exception. 
  A summary of the behavior of all five exceptions is given in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5585">TABLE&nbsp;D-4</A>. 
  </FONT></P>
  <P><A name=978></A><FONT face="Verdana, Arial, Helvetica, sans-serif">There is 
  an implementation issue connected with the fact that the inexact exception is 
  raised so often. If floating-point hardware does not have flags of its own, 
  but instead interrupts the operating system to signal a floating-point 
  exception, the cost of inexact exceptions could be prohibitive. This cost can 
  be avoided by having the status flags maintained by software. The first time 
  an exception is raised, set the software flag for the appropriate class, and 
  tell the floating-point hardware to mask off that class of exceptions. Then 
  all further exceptions will run without interrupting the operating system. 
  When a user resets that status flag, the hardware mask is re-enabled. 
  </FONT></P>
  <H4><A name=979></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Trap Handlers </FONT></H4>
  <P><A name=980></A><FONT face="Verdana, Arial, Helvetica, sans-serif">One 
  obvious use for trap handlers is for backward compatibility. Old codes that 
  expect to be aborted when exceptions occur can install a trap handler that 
  aborts the process. This is especially useful for codes with a loop like 
  <CODE>do</CODE>&nbsp;<CODE>S</CODE>&nbsp;<CODE>until</CODE>&nbsp;<CODE>(x</CODE> 
  <CODE>&gt;=</CODE> <CODE>100)</CODE>. Since comparing a NaN to a number with 
  &lt;, <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT>, 
  &gt;,<FONT face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT>, 
  or = (but not <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/notequal.gif"></FONT>) 
  always returns false, this code will go into an infinite loop if 
  <CODE>x</CODE> ever becomes a NaN. </FONT></P>
  <P><A name=981></A><FONT face="Verdana, Arial, Helvetica, sans-serif">There is 
  a more interesting use for trap handlers that comes up when computing products 
  such as<EM> <IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg238.gif" 
  width=44> </EM>that could potentially overflow. One solution is to use 
  logarithms, and compute exp<IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg243.gif" 
  width=51> instead. The problem with this approach is that it is less accurate, 
  and that it costs more than the simple expression <IMG height=22 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg249.gif" 
  width=23> , even if there is no overflow. There is another solution using trap 
  handlers called <EM>over/underflow counting</EM> that avoids both of these 
  problems [Sterbenz 1974]. </FONT></P>
  <P><A name=982></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The idea 
  is as follows. There is a global counter initialized to zero. Whenever the 
  partial product <IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg254.gif" 
  width=75> overflows for some<FONT face=Arial,Helvetica><EM> k</EM></FONT>, the 
  trap handler increments the counter by one and returns the overflowed quantity 
  with the exponent wrapped around. In IEEE 754 single precision, 
  <EM>e</EM><SUB>max</SUB> = 127, so if <EM>p</EM><SUB>k</SUB>&nbsp;=&nbsp;1.45 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 2<SUP>130</SUP>, 
  it will overflow and cause the trap handler to be called, which will wrap the 
  exponent back into range, changing <EM>p</EM><SUB>k</SUB> to 1.45 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 2<SUP>-62</SUP> (see 
  below). Similarly, if <EM>p</EM><SUB>k</SUB> underflows, the counter would be 
  decremented, and negative exponent would get wrapped around into a positive 
  one. When all the multiplications are done, if the counter is zero then the 
  final product is <EM>p</EM><SUB>n</SUB>. If the counter is positive, the 
  product overflowed, if the counter is negative, it underflowed. If none of the 
  partial products are out of range, the trap handler is never called and the 
  computation incurs no extra cost. Even if there are over/underflows, the 
  calculation is more accurate than if it had been computed with logarithms, 
  because each <EM>p</EM><SUB>k</SUB> was computed from <EM>p</EM><SUB>k - 
  1</SUB> using a full precision multiply. Barnett [1987] discusses a formula 
  where the full accuracy of over/underflow counting turned up an error in 
  earlier tables of that formula. </FONT></P>
  <P><A name=983></A><FONT face="Verdana, Arial, Helvetica, sans-serif">IEEE 754 
  specifies that when an overflow or underflow trap handler is called, it is 
  passed the wrapped-around result as an argument. The definition of 
  wrapped-around for overflow is that the result is computed as if to infinite 
  precision, then divided by 2<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/alpha.gif"></FONT>, 
  and then rounded to the relevant precision. For underflow, the result is 
  multiplied by 2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/alpha.gif"></FONT>. 
  The exponent <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/alpha.gif"></FONT> 
  is 192 for single precision and 1536 for double precision. This is why 1.45 x 
  2<SUP>130</SUP> was transformed into 1.45 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> 2<SUP>-62</SUP> in the 
  example above. </FONT></P>
  <H4><A name=984></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Rounding Modes </FONT></H4>
  <P><A name=985></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In the 
  IEEE standard, rounding occurs whenever an operation has a result that is not 
  exact, since (with the exception of binary decimal conversion) each operation 
  is computed exactly and then rounded. By default, rounding means round toward 
  nearest. The standard requires that three other rounding modes be provided, 
  namely round toward 0, round toward +<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  and round toward -<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  When used with the convert to integer operation, round toward -<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  causes the convert to become the floor function, while round toward +<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  is ceiling. The rounding mode affects overflow, because when round toward 0 or 
  round toward -<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  is in effect, an overflow of positive magnitude causes the default result to 
  be the largest representable number, not +<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  Similarly, overflows of negative magnitude will produce the largest negative 
  number when round toward +<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  or round toward 0 is in effect. </FONT></P>
  <P><A name=717></A><FONT face="Verdana, Arial, Helvetica, sans-serif">One 
  application of rounding modes occurs in interval arithmetic (another is 
  mentioned in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1251">Binary to 
  Decimal Conversion</A>). When using interval arithmetic, the sum of two 
  numbers <EM>x</EM> and <EM>y</EM> is an interval <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg37.gif" 
  width=28> , where <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg260.gif" 
  width=9> is <EM>x </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT> rounded toward -<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  and <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg265.gif" 
  width=9> is <FONT face=Arial,Helvetica><EM>x</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT> rounded toward +<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  The exact result of the addition is contained within the interval <IMG 
  height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg271.gif" 
  width=28> . Without rounding modes, interval arithmetic is usually implemented 
  by computing <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg275.gif" 
  width=101> and <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg281.gif" 
  width=102> , where <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg286.gif" 
  width=9> is machine epsilon.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#753"><SUP>21</SUP></A> 
  This results in overestimates for the size of the intervals. Since the result 
  of an operation in interval arithmetic is an interval, in general the input to 
  an operation will also be an interval. If two intervals <IMG height=17 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg300.gif" 
  width=30> , and <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg305.gif" 
  width=30> , are added, the result is <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg3.gif" 
  width=28> , where <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg7.gif" 
  width=9> is <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg13.gif" 
  width=31> with the rounding mode set to round toward -<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  and <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg18.gif" 
  width=9> is <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg24.gif" 
  width=30> with the rounding mode set to round toward +<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  </FONT></P>
  <P><A name=988></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When a 
  floating-point calculation is performed using interval arithmetic, the final 
  answer is an interval that contains the exact result of the calculation. This 
  is not very helpful if the interval turns out to be large (as it often does), 
  since the correct answer could be anywhere in that interval. Interval 
  arithmetic makes more sense when used in conjunction with a multiple precision 
  floating-point package. The calculation is first performed with some precision 
  <EM>p</EM>. If interval arithmetic suggests that the final answer may be 
  inaccurate, the computation is redone with higher and higher precisions until 
  the final interval is a reasonable size.</FONT> </P>
  <H4><A name=989></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Flags </FONT></H4>
  <P><A name=990></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The IEEE 
  standard has a number of flags and modes. As discussed above, there is one 
  status flag for each of the five exceptions: underflow, overflow, division by 
  zero, invalid operation and inexact. There are four rounding modes: round 
  toward nearest, round toward +<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  round toward 0, and round toward -<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  It is strongly recommended that there be an enable mode bit for each of the 
  five exceptions. This section gives some simple examples of how these modes 
  and flags can be put to good use. A more sophisticated example is discussed in 
  the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1251">Binary to 
  Decimal Conversion</A>. </FONT></P>
  <P><A name=6167></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Consider writing a subroutine to 
  compute <EM>x</EM><SUP>n</SUP>, where <FONT 
  face=Arial,Helvetica><EM>n</EM></FONT> is an integer. When <FONT 
  face=Arial,Helvetica><EM>n</EM></FONT>&nbsp;&gt;&nbsp;0, a simple routine like 

  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1></FONT></B></CAPTION>
    <TBODY>
    <TR>
      <TD><A name=13583></A><PRE>PositivePower(x,n) { 
</PRE><A name=13584></A><PRE> while (n is even) { 
</PRE><A name=13585></A><PRE>     x = x*x
</PRE><A name=13586></A><PRE>     n = n/2
</PRE><A name=13587></A><PRE> } 
</PRE><A name=13588></A><PRE> u = x
</PRE><A name=13589></A><PRE> while (true) { 
</PRE><A name=13590></A><PRE>     n = n/2
</PRE><A name=13591></A><PRE>     if (n==0) return u
</PRE><A name=13592></A><PRE>     x = x*x
</PRE><A name=13593></A><PRE>     if (n is odd) u = u*x
</PRE><A name=6181></A><PRE> } 
</PRE></TD></TR></TBODY></TABLE></P><BR></FONT>
  <P></P>
  <P><A name=6183></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If n 
  &lt; 0, then a more accurate way to compute <EM>x</EM><SUP>n</SUP> is not to 
  call <CODE>PositivePower(1/x,</CODE> <CODE>-n)</CODE> but rather 
  <CODE>1/PositivePower(x,</CODE> <CODE>-n)</CODE>, because the first expression 
  multiplies <FONT face=Arial,Helvetica><EM>n</EM></FONT> quantities each of 
  which have a rounding error from the division (i.e., 1/<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>). In the second expression these are 
  exact (i.e., <EM>x</EM>), and the final division commits just one additional 
  rounding error. Unfortunately, these is a slight snag in this strategy. If 
  <CODE>PositivePower(x,</CODE> <CODE>-n)</CODE> underflows, then either the 
  underflow trap handler will be called, or else the underflow status flag will 
  be set. This is incorrect, because if 
  <EM>x</EM><SUP>-</SUP><SUP><EM>n</EM></SUP> underflows, then 
  <EM>x</EM><SUP>n</SUP> will either overflow or be in range.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#6189"><SUP>22</SUP></A> 
  But since the IEEE standard gives the user access to all the flags, the 
  subroutine can easily correct for this. It simply turns off the overflow and 
  underflow trap enable bits and saves the overflow and underflow status bits. 
  It then computes <CODE>1/PositivePower(x,</CODE> <CODE>-n)</CODE>. If neither 
  the overflow nor underflow status bit is set, it restores them together with 
  the trap enable bits. If one of the status bits is set, it restores the flags 
  and redoes the calculation using <CODE>PositivePower(1/x,</CODE> 
  <CODE>-n)</CODE>, which causes the correct exceptions to occur. </FONT></P>
  <P><A name=1014></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Another 
  example of the use of flags occurs when computing arccos via the 
  formula</FONT> </P><A name=6197></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>arccos <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> = 2 arctan <IMG height=35 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg58.gif" 
  width=38> . <BR></FONT>
  <P><A name=6199></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If 
  arctan(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>) 
  evaluates to <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/pi.gif"></FONT>/2, 
  then arccos(-1) will correctly evaluate to 2<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">·</FONT>arctan(<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>)&nbsp;=<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/pi.gif"></FONT>, 
  because of infinity arithmetic. However, there is a small snag, because the 
  computation of (1 - <FONT face=Arial,Helvetica><EM>x</EM></FONT>)/(1 + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) will cause the divide by zero 
  exception flag to be set, even though arccos(-1) is not exceptional. The 
  solution to this problem is straightforward. Simply save the value of the 
  divide by zero flag before computing arccos, and then restore its old value 
  after the computation. </FONT></P>
  <H2><A name=1015></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Systems Aspects</FONT> </H2>
  <P><A name=1016></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  design of almost every aspect of a computer system requires knowledge about 
  floating-point. Computer architectures usually have floating-point 
  instructions, compilers must generate those floating-point instructions, and 
  the operating system must decide what to do when exception conditions are 
  raised for those floating-point instructions. Computer system designers rarely 
  get guidance from numerical analysis texts, which are typically aimed at users 
  and writers of software, not at computer designers. As an example of how 
  plausible design decisions can lead to unexpected behavior, consider the 
  following BASIC program. 
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1></FONT></B></CAPTION>
    <TBODY>
    <TR>
      <TD><A name=1017></A><PRE>q = 3.0/7.0
</PRE><A name=1018></A><PRE>if q = 3.0/7.0 then print "Equal":
</PRE><A name=1019></A><PRE>    else print "Not Equal"
</PRE></TD></TR></TBODY></TABLE></P><BR></FONT>
  <P></P>
  <P><A name=1020></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
  compiled and run using Borland's Turbo Basic on an IBM PC, the program prints 
  <CODE>Not</CODE> <CODE>Equal</CODE>! This example will be analyzed in the next 
  section</FONT> </P>
  <P><A name=1021></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Incidentally, some people think 
  that the solution to such anomalies is never to compare floating-point numbers 
  for equality, but instead to consider them equal if they are within some error 
  bound <FONT face=Arial,Helvetica><EM>E</EM></FONT>. This is hardly a cure-all 
  because it raises as many questions as it answers. What should the value of 
  <FONT face=Arial,Helvetica><EM>E</EM></FONT> be? If <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> &lt; 0 and y&nbsp;&gt;&nbsp;0 are 
  within <FONT face=Arial,Helvetica><EM>E</EM></FONT>, should they really be 
  considered to be equal, even though they have different signs? Furthermore, 
  the relation defined by this rule, <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT>&nbsp;~&nbsp;<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwdbbo.gif"></FONT> 
  |a - <FONT face=Arial,Helvetica><EM>b</EM></FONT>| &lt; <FONT 
  face=Arial,Helvetica><EM>E</EM></FONT>, is not an equivalence relation because 
  <FONT face=Arial,Helvetica><EM>a</EM></FONT> ~ <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> and <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> ~ <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> does not imply that <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> ~ <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT>.</FONT> </P>
  <H3><A name=1022></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Instruction Sets </FONT></H3>
  <P><A name=12029></A><FONT face="Verdana, Arial, Helvetica, sans-serif">It is 
  quite common for an algorithm to require a short burst of higher precision in 
  order to produce accurate results. One example occurs in the quadratic formula 
  (<IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg241.gif" 
  width=85> )/2<FONT face=Arial,Helvetica><EM>a</EM></FONT>. As discussed in the 
  section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1224">Proof of 
  Theorem 4</A>, when <FONT face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  4<FONT face=Arial,Helvetica><EM>ac</EM></FONT>, rounding error can contaminate 
  up to half the digits in the roots computed with the quadratic formula. By 
  performing the subcalculation of <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> - 4<FONT 
  face=Arial,Helvetica><EM>ac</EM></FONT> in double precision, half the double 
  precision bits of the root are lost, which means that all the single precision 
  bits are preserved. </FONT></P>
  <P><A name=12036></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  computation of <FONT face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> - 
  4<FONT face=Arial,Helvetica><EM>ac</EM></FONT> in double precision when each 
  of the quantities <FONT face=Arial,Helvetica><EM>a</EM></FONT>, <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>, and <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> are in single precision is easy if 
  there is a multiplication instruction that takes two single precision numbers 
  and produces a double precision result. In order to produce the exactly 
  rounded product of two <EM>p</EM>-digit numbers, a multiplier needs to 
  generate the entire 2<FONT face=Arial,Helvetica><EM>p</EM></FONT> bits of 
  product, although it may throw bits away as it proceeds. Thus, hardware to 
  compute a double precision product from single precision operands will 
  normally be only a little more expensive than a single precision multiplier, 
  and much cheaper than a double precision multiplier. Despite this, modern 
  instruction sets tend to provide only instructions that produce a result of 
  the same precision as the operands.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#12039"><SUP>23</SUP></A> 
  </FONT></P>
  <P><A name=1026></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If an 
  instruction that combines two single precision operands to produce a double 
  precision product was only useful for the quadratic formula, it wouldn't be 
  worth adding to an instruction set. However, this instruction has many other 
  uses. Consider the problem of solving a system of linear equations, 
  </FONT></P><A name=1027></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2><FONT face=Arial,Helvetica><EM>a</EM></FONT><SUB>11</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB> + <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>12</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>2</SUB> +<SUB><EM> </EM></SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">· · · + </FONT><FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>1n</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>n</SUB>=<FONT 
  face=Arial,Helvetica><EM> b</EM></FONT><SUB>1</SUB><BR></FONT><A 
  name=11266></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>21</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB> + <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>22</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>2</SUB> +<SUB><EM> </EM></SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">· · · + </FONT><FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>2n</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>n</SUB>=<FONT 
  face=Arial,Helvetica><EM> b</EM></FONT><SUB>2</SUB><BR></FONT><A 
  name=1029></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">· · ·</FONT><BR></FONT><A 
  name=1030></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>n1</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB> + <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>n2</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>2</SUB> +<SUB><EM> </EM></SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">· · ·+ </FONT><FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>nn</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>n</SUB>=<FONT 
  face=Arial,Helvetica><EM> b</EM></FONT><SUB>n</SUB><BR></FONT>
  <P><A name=11280></A><FONT face="Verdana, Arial, Helvetica, sans-serif">which 
  can be written in matrix form as <FONT face=Arial,Helvetica><EM>Ax</EM></FONT> 
  = <FONT face=Arial,Helvetica><EM>b</EM></FONT>, where </FONT></P><A 
  name=11300></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG 
  height=186 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg216.gif" 
  width=591> <BR></FONT>
  <P><A name=11301></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Suppose that a solution 
  <EM>x</EM><SUP>(1)</SUP> is computed by some method, perhaps Gaussian 
  elimination. There is a simple way to improve the accuracy of the result 
  called <EM>iterative improvement</EM>. First compute</FONT> </P><A 
  name=11302></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(12) 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/xi.gif"></FONT> 
  = <FONT face=Arial,Helvetica><EM>Ax</EM></FONT><SUP>(1)</SUP> - <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> <BR></FONT>
  <P><A name=11303></A><FONT face="Verdana, Arial, Helvetica, sans-serif">and 
  then solve the system </FONT></P><A name=11305></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(13) <FONT 
  face=Arial,Helvetica><EM>Ay</EM></FONT> = <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/xi.gif"></FONT><BR></FONT>
  <P><A name=11306></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Note 
  that if <EM>x</EM><SUP>(1)</SUP> is an exact solution, then <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/xi.gif"></FONT> 
  is the zero vector, as is <EM>y</EM>. In general, the computation of <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/xi.gif"></FONT> 
  and <EM>y</EM> will incur rounding error, so <FONT 
  face=Arial,Helvetica><EM>Ay</EM></FONT>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/xi.gif"></FONT>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT>&nbsp;<FONT 
  face=Arial,Helvetica><EM>Ax</EM></FONT><SUP>(1)</SUP>&nbsp;-&nbsp;<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>&nbsp;=&nbsp;<FONT 
  face=Arial,Helvetica><EM>A</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>(1)</SUP> - <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>), where <EM>x</EM> is the (unknown) 
  true solution. Then <EM>y&nbsp;</EM><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT><EM>&nbsp;</EM><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>(1)</SUP> - <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>, so an improved estimate for the 
  solution is </FONT></P><A name=11308></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(14) <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>(2)</SUP> = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>(1)</SUP> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT> <BR></FONT>
  <P><A name=11318></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  three steps <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#11302">(12)</A>, 
  <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#11305">(13)</A>, 
  and <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#11308">(14)</A> 
  can be repeated, replacing <EM>x</EM><SUP>(1)</SUP> with 
  <EM>x</EM><SUP>(2)</SUP>, and <EM>x</EM><SUP>(2)</SUP> with 
  <EM>x</EM><SUP>(3)</SUP>. This argument that 
  <EM>x</EM><SUP>(</SUP><SUP><EM>i</EM></SUP><SUP> + 1)</SUP> is more accurate 
  than x<SUP>(</SUP><SUP><EM>i</EM></SUP><SUP>)</SUP> is only informal. For more 
  information, see [Golub and Van Loan 1989]. </FONT></P>
  <P><A name=1041></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
  performing iterative improvement, <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/xi.gif"></FONT> 
  is a vector whose elements are the difference of nearby inexact floating-point 
  numbers, and so can suffer from catastrophic cancellation. Thus iterative 
  improvement is not very useful unless <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/xi.gif"></FONT>=&nbsp;<FONT 
  face=Arial,Helvetica><EM>Ax</EM></FONT><SUP>(1)</SUP> - <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> is computed in double precision. Once 
  again, this is a case of computing the product of two single precision numbers 
  (<EM>A</EM> and <EM>x</EM><SUP>(1)</SUP>), where the full double precision 
  result is needed. </FONT></P>
  <P><A name=1042></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To 
  summarize, instructions that multiply two floating-point numbers and return a 
  product with twice the precision of the operands make a useful addition to a 
  floating-point instruction set. Some of the implications of this for compilers 
  are discussed in the next section. </FONT></P>
  <H3><A name=1043></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Languages and Compilers </FONT></H3>
  <P><A name=1044></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  interaction of compilers and floating-point is discussed in Farnum [1988], and 
  much of the discussion in this section is taken from that paper.</FONT> </P>
  <H4><A name=1045></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Ambiguity </FONT></H4>
  <P><A name=1046></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Ideally, a language definition 
  should define the semantics of the language precisely enough to prove 
  statements about programs. While this is usually true for the integer part of 
  a language, language definitions often have a large grey area when it comes to 
  floating-point. Perhaps this is due to the fact that many language designers 
  believe that nothing can be proven about floating-point, since it entails 
  rounding error. If so, the previous sections have demonstrated the fallacy in 
  this reasoning. This section discusses some common grey areas in language 
  definitions, including suggestions about how to deal with them.</FONT> </P>
  <P><A name=1047></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Remarkably enough, some languages 
  don't clearly specify that if <CODE>x</CODE> is a floating-point variable 
  (with say a value of <CODE>3.0/10.0</CODE>), then every occurrence of (say) 
  <CODE>10.0*x</CODE> must have the same value. For example Ada, which is based 
  on Brown's model, seems to imply that floating-point arithmetic only has to 
  satisfy Brown's axioms, and thus expressions can have one of many possible 
  values. Thinking about floating-point in this fuzzy way stands in sharp 
  contrast to the IEEE model, where the result of each floating-point operation 
  is precisely defined. In the IEEE model, we can prove that 
  <CODE>(3.0/10.0)*10.0</CODE> evaluates to <CODE>3</CODE> (Theorem 7). In 
  Brown's model, we cannot. </FONT></P>
  <P><A name=1048></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Another 
  ambiguity in most language definitions concerns what happens on overflow, 
  underflow and other exceptions. The IEEE standard precisely specifies the 
  behavior of exceptions, and so languages that use the standard as a model can 
  avoid any ambiguity on this point. </FONT></P>
  <P><A name=1049></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Another 
  grey area concerns the interpretation of parentheses. Due to roundoff errors, 
  the associative laws of algebra do not necessarily hold for floating-point 
  numbers. For example, the expression <CODE>(x+y)+z</CODE> has a totally 
  different answer than <CODE>x+(y+z)</CODE> when <EM>x</EM> = 10<SUP>30</SUP>, 
  <EM>y</EM> = -10<SUP>30</SUP> and <FONT face=Arial,Helvetica><EM>z</EM></FONT> 
  = 1 (it is 1 in the former case, 0 in the latter). The importance of 
  preserving parentheses cannot be overemphasized. The algorithms presented in 
  theorems 3, 4 and 6 all depend on it. For example, in Theorem 6, the formula 
  <EM>x</EM><SUB>h</SUB> = <FONT face=Arial,Helvetica><EM>mx</EM></FONT> - 
  (<FONT face=Arial,Helvetica><EM>mx</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) would reduce to <EM>x</EM><SUB>h</SUB> 
  = <FONT face=Arial,Helvetica><EM>x</EM></FONT> if it weren't for parentheses, 
  thereby destroying the entire algorithm. A language definition that does not 
  require parentheses to be honored is useless for floating-point calculations. 
  </FONT></P>
  <P><A name=1050></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Subexpression evaluation is 
  imprecisely defined in many languages. Suppose that <CODE>ds</CODE> is double 
  precision, but <CODE>x</CODE> and <CODE>y</CODE> are single precision. Then in 
  the expression <CODE>ds</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x*y</CODE> is 
  the product performed in single or double precision? Another example: in 
  <CODE>x</CODE> <CODE>+</CODE> <CODE>m/n</CODE> where <CODE>m</CODE> and 
  <CODE>n</CODE> are integers, is the division an integer operation or a 
  floating-point one? There are two ways to deal with this problem, neither of 
  which is completely satisfactory. The first is to require that all variables 
  in an expression have the same type. This is the simplest solution, but has 
  some drawbacks. First of all, languages like Pascal that have subrange types 
  allow mixing subrange variables with integer variables, so it is somewhat 
  bizarre to prohibit mixing single and double precision variables. Another 
  problem concerns constants. In the expression <CODE>0.1*x</CODE>, most 
  languages interpret 0.1 to be a single precision constant. Now suppose the 
  programmer decides to change the declaration of all the floating-point 
  variables from single to double precision. If 0.1 is still treated as a single 
  precision constant, then there will be a compile time error. The programmer 
  will have to hunt down and change every floating-point constant. </FONT></P>
  <P><A name=1051></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  second approach is to allow mixed expressions, in which case rules for 
  subexpression evaluation must be provided. There are a number of guiding 
  examples. The original definition of C required that every floating-point 
  expression be computed in double precision [Kernighan and Ritchie 1978]. This 
  leads to anomalies like the example at the beginning of this section. The 
  expression <CODE>3.0/7.0</CODE> is computed in double precision, but if 
  <CODE>q</CODE> is a single-precision variable, the quotient is rounded to 
  single precision for storage. Since 3/7 is a repeating binary fraction, its 
  computed value in double precision is different from its stored value in 
  single precision. Thus the comparison <FONT 
  face=Arial,Helvetica><EM>q</EM></FONT> = 3/7 fails. This suggests that 
  computing every expression in the highest precision available is not a good 
  rule. </FONT></P>
  <P><A name=1052></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Another 
  guiding example is inner products. If the inner product has thousands of 
  terms, the rounding error in the sum can become substantial. One way to reduce 
  this rounding error is to accumulate the sums in double precision (this will 
  be discussed in more detail in the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1070">Optimizers</A>). 
  If <CODE>d</CODE> is a double precision variable, and <CODE>x[]</CODE> and 
  <CODE>y[]</CODE> are single precision arrays, then the inner product loop will 
  look like <CODE>d</CODE>&nbsp;<CODE>=</CODE> <CODE>d</CODE> <CODE>+</CODE> 
  <CODE>x[i]*y[i]</CODE>. If the multiplication is done in single precision, 
  than much of the advantage of double precision accumulation is lost, because 
  the product is truncated to single precision just before being added to a 
  double precision variable. </FONT></P>
  <P><A name=1053></A><FONT face="Verdana, Arial, Helvetica, sans-serif">A rule 
  that covers both of the previous two examples is to compute an expression in 
  the highest precision of any variable that occurs in that expression. Then 
  <CODE>q</CODE>&nbsp;<CODE>=</CODE>&nbsp;<CODE>3.0/7.0</CODE> will be computed 
  entirely in single precision<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1054"><SUP>24</SUP></A> 
  and will have the boolean value true, whereas <CODE>d</CODE> <CODE>=</CODE> 
  <CODE>d</CODE> <CODE>+</CODE> <CODE>x[i]*y[i]</CODE> will be computed in 
  double precision, gaining the full advantage of double precision accumulation. 
  However, this rule is too simplistic to cover all cases cleanly. If 
  <CODE>dx</CODE> and <CODE>dy</CODE> are double precision variables, the 
  expression 
  <CODE>y</CODE>&nbsp;<CODE>=</CODE>&nbsp;<CODE>x</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>single(dx-dy)</CODE> 
  contains a double precision variable, but performing the sum in double 
  precision would be pointless, because both operands are single precision, as 
  is the result. </FONT></P>
  <P><A name=1055></A><FONT face="Verdana, Arial, Helvetica, sans-serif">A more 
  sophisticated subexpression evaluation rule is as follows. First assign each 
  operation a tentative precision, which is the maximum of the precisions of its 
  operands. This assignment has to be carried out from the leaves to the root of 
  the expression tree. Then perform a second pass from the root to the leaves. 
  In this pass, assign to each operation&nbsp;the maximum of the tentative 
  precision and the precision expected by the parent. In the case of 
  <CODE>q</CODE>&nbsp;<CODE>=</CODE>&nbsp;<CODE>3.0/7.0</CODE>, every leaf is 
  single precision, so all the operations are done in single precision. In the 
  case of 
  <CODE>d</CODE>&nbsp;<CODE>=</CODE>&nbsp;<CODE>d</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x[i]*y[i]</CODE>, 
  the tentative precision of the multiply operation is single precision, but in 
  the second pass it gets promoted to double precision, because its parent 
  operation expects a double precision operand. And in 
  <CODE>y</CODE>&nbsp;<CODE>=</CODE>&nbsp;<CODE>x</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>single(dx-dy)</CODE>, 
  the addition is done in single precision. Farnum [1988] presents evidence that 
  this algorithm in not difficult to implement. </FONT></P>
  <P><A name=1056></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  disadvantage of this rule is that the evaluation of a subexpression depends on 
  the expression in which it is embedded. This can have some annoying 
  consequences. For example, suppose you are debugging a program and want to 
  know the value of a subexpression. You cannot simply type the subexpression to 
  the debugger and ask it to be evaluated, because the value of the 
  subexpression in the program depends on the expression it is embedded in. A 
  final comment on subexpressions: since converting decimal constants to binary 
  is an operation, the evaluation rule also affects the interpretation of 
  decimal constants. This is especially important for constants like 
  <CODE>0.1</CODE> which are not exactly representable in binary. </FONT></P>
  <P><A name=1057></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Another 
  potential grey area occurs when a language includes exponentiation as one of 
  its built-in operations. Unlike the basic arithmetic operations, the value of 
  exponentiation is not always obvious [Kahan and Coonen 1982]. If 
  <CODE>**</CODE> is the exponentiation operator, then <CODE>(-3)**3</CODE> 
  certainly has the value -27. However, <CODE>(-3.0)**3.0</CODE> is 
  problematical. If the <CODE>**</CODE> operator checks for integer powers, it 
  would compute <CODE>(-3.0)**3.0</CODE> as -3.0<SUP>3</SUP> = -27. On the other 
  hand, if the formula 
  <EM>x</EM><SUP>y</SUP>&nbsp;=&nbsp;<EM>e</EM><SUP>ylog</SUP><SUP><EM>x</EM></SUP> 
  is used to define <CODE>**</CODE> for real arguments, then depending on the 
  log function, the result could be a NaN (using the natural definition of 
  log(<FONT face=Arial,Helvetica><EM>x</EM></FONT>) = <CODE>NaN</CODE> when 
  <EM>x</EM> &lt; 0). If the FORTRAN <CODE>CLOG</CODE> function is used however, 
  then the answer will be -27, because the ANSI FORTRAN standard defines 
  <CODE>CLOG(-3.0)</CODE> to be <FONT 
  face=Arial,Helvetica><EM>i</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/pi.gif"></FONT> 
  + log 3 [ANSI 1978]. The programming language Ada avoids this problem by only 
  defining exponentiation for integer powers, while ANSI FORTRAN prohibits 
  raising a negative number to a real power. </FONT></P>
  <P><A name=1058></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In 
  fact, the FORTRAN standard says that </FONT></P>
  <DL>
    <DL>
      <DT><A name=1059></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif">Any arithmetic operation 
      whose result is not mathematically defined is prohibited... 
  </FONT></DT></DL></DL>
  <P><A name=1060></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Unfortunately, with the 
  introduction of <FONT face="Verdana, Arial, Helvetica, sans-serif">±<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  by the IEEE standard, the meaning of <EM>not mathematically defined</EM> is no 
  longer totally clear cut. One definition might be to use the method shown in 
  section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#918">Infinity</A>. 
  For example, to determine the value of <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUP>b</SUP>, consider non-constant 
  analytic functions <FONT face=Arial,Helvetica><EM>f</EM></FONT> and <FONT 
  face=Arial,Helvetica><EM>g</EM></FONT> with the property that <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>a</EM></FONT> and <FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>b</EM></FONT> as <EM>x</EM> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  0. If <FONT face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)<SUP><EM>g</EM></SUP><SUP>(</SUP><SUP><EM>x</EM></SUP><SUP>)</SUP> 
  always approaches the same limit, then this should be the value of <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUP>b</SUP>. This definition would set 
  2<SUP><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></SUP>&nbsp;=&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  which seems quite reasonable. In the case of 1.0<SUP><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></SUP>, 
  when <FONT face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) = 1 and <FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)&nbsp;=&nbsp;1/<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> the limit approaches 1, but when <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) = 1 - <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> and <FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) = 1/<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> the limit is <EM>e</EM><SUP>-1</SUP>. 
  So 1.0<SUP><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></SUP>, 
  should be a NaN. In the case of 0<SUP>0</SUP>, <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)<SUP><EM>g</EM></SUP><SUP>(</SUP><SUP><EM>x</EM></SUP><SUP>)</SUP> 
  = <EM>e</EM><SUP>g(</SUP><SUP><EM>x</EM></SUP><SUP>)log 
  </SUP><SUP><EM>f</EM></SUP><SUP>(</SUP><SUP><EM>x</EM></SUP><SUP>)</SUP>. 
  Since <FONT face=Arial,Helvetica><EM>f</EM></FONT> and <FONT 
  face=Arial,Helvetica><EM>g</EM></FONT> are analytic and take on the value 0 at 
  0, <FONT face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) = <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>1</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>1</SUP> + <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>2</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP> + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT> and <FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)&nbsp;=&nbsp;<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>1</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>1</SUP>&nbsp;+&nbsp;<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>2</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP> + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>. Thus 
  lim<SUB><EM>x</EM></SUB><SUB> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"> 
  0</SUB><FONT face=Arial,Helvetica><EM>g</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) log <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) = 
  lim<SUB><EM>x</EM></SUB><SUB>&nbsp;<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif">&nbsp;0</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;log(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>1</SUB>&nbsp;+&nbsp;<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>2</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;+&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>)) = 
  lim<SUB><EM>x</EM></SUB><SUB> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"> 
  0</SUB><FONT face=Arial,Helvetica><EM>x</EM></FONT> log(<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT><SUB>1</SUB><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) = 0. So <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)<SUP><EM>g</EM></SUP><SUP>(</SUP><SUP><EM>x</EM></SUP><SUP>)</SUP> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  <EM>e</EM><SUP>0</SUP> = 1 for all <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT> and <FONT 
  face=Arial,Helvetica><EM>g</EM></FONT>, which means that 
  0<SUP>0</SUP>&nbsp;=&nbsp;1.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1061"><SUP>25</SUP></A> 
  <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1062"><SUP>26</SUP></A> 
  Using this definition would unambiguously define the exponential function for 
  all arguments, and in particular would define <CODE>(-3.0)**3.0</CODE> to be 
  -27. </FONT></P>
  <H4><A name=1063></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>The IEEE Standard </FONT></H4>
  <P><A name=1064></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#799">The IEEE 
  Standard</A>," discussed many of the features of the IEEE standard. However, 
  the IEEE standard says nothing about how these features are to be accessed 
  from a programming language. Thus, there is usually a mismatch between 
  floating-point hardware that supports the standard and programming languages 
  like C, Pascal or FORTRAN. Some of the IEEE capabilities can be accessed 
  through a library of subroutine calls. For example the IEEE standard requires 
  that square root be exactly rounded, and the square root function is often 
  implemented directly in hardware. This functionality is easily accessed via a 
  library square root routine. However, other aspects of the standard are not so 
  easily implemented as subroutines. For example, most computer languages 
  specify at most two floating-point types, while the IEEE standard has four 
  different precisions (although the recommended configurations are single plus 
  single-extended or single, double, and double-extended). Infinity provides 
  another example. Constants to represent <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">±<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT> 
  could be supplied by a subroutine. But that might make them unusable in places 
  that require constant expressions, such as the initializer of a constant 
  variable. </FONT></P>
  <P><A name=1065></A><FONT face="Verdana, Arial, Helvetica, sans-serif">A more 
  subtle situation is manipulating the state associated with a computation, 
  where the state consists of the rounding modes, trap enable bits, trap 
  handlers and exception flags. One approach is to provide subroutines for 
  reading and writing the state. In addition, a single call that can atomically 
  set a new value and return the old value is often useful. As the examples in 
  the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#989">Flags</A> 
  show, a very common pattern of modifying IEEE state is to change it only 
  within the scope of a block or subroutine. Thus the burden is on the 
  programmer to find each exit from the block, and make sure the state is 
  restored. Language support for setting the state precisely in the scope of a 
  block would be very useful here. Modula-3 is one language that implements this 
  idea for trap handlers [Nelson 1991]. </FONT></P>
  <P><A name=1066></A><FONT face="Verdana, Arial, Helvetica, sans-serif">There 
  are a number of minor points that need to be considered when implementing the 
  IEEE standard in a language. Since <EM>x</EM> - <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> = +0 for all <EM>x</EM>,<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1067"><SUP>27</SUP></A> 
  (+0)&nbsp;-&nbsp;(+0) = +0. However, -(+0) = -0, thus -<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> should not be defined as 
  0&nbsp;-&nbsp;x. The introduction of NaNs can be confusing, because a NaN is 
  never equal to any other number (including another NaN), so <EM>x</EM> = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> is no longer always true. In fact, the 
  expression <EM>x</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/notequal.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT> is the simplest way to test for a 
  NaN if the IEEE recommended function <CODE>Isnan</CODE> is not provided. 
  Furthermore, NaNs are unordered with respect to all other numbers, so 
  <EM>x</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT> cannot be defined as <EM>not</EM> 
  <EM>x</EM> &gt; <FONT face=Arial,Helvetica><EM>y</EM></FONT>. Since the 
  introduction of NaNs causes floating-point numbers to become partially 
  ordered, a <CODE>compare</CODE> function that returns one of &lt;, =, &gt;, or 
  <FONT face=Arial,Helvetica><EM>unordered</EM></FONT> can make it easier for 
  the programmer to deal with comparisons. </FONT></P>
  <P><A name=1068></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Although the IEEE standard 
  defines the basic floating-point operations to return a NaN if any operand is 
  a NaN, this might not always be the best definition for compound operations. 
  For example when computing the appropriate scale factor to use in plotting a 
  graph, the maximum of a set of values must be computed. In this case it makes 
  sense for the max operation to simply ignore NaNs. </FONT></P>
  <P><A name=1069></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Finally, rounding can be a 
  problem. The IEEE standard defines rounding very precisely, and it depends on 
  the current value of the rounding modes. This sometimes conflicts with the 
  definition of implicit rounding in type conversions or the explicit 
  <CODE>round</CODE> function in languages. This means that programs which wish 
  to use IEEE rounding can't use the natural language primitives, and conversely 
  the language primitives will be inefficient to implement on the ever 
  increasing number of IEEE machines. </FONT></P>
  <H4><A name=1070></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Optimizers </FONT></H4>
  <P><A name=1071></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Compiler texts tend to ignore the 
  subject of floating-point. For example Aho et al. [1986] mentions replacing 
  <CODE>x/2.0</CODE> with <CODE>x*0.5</CODE>, leading the reader to assume that 
  <CODE>x/10.0</CODE> should be replaced by <CODE>0.1*x</CODE>. However, these 
  two expressions do not have the same semantics on a binary machine, because 
  0.1 cannot be represented exactly in binary. This textbook also suggests 
  replacing <CODE>x*y-x*z</CODE> by <CODE>x*(y-z)</CODE>, even though we have 
  seen that these two expressions can have quite different values when 
  <EM>y</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  z. Although it does qualify the statement that any algebraic identity can be 
  used when optimizing code by noting that optimizers should not violate the 
  language definition, it leaves the impression that floating-point semantics 
  are not very important. Whether or not the language standard specifies that 
  parenthesis must be honored, <CODE>(x+y)+z</CODE> can have a totally different 
  answer than <CODE>x+(y+z)</CODE>, as discussed above. There is a problem 
  closely related to preserving parentheses that is illustrated by the following 
  code
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1></FONT></B></CAPTION>
    <TBODY>
    <TR>
      <TD><A name=1072></A><PRE>eps = 1;
</PRE><A name=1073></A><PRE>do eps = 0.5*eps; while (eps + 1 &gt; 1);
</PRE></TD></TR></TBODY></TABLE></P><BR>:</FONT> 
  <P></P>
  <P><A name=1074></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This is 
  designed to give an estimate for machine epsilon. If an optimizing compiler 
  notices that <FONT face=Arial,Helvetica><EM>eps</EM></FONT> + 1 &gt; 1 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwdbbo.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>eps</EM></FONT> &gt; 0, the program will be 
  changed completely. Instead of computing the smallest number <EM>x</EM> such 
  that 1 <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT> is still greater than <EM>x 
  </EM>(<EM>x</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>e</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg71.gif" 
  width=22> ), it will compute the largest number <EM>x</EM> for which 
  <EM>x</EM>/2 is rounded to 0 (<EM>x</EM> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg76.gif" 
  width=27> ). Avoiding this kind of "optimization" is so important that it is 
  worth presenting one more very useful algorithm that is totally ruined by it. 
  </FONT></P>
  <P><A name=1075></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Many 
  problems, such as numerical integration and the numerical solution of 
  differential equations involve computing sums with many terms. Because each 
  addition can potentially introduce an error as large as .5 ulp, a sum 
  involving thousands of terms can have quite a bit of rounding error. A simple 
  way to correct for this is to store the partial summand in a double precision 
  variable and to perform each addition using double precision. If the 
  calculation is being done in single precision, performing the sum in double 
  precision is easy on most computer systems. However, if the calculation is 
  already being done in double precision, doubling the precision is not so 
  simple. One method that is sometimes advocated is to sort the numbers and add 
  them from smallest to largest. However, there is a much more efficient method 
  which dramatically improves the accuracy of sums, namely</FONT> </P>
  <H4><A name=1076></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 8 (Kahan Summation Formula)</FONT> </H4>
  <DL>
    <DT><A name=1091></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>Suppose that <IMG height=21 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg81.gif" 
    width=44> is computed using the following algorithm</EM> 
    <P>
    <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
    borderColorLight=#ffffff border=1>
      <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
      size=-1></FONT></B></CAPTION>
      <TBODY>
      <TR>
        <TD colSpan=7><A name=1077></A><PRE>S = X[1];
</PRE><A name=1078></A><PRE>C = 0;
</PRE><A name=1079></A><PRE>for j = 2 to N { 
</PRE><A name=1080></A><PRE>    Y = X[j] - C;
</PRE><A name=1081></A><PRE>    T = S + Y;
</PRE><A name=1082></A><PRE>    C = (T - S) - Y;
</PRE><A name=1083></A><PRE>    S = T;
</PRE><A name=1084></A><PRE>} 
</PRE></TD></TR></TBODY></TABLE></P><BR></FONT>
    <DT><A name=1092></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>Then the computed sum 
    </EM><FONT face=Arial,Helvetica><EM>S</EM></FONT><EM> is equal to</EM> <IMG 
    height=21 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg87.gif" 
    width=146> <EM>where </EM><IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg90.gif" 
    width=56> . </FONT></DT></DL>
  <P><A name=1093></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Using 
  the naive formula <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg96.gif" 
  width=22> , the computed sum is equal to <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg100.gif" 
  width=63> where |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>j</EM></SUB>|&nbsp;&lt;&nbsp;(<FONT 
  face=Arial,Helvetica><EM>n</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>j</EM></FONT>)<FONT 
  face=Arial,Helvetica><EM>e</EM></FONT>. Comparing this with the error in the 
  Kahan summation formula shows a dramatic improvement. Each summand is 
  perturbed by only 2<FONT face=Arial,Helvetica><EM>e</EM></FONT>, instead of 
  perturbations as large as <FONT face=Arial,Helvetica><EM>ne</EM></FONT> in the 
  simple formula. Details are in, <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1262">Errors In 
  Summation</A>. </FONT></P>
  <P><A name=1094></A><FONT face="Verdana, Arial, Helvetica, sans-serif">An 
  optimizer that believed floating-point arithmetic obeyed the laws of algebra 
  would conclude that <FONT face=Arial,Helvetica><EM>C</EM></FONT> = [<FONT 
  face=Arial,Helvetica><EM>T</EM></FONT>-<FONT 
  face=Arial,Helvetica><EM>S</EM></FONT>] - <FONT 
  face=Arial,Helvetica><EM>Y</EM></FONT> = [(<FONT 
  face=Arial,Helvetica><EM>S</EM></FONT>+<FONT 
  face=Arial,Helvetica><EM>Y</EM></FONT>)-<FONT 
  face=Arial,Helvetica><EM>S</EM></FONT>] - <FONT 
  face=Arial,Helvetica><EM>Y</EM></FONT> = 0, rendering the algorithm completely 
  useless. These examples can be summarized by saying that optimizers should be 
  extremely cautious when applying algebraic identities that hold for the 
  mathematical real numbers to expressions involving floating-point variables. 
  </FONT></P>
  <P><A name=1095></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Another 
  way that optimizers can change the semantics of floating-point code involves 
  constants. In the expression <CODE>1.0E-40*x</CODE>, there is an implicit 
  decimal to binary conversion operation that converts the decimal number to a 
  binary constant. Because this constant cannot be represented exactly in 
  binary, the inexact exception should be raised. In addition, the underflow 
  flag should to be set if the expression is evaluated in single precision. 
  Since the constant is inexact, its exact conversion to binary depends on the 
  current value of the IEEE rounding modes. Thus an optimizer that converts 
  <CODE>1.0E-40</CODE> to binary at compile time would be changing the semantics 
  of the program. However, constants like 27.5 which are exactly representable 
  in the smallest available precision can be safely converted at compile time, 
  since they are always exact, cannot raise any exception, and are unaffected by 
  the rounding modes. Constants that are intended to be converted at compile 
  time should be done with a constant declaration, such as <CODE>const</CODE> 
  <CODE>pi</CODE> <CODE>=</CODE> <CODE>3.14159265</CODE>.</FONT> </P>
  <P><A name=1096></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Common 
  subexpression elimination is another example of an optimization that can 
  change floating-point semantics, as illustrated by the following code 
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1></FONT></B></CAPTION>
    <TBODY>
    <TR>
      <TD colSpan=2><A name=1097></A><PRE>C = A*B;
</PRE><A name=1098></A><PRE>RndMode = Up
</PRE><A name=1099></A><PRE>D = A*B;
</PRE></TD></TR></TBODY></TABLE></P><BR></FONT>
  <P></P>
  <P><A name=1101></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Although <CODE>A*B</CODE> can 
  appear to be a common subexpression, it is not because the rounding mode is 
  different at the two evaluation sites. Three final examples: 
  <EM>x</EM>&nbsp;=&nbsp;<FONT face=Arial,Helvetica><EM>x</EM></FONT> cannot be 
  replaced by the boolean constant <CODE>true</CODE>, because it fails when 
  <EM>x</EM> is a NaN; -<FONT face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;= 0 - 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT> fails for <EM>x</EM> = +0; and 
  <EM>x</EM> &lt; <FONT face=Arial,Helvetica><EM>y</EM></FONT> is not the 
  opposite of <EM>x</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT>, because NaNs are neither greater 
  than nor less than ordinary floating-point numbers. </FONT></P>
  <P><A name=1102></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Despite 
  these examples, there are useful optimizations that can be done on 
  floating-point code. First of all, there are algebraic identities that are 
  valid for floating-point numbers. Some examples in IEEE arithmetic are 
  <EM>x</EM> + <FONT face=Arial,Helvetica><EM>y</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>, 2&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp; <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>, 1&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;=&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>, and 0.5<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>/2. However, even these simple 
  identities can fail on a few machines such as CDC and Cray supercomputers. 
  Instruction scheduling and in-line procedure substitution are two other 
  potentially useful optimizations.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1103"><SUP>28</SUP></A></FONT> 
  </P>
  <P><A name=1104></A><FONT face="Verdana, Arial, Helvetica, sans-serif">As a 
  final example, consider the&nbsp;expression 
  <CODE>dx</CODE>&nbsp;<CODE>=</CODE>&nbsp;<CODE>x*y</CODE>, where 
  <CODE>x</CODE> and <CODE>y</CODE> are single precision variables, and 
  <CODE>dx</CODE> is double precision. On machines that have an instruction that 
  multiplies two single precision numbers to produce a double precision number, 
  <CODE>dx</CODE>&nbsp;<CODE>=</CODE>&nbsp;<CODE>x*y</CODE> can get mapped to 
  that instruction, rather than compiled to a series of instructions that 
  convert the operands to double and then perform a double to double precision 
  multiply. </FONT></P>
  <P><A name=1105></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Some 
  compiler writers view restrictions which prohibit converting (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) + <FONT 
  face=Arial,Helvetica><EM>z</EM></FONT> to <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>y</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>z</EM></FONT>) as irrelevant, of interest only to 
  programmers who use unportable tricks. Perhaps they have in mind that 
  floating-point numbers model real numbers and should obey the same laws that 
  real numbers do. The problem with real number semantics is that they are 
  extremely expensive to implement. Every time two <FONT 
  face=Arial,Helvetica><EM>n</EM></FONT> bit numbers are multiplied, the product 
  will have 2<FONT face=Arial,Helvetica><EM>n</EM></FONT> bits. Every time two 
  <FONT face=Arial,Helvetica><EM>n</EM></FONT> bit numbers with widely spaced 
  exponents are added, the number of bits in the sum is n + the space between 
  the exponents. The sum could have up to <EM>(e</EM><SUP>max</SUP> - 
  <EM>e</EM><SUP>min</SUP>) + n bits, or roughly 2<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">·</FONT><EM>e</EM><SUP>max</SUP> 
  + n bits. An algorithm that involves thousands of operations (such as solving 
  a linear system) will soon be operating on numbers with many significant bits, 
  and be hopelessly slow. The implementation of library functions such as sin 
  and cos is even more difficult, because the value of these transcendental 
  functions aren't rational numbers. Exact integer arithmetic is often provided 
  by lisp systems and is handy for some problems. However, exact floating-point 
  arithmetic is rarely useful. </FONT></P>
  <P><A name=1106></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  fact is that there are useful algorithms (like the Kahan summation formula) 
  that exploit the fact that (<FONT face=Arial,Helvetica><EM>x</EM></FONT> + 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT>) + <FONT 
  face=Arial,Helvetica><EM>z</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/notequal.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>y</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>z</EM></FONT>), and work whenever the bound 
  </FONT></P><A name=1107></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2><FONT face=Arial,Helvetica><EM>a </EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"> 
  </FONT><FONT face=Arial,Helvetica><EM>b</EM></FONT> = (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>)(<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">1 + <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif">)</FONT><BR></FONT>
  <P><A name=1108></A><FONT face="Verdana, Arial, Helvetica, sans-serif">holds 
  (as well as similar bounds for -, <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT> and /). Since these 
  bounds hold for almost all commercial hardware, it would be foolish for 
  numerical programmers to ignore such algorithms, and it would be irresponsible 
  for compiler writers to destroy these algorithms by pretending that 
  floating-point variables have real number semantics. </FONT></P>
  <H3><A name=1109></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Exception Handling </FONT></H3>
  <P><A name=1110></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  topics discussed up to now have primarily concerned systems implications of 
  accuracy and precision. Trap handlers also raise some interesting systems 
  issues. The IEEE standard strongly recommends that users be able to specify a 
  trap handler for each of the five classes of exceptions, and the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#979">Trap 
  Handlers</A>, gave some applications of user defined trap handlers. In the 
  case of invalid operation and division by zero exceptions, the handler should 
  be provided with the operands, otherwise, with the exactly rounded result. 
  Depending on the programming language being used, the trap handler might be 
  able to access other variables in the program as well. For all exceptions, the 
  trap handler must be able to identify what operation was being performed and 
  the precision of its destination. </FONT></P>
  <P><A name=1111></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  IEEE standard assumes that operations are conceptually serial and that when an 
  interrupt occurs, it is possible to identify the operation and its operands. 
  On machines which have pipelining or multiple arithmetic units, when an 
  exception occurs, it may not be enough to simply have the trap handler examine 
  the program counter. Hardware support for identifying exactly which operation 
  trapped may be necessary. </FONT></P>
  <P><A name=1116></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Another 
  problem is illustrated by the following program fragment. 
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1></FONT></B></CAPTION>
    <TBODY>
    <TR>
      <TD><A name=1112></A><PRE>x = y*z;
</PRE><A name=1113></A><PRE>z = x*w;
</PRE><A name=1114></A><PRE>a = b + c;
</PRE><A name=1115></A><PRE>d = a/x;
</PRE></TD></TR></TBODY></TABLE></P><BR></FONT>
  <P></P>
  <P><A name=1117></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Suppose 
  the second multiply raises an exception, and the trap handler wants to use the 
  value of <CODE>a</CODE>. On hardware that can do an add and multiply in 
  parallel, an optimizer would probably move the addition operation ahead of the 
  second multiply, so that the add can proceed in parallel with the first 
  multiply. Thus when the second multiply traps, 
  <CODE>a</CODE>&nbsp;<CODE>=</CODE>&nbsp;<CODE>b</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>c</CODE> 
  has already been executed, potentially changing the result of <CODE>a</CODE>. 
  It would not be reasonable for a compiler to avoid this kind of optimization, 
  because every floating-point operation can potentially trap, and thus 
  virtually all instruction scheduling optimizations would be eliminated. This 
  problem can be avoided by prohibiting trap handlers from accessing any 
  variables of the program directly. Instead, the handler can be given the 
  operands or result as an argument. </FONT></P>
  <P><A name=1120></A><FONT face="Verdana, Arial, Helvetica, sans-serif">But 
  there are still problems. In the fragment 
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1></FONT></B></CAPTION>
    <TBODY>
    <TR>
      <TD><A name=1118></A><PRE>x = y*z;
</PRE><A name=1119></A><PRE>z = a + b;
</PRE></TD></TR></TBODY></TABLE></P><BR></FONT>
  <P></P>
  <P><A name=1121></A><FONT face="Verdana, Arial, Helvetica, sans-serif">the two 
  instructions might well be executed in parallel. If the multiply traps, its 
  argument <CODE>z</CODE> could already have been overwritten by the addition, 
  especially since addition is usually faster than multiply. Computer systems 
  that support the IEEE standard must provide some way to save the value of 
  <CODE>z</CODE>, either in hardware or by having the compiler avoid such a 
  situation in the first place. </FONT></P>
  <P><A name=1122></A><FONT face="Verdana, Arial, Helvetica, sans-serif">W. 
  Kahan has proposed using <EM>presubstitution</EM> instead of trap handlers to 
  avoid these problems. In this method, the user specifies an exception and the 
  value he wants to be used as the result when the exception occurs. As an 
  example, suppose that in code for computing (sin <FONT 
  face=Arial,Helvetica><EM>x)</EM></FONT>/<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>, the user decides that <EM>x</EM> = 0 
  is so rare that it would improve performance to avoid a test for <EM>x</EM> = 
  0, and instead handle this case when a 0/0 trap occurs. Using IEEE trap 
  handlers, the user would write a handler that returns a value of 1 and install 
  it before computing sin <FONT face=Arial,Helvetica><EM>x</EM></FONT>/<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>. Using presubstitution, the user would 
  specify that when an invalid operation occurs, the value 1 should be used. 
  Kahan calls this presubstitution, because the value to be used must be 
  specified before the exception occurs. When using trap handlers, the value to 
  be returned can be computed when the trap occurs. </FONT></P>
  <P><A name=1123></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  advantage of presubstitution is that it has a straightforward hardware 
  implementation.<A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1124"><SUP>29</SUP></A> 
  As soon as the type of exception has been determined, it can be used to index 
  a table which contains the desired result of the operation. Although 
  presubstitution has some attractive attributes, the widespread acceptance of 
  the IEEE standard makes it unlikely to be widely implemented by hardware 
  manufacturers. </FONT></P>
  <H2><A name=1125></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>The Details </FONT></H2>
  <P><A name=1126></A><FONT face="Verdana, Arial, Helvetica, sans-serif">A 
  number of claims have been made in this paper concerning properties of 
  floating-point arithmetic. We now proceed to show that floating-point is not 
  black magic, but rather is a straightforward subject whose claims can be 
  verified mathematically. This section is divided into three parts. The first 
  part presents an introduction to error analysis, and provides the details for 
  the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#680">Rounding 
  Error</A>. The second part explores binary to decimal conversion, filling in 
  some gaps from the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#799">The IEEE 
  Standard</A>. The third part discusses the Kahan summation formula, which was 
  used as an example in the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1015">Systems 
  Aspects</A>. </FONT></P>
  <H3><A name=1127></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Rounding Error </FONT></H3>
  <P><A name=1128></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In the 
  discussion of rounding error, it was stated that a single guard digit is 
  enough to guarantee that addition and subtraction will always be accurate 
  (Theorem 2). We now proceed to verify this fact. Theorem 2 has two parts, one 
  for subtraction and one for addition. The part for subtraction is </FONT></P>
  <H4><A name=1129></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 9</FONT> </H4>
  <P><A name=1130></A><FONT face="Verdana, Arial, Helvetica, sans-serif"><EM>If 
  x and y are positive floating-point numbers in a format with parameters 
  </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><EM> 
  and p, and if subtraction is done with p + 1 digits (i.e. one guard digit), 
  then the relative rounding error in the result is less than</EM></FONT> </P><A 
  name=11105></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2><EM><IMG height=36 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg106.gif" 
  width=119> </EM><FONT face=Arial,Helvetica><EM>e</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><EM> 
  2</EM><FONT face=Arial,Helvetica><EM>e</EM></FONT>.<BR></FONT>
  <H4><A name=1131></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H4>
  <DL>
    <DT><A name=1132></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Interchange <EM>x</EM> and 
    <EM>y</EM> if necessary so that <EM>x</EM> &gt; y. It is also harmless to 
    scale <EM>x</EM> and <EM>y</EM> so that <EM>x</EM> is represented by 
    <EM>x</EM><SUB>0</SUB>.<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>p - 1</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>0</SUP>. 
    If <EM>y</EM> is represented as <EM>y</EM><SUB>0</SUB>.<FONT 
    face=Arial,Helvetica><EM>y</EM></FONT><SUB>1</SUB><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"> ...</FONT> <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT><SUB>p-1</SUB>, then the difference is 
    exact. If <EM>y</EM> is represented as <EM>0</EM>.<FONT 
    face=Arial,Helvetica><EM>y</EM></FONT><SUB>1</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT><SUB>p</SUB>, then the guard digit 
    ensures that the computed difference will be the exact difference rounded to 
    a floating-point number, so the rounding error is at most <FONT 
    face=Arial,Helvetica><EM>e</EM></FONT>. In general, let <EM>y</EM> = 0.0 
    <FONT face="Verdana, Arial, Helvetica, sans-serif">...</FONT> 0<FONT 
    face=Arial,Helvetica><EM>y</EM></FONT><SUB>k + 1</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT><SUB>k + </SUB><SUB><EM>p</EM></SUB> 
    and <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg109.gif" 
    width=10> be <EM>y</EM> truncated to <EM>p</EM>&nbsp;+&nbsp;1 digits. Then 
    </FONT></DT></DL><A name=1133></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(15) y - <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg115.gif" 
  width=10> &lt; (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  - 1)(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP><SUP> 
  - 1</SUP> + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP><SUP> 
  - 2</SUP> + <FONT face="Verdana, Arial, Helvetica, sans-serif">...</FONT><SUP> 
  </SUP>+ <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP><SUP> 
  - </SUP><SUP><EM>k</EM></SUP>).<BR></FONT>
  <DL>
    <DT><A name=1134></A><FONT face="Verdana, Arial, Helvetica, sans-serif">From 
    the definition of guard digit, the computed value of <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> - <FONT face=Arial,Helvetica><EM>y 
    </EM></FONT>is <FONT face=Arial,Helvetica><EM>x</EM></FONT> - <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg120.gif" 
    width=10> rounded to be a floating-point number, that is, (<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> - <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg124.gif" 
    width=10> ) + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT>, 
    where the rounding error <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT> 
    satisfies </FONT></DT></DL><A name=1135></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(16) |<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP>.<BR></FONT>
  <DL>
    <DT><A name=1136></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
    exact difference is <EM>x</EM> - <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT>, so the error is (<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT>) - (<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> - <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg128.gif" 
    width=10> + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT>) 
    = <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg131.gif" 
    width=10> - <FONT face=Arial,Helvetica><EM>y</EM></FONT> + <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT>. 
    There are three cases. If x - y <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
    1 then the relative error is bounded by</FONT> </DT></DL><A 
  name=1137></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(17) 
  <IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg221.gif" 
  width=48> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP> 
  [(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"> 
  - 1)(<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-1</SUP> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif">...</FONT> + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>k</EM></SUP>) 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2] 
  &lt; <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP>(1 
  +<FONT face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> .</FONT><BR></FONT>
  <DL>
    <DT><A name=1138></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Secondly, if <EM>x</EM> - <IMG 
    height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg226.gif" 
    width=10> &lt; 1, then <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT> 
    = 0. Since the smallest that <EM>x</EM> - <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT> can be is</FONT> </DT></DL><A 
  name=1159></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG 
  height=44 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg230.gif" 
  width=140> &gt; (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>-&nbsp;1)(<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-1</SUP>&nbsp;+&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>&nbsp;+ <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>k</EM></SUP>), 
  where <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/rho.gif"></FONT> 
  = <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  - 1, <BR></FONT>
  <DL>
    <DT><A name=1139></A><FONT face="Verdana, Arial, Helvetica, sans-serif">in 
    this case the relative error is bounded by </FONT></DT></DL><A 
  name=1140></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(18) 
  <IMG height=35 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg142.gif" 
  width=315> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">.</FONT><BR></FONT>
  <DL>
    <DT><A name=1141></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
    final case is when <EM>x</EM> - y &lt; 1 but <EM>x</EM> - <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg147.gif" 
    width=10> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
    1. The only way this could happen is if <EM>x</EM>&nbsp;-&nbsp;<IMG 
    height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg152.gif" 
    width=10> = 1, in which case <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT> 
    = 0. But if <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT> 
    = 0, then <A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1140">(18)</A> 
    applies, so that again the relative error is bounded by <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP> 
    &lt; <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP>(1 
    + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2). 
    <FONT face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT></FONT> 
    </DT></DL>
  <P><A name=1142></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, the bound is exactly 2<FONT face=Arial,Helvetica><EM>e</EM></FONT>, and 
  this bound is achieved for <EM>x</EM>= 1 + 
  2<SUP>2&nbsp;-&nbsp;</SUP><SUP><EM>p</EM></SUP> and <EM>y</EM> = 2<SUP>1 - 
  </SUP><SUP><EM>p</EM></SUP> - 2<SUP>1 - 2</SUP><SUP><EM>p</EM></SUP> in the 
  limit as <EM>p</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"></FONT> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>. 
  When adding numbers of the same sign, a guard digit is not necessary to 
  achieve good accuracy, as the following result shows. </FONT></P>
  <H4><A name=1143></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 10</FONT> </H4>
  <P><A name=743></A><FONT face="Verdana, Arial, Helvetica, sans-serif"><EM>If x 
  </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT><EM> 
  </EM>0<EM> and y </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT><EM> 
  </EM>0<EM>, then the relative error in computing x + y is at most </EM>2<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><EM>, 
  even if no guard digits are used.</EM></FONT> </P>
  <H4><A name=1145></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H4>
  <DL>
    <DT><A name=1146></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
    algorithm for addition with <FONT face=Arial,Helvetica><EM>k</EM></FONT> 
    guard digits is similar to that for subtraction. If <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT>&nbsp;<FONT 
    face=Arial,Helvetica><EM>y</EM></FONT>, shift <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT> right until the radix points of <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> and <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT> are aligned. Discard any digits 
    shifted past the <FONT face=Arial,Helvetica><EM>p</EM></FONT> + <FONT 
    face=Arial,Helvetica><EM>k</EM></FONT> position. Compute the sum of these 
    two <FONT face=Arial,Helvetica><EM>p</EM></FONT> + <FONT 
    face=Arial,Helvetica><EM>k</EM></FONT> digit numbers exactly. Then round to 
    <FONT face=Arial,Helvetica><EM>p</EM></FONT> digits. </FONT>
    <DT><A name=1147></A><FONT face="Verdana, Arial, Helvetica, sans-serif">We 
    will verify the theorem when no guard digits are used; the general case is 
    similar. There is no loss of generality in assuming that <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>y</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
    0 and that <FONT face=Arial,Helvetica><EM>x</EM></FONT> is scaled to be of 
    the form <FONT face=Arial,Helvetica><EM>d.dd</EM></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
    face=Arial,Helvetica><EM>d</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">×</FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>0</SUP>. 
    First, assume there is no carry out. Then the digits shifted off the end of 
    <FONT face=Arial,Helvetica><EM>y</EM></FONT> have a value less than <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP><SUP> 
    + 1</SUP>, and the sum is at least 1, so the relative error is less than 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP><SUP>+1</SUP>/1 
    = 2<FONT face=Arial,Helvetica><EM>e</EM></FONT>. If there is a carry out, 
    then the error from shifting must be added to the rounding error of</FONT> 
    </DT></DL><A name=6239></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2><IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg158.gif" 
  width=47> . <BR></FONT>
  <P><A name=6241></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The sum 
  is at least <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>, 
  so the relative error is less than </FONT></P><A name=6244></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=36 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg163.gif" 
  width=212> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"> 
  </FONT>2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  <FONT face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT> <BR></FONT>
  <P><A name=6250></A><FONT face="Verdana, Arial, Helvetica, sans-serif">It is 
  obvious that combining these two theorems gives Theorem 2. Theorem 2 gives the 
  relative error for performing one operation. Comparing the rounding error of 
  <EM>x</EM><SUP>2</SUP>&nbsp;-&nbsp;<FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUP>2</SUP> and (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) requires knowing the relative error of 
  multiple operations. The relative error of <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg85.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT> is <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB> 
  = [(<FONT face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg94.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT>) - (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>)] / (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>), which satisfies |<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>|&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT>&nbsp;2<FONT 
  face=Arial,Helvetica><EM>e</EM></FONT>. Or to write it another way 
  </FONT></P><A name=6266></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2>(19) <FONT face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg104.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT> = (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>), 
  |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  2<FONT face=Arial,Helvetica><EM>e</EM></FONT><BR></FONT>
  <P><A name=6267></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Similarly</FONT> </P><A 
  name=1154></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(20) 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT> = (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>), 
  |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  2<FONT face=Arial,Helvetica><EM>e</EM></FONT><BR></FONT>
  <P><A name=1155></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Assuming that multiplication is 
  performed by computing the exact product and then rounding, the relative error 
  is at most .5 ulp, so </FONT></P><A name=1156></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(21) <FONT 
  face=Arial,Helvetica><EM>u</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>v</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>uv</EM></FONT> (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>), 
  |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>e</EM></FONT><BR></FONT>
  <P><A name=1157></A><FONT face="Verdana, Arial, Helvetica, sans-serif">for any 
  floating-point numbers <FONT face=Arial,Helvetica><EM>u</EM></FONT> and <FONT 
  face=Arial,Helvetica><EM>v</EM></FONT>. Putting these three equations together 
  (letting <FONT face=Arial,Helvetica><EM>u</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg17.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT> and <FONT 
  face=Arial,Helvetica><EM>v</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT>) gives</FONT> </P><A 
  name=1160></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(22) 
  (<FONT face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg105.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"> 
  (</FONT><FONT face=Arial,Helvetica><EM>x</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"> 
  </FONT><FONT face=Arial,Helvetica><EM>y</EM></FONT>) = (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>) 
  (<FONT face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>)<BR></FONT>
  <P><A name=6313></A><FONT face="Verdana, Arial, Helvetica, sans-serif">So the 
  relative error incurred when computing (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) is </FONT></P><A name=6317></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(23) <IMG height=42 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg123.gif" 
  width=305> <BR></FONT>
  <P><A name=1164></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
  relative error is equal to <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>, 
  which is bounded by 5<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"> 
  + 8<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"><SUP>2</SUP>. 
  In other words, the maximum relative error is about 5 rounding errors (since 
  <FONT face=Arial,Helvetica><EM>e</EM></FONT> is a small number, <FONT 
  face=Arial,Helvetica><EM>e</EM></FONT><SUP>2</SUP> is almost negligible). 
  </FONT></P>
  <P><A name=1166></A><FONT face="Verdana, Arial, Helvetica, sans-serif">A 
  similar analysis of (<FONT face=Arial,Helvetica><EM>x</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT>) <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg160.gif" 
  width=13> (<FONT face=Arial,Helvetica><EM>y</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT>) cannot result in a small value 
  for the relative error, because when two nearby values of <EM>x</EM> and 
  <EM>y</EM> are plugged into <EM>x</EM><SUP>2</SUP>&nbsp;-&nbsp;y<SUP>2</SUP>, 
  the relative error will usually be quite large. Another way to see this is to 
  try and duplicate the analysis that worked on (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg119.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT>) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>x</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT>), yielding </FONT></P><A 
  name=1169></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(x 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  x) <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg210.gif" 
  width=13> (y <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  y) = [<FONT face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP>(1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>) 
  - <FONT face=Arial,Helvetica><EM>y</EM></FONT><SUP>2</SUP>(1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>)] 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>)<BR>= 
  ((<FONT face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUP>2</SUP>) (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>) 
  + (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB> 
  - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>)y<SUP>2</SUP>) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>)<BR></FONT>
  <P><A name=1171></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
  <EM>x</EM> and <EM>y</EM> are nearby, the error term (<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB> 
  - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>)y<SUP>2</SUP> 
  can be as large as the result <EM>x</EM><SUP>2</SUP> - y<SUP>2</SUP>. These 
  computations formally justify our claim that (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) is more accurate than 
  <EM>x</EM><SUP>2</SUP> - <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUP>2</SUP>. </FONT></P>
  <P><A name=1172></A><FONT face="Verdana, Arial, Helvetica, sans-serif">We next 
  turn to an analysis of the formula for the area of a triangle. In order to 
  estimate the maximum error that can occur when computing with <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1405">(7)</A>, the 
  following fact will be needed. </FONT></P>
  <H4><A name=1173></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 11</FONT> </H4>
  <DL>
    <DT><A name=1174></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>If subtraction is performed 
    with a guard digit, and y/2 </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><EM> 
    x </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><EM> 
    2y, then x - y is computed exactly.</EM> </FONT></DT></DL>
  <H4><A name=1175></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H4>
  <DL>
    <DT><A name=1177></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Note 
    that if <EM>x</EM> and <EM>y</EM> have the same exponent, then certainly 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg2.gif" 
    width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT> is exact. Otherwise, 
    from the condition of the theorem, the exponents can differ by at most 1. 
    Scale and interchange <EM>x</EM> and <EM>y</EM> if necessary so that 0 <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>y</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT>, and <EM>x</EM> is represented 
    as <FONT face=Arial,Helvetica><EM>x</EM></FONT><SUB>0</SUB>.<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>p - 1</SUB> and <EM>y</EM> as 
    0.<FONT face=Arial,Helvetica><EM>y</EM></FONT><SUB>1</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT><SUB>p</SUB>. Then the algorithm for 
    computing <EM>x</EM> <IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg12.gif" 
    width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT> will compute 
    <EM>x</EM> -<FONT face=Arial,Helvetica><EM> y</EM></FONT> exactly and round 
    to a floating-point number. If the difference is of the form 0.<FONT 
    face=Arial,Helvetica><EM>d</EM></FONT><SUB>1</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
    face=Arial,Helvetica><EM>d</EM></FONT><SUB>p</SUB>, the difference will 
    already be <EM>p</EM> digits long, and no rounding is necessary. Since 
    <EM>x</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    2<FONT face=Arial,Helvetica><EM>y</EM></FONT>, <EM>x</EM> - <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT>&nbsp;<FONT 
    face=Arial,Helvetica><EM>y</EM></FONT>, and since <EM>y</EM> is of the form 
    0.<FONT face=Arial,Helvetica><EM>d</EM></FONT><SUB>1</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
    face=Arial,Helvetica><EM>d</EM></FONT><SUB>p</SUB>, so is <EM>x</EM> - <FONT 
    face=Arial,Helvetica><EM>y</EM></FONT>. <FONT 
    face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT></FONT> </DT></DL>
  <P><A name=1179></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  &gt; 2, the hypothesis of Theorem 11 cannot be replaced by <EM>y</EM>/<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT>x&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"> 
  <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>; the stronger condition <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>/2 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  2<FONT face=Arial,Helvetica><EM>y</EM></FONT> is still necessary. The analysis 
  of the error in (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;-&nbsp;<FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>)&nbsp;(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;+ <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>), immediately following the proof of 
  Theorem 10, used the fact that the relative error in the basic operations of 
  addition and subtraction is small (namely equations <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#6266">(19)</A> and 
  <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1154">(20)</A>). 
  This is the most common kind of error analysis. However, analyzing formula <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1405">(7)</A> 
  requires something more, namely Theorem 11, as the following proof will show. 
  </FONT></P>
  <H4><A name=1180></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 12</FONT> </H4>
  <DL>
    <DT><A name=1181></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>If subtraction uses a guard 
    digit, and if a,b and c are the sides of a triangle (a&nbsp;</EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT><EM>&nbsp;b</EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT><EM>&nbsp;c), 
    then the relative error in computing 
    (a&nbsp;+&nbsp;(b&nbsp;+&nbsp;c))(c&nbsp;-&nbsp;(a&nbsp;-&nbsp;b))(c&nbsp;+&nbsp;(a&nbsp;-&nbsp;b))(a&nbsp;+(b&nbsp;-&nbsp;c)) 
    is at most </EM>16<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><EM>, 
    provided </EM><FONT face=Arial,Helvetica><EM>e</EM></FONT><EM> &lt; .005. 
    </EM></FONT></DT></DL>
  <H4><A name=1182></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H4>
  <DL>
    <DT><A name=12079></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Let's examine the factors one 
    by one. From Theorem 10, <FONT 
    face=Arial,Helvetica><EM>b</EM></FONT>&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT>&nbsp;<FONT 
    face=Arial,Helvetica><EM>c</EM></FONT>&nbsp;=&nbsp;(<FONT 
    face=Arial,Helvetica><EM>b</EM></FONT>&nbsp;+&nbsp;<FONT 
    face=Arial,Helvetica><EM>c</EM></FONT>)&nbsp;(1&nbsp;+&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>), 
    where <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB> 
    is the relative error, and |<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>| 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    Then the value of the first factor is </FONT></DT></DL><A name=12080></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>b</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>c</EM></FONT>)) = (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>c</EM></FONT>)) (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>) 
  = (<FONT face=Arial,Helvetica><EM>a</EM></FONT>&nbsp;+&nbsp;(<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>&nbsp;+&nbsp;c)&nbsp;(1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>))(1 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>), 
  <BR></FONT>
  <DL>
    <DT><A name=12081></A><FONT face="Verdana, Arial, Helvetica, sans-serif">and 
    thus </FONT></DT></DL><A name=1184></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT>) (1 - 2<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<SUP>2</SUP><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  [<FONT face=Arial,Helvetica><EM>a</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT>) (1 - 2<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">] · (1-2<IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif">) 
  <BR><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  a <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>b</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>c</EM></FONT>)<BR><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  [<FONT face=Arial,Helvetica><EM>a</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT>) (1 + 2<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)] 
  (1 + 2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<BR><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>a</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT>) (1 + 2<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<SUP>2</SUP> 
  <BR></FONT>
  <DL>
    <DT><A name=6357></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
    means that there is an <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>1</SUB> 
    so that </FONT></DT></DL><A name=6358></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(24) (a <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (b <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  c)) = (a + b + c) (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>1</SUB>)<SUP>2</SUP>, 
  |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>1</SUB>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  <BR></FONT>
  <DL>
    <DT><A name=6364></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
    next term involves the potentially catastrophic subtraction of <FONT 
    face=Arial,Helvetica><EM>c</EM></FONT> and <FONT 
    face=Arial,Helvetica><EM>a</EM></FONT>&nbsp;<IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg134.gif" 
    width=13> &nbsp;<CODE>b</CODE>, because <FONT 
    face=Arial,Helvetica><EM>a</EM></FONT> <IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg222.gif" 
    width=13> <FONT face=Arial,Helvetica><EM>b</EM></FONT> may have rounding 
    error. Because a, b and c are the sides of a triangle, a <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    b+<FONT face=Arial,Helvetica><EM> c</EM></FONT>, and combining this with the 
    ordering <FONT face=Arial,Helvetica><EM>c</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>b</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>a</EM></FONT> gives <FONT 
    face=Arial,Helvetica><EM>a</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>b</EM></FONT> +<FONT 
    face=Arial,Helvetica><EM> c</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    2<FONT face=Arial,Helvetica><EM>b</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    2<FONT face=Arial,Helvetica><EM>a</EM></FONT>. So <FONT 
    face=Arial,Helvetica><EM>a</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>b</EM></FONT> satisfies the conditions of Theorem 
    11. This means that <FONT face=Arial,Helvetica><EM>a</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>b</EM></FONT> = <FONT 
    face=Arial,Helvetica><EM>a</EM></FONT> <IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg127.gif" 
    width=13> <FONT face=Arial,Helvetica><EM>b</EM></FONT> is exact, hence <FONT 
    face=Arial,Helvetica><EM>c</EM></FONT> <IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg135.gif" 
    width=13> (<FONT face=Arial,Helvetica><EM>a</EM></FONT> - b) is a harmless 
    subtraction which can be estimated from Theorem 9 to be </FONT></DT></DL><A 
  name=1194></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(25) 
  (<FONT face=Arial,Helvetica><EM>c</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg228.gif" 
  width=13> (<FONT face=Arial,Helvetica><EM>a</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg219.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>b</EM></FONT>)) = (<FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> - (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>)) (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>2</SUB>), 
  |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>2</SUB>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  <BR></FONT>
  <DL>
    <DT><A name=1195></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
    third term is the sum of two exact positive quantities, so </FONT></DT></DL><A 
  name=1197></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(26) 
  (<FONT face=Arial,Helvetica><EM>c</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>a</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg29.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>b</EM></FONT>)) = (c + (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>)) (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>3</SUB>), 
  |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>3</SUB>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><BR></FONT>
  <DL>
    <DT><A name=1198></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Finally, the last term is 
    </FONT></DT></DL><A name=1200></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(27) (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>b</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg38.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>c</EM></FONT>)) = (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> - c)) (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>4</SUB>)<SUP>2</SUP>, 
  |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>4</SUB>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>, 
  <BR></FONT>
  <DL>
    <DT><A name=1201></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">using both Theorem 9 and 
    Theorem 10. If multiplication is assumed to be exactly rounded, so that 
    <EM>x</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>y</EM></FONT> = <FONT 
    face=Arial,Helvetica><EM>xy</EM></FONT>(1 + <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/zeta.gif"></FONT>) 
    with |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/zeta.gif"></FONT>| 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>, 
    then combining <A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#6358">(24)</A>, 
    <A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1194">(25)</A>, 
    <A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1197">(26)</A> 
    and <A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1200">(27)</A> 
    gives </FONT></DT></DL><A name=1206></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (b <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  c)) (c <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg48.gif" 
  width=13> (a <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg136.gif" 
  width=13> b)) (c <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (a <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg168.gif" 
  width=13> b)) (<FONT face=Arial,Helvetica><EM>a </EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>b</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg178.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>c</EM></FONT>))<BR><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT>(<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> + c)) (<FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> - (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>)) (<FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>)) (a + (b -<FONT 
  face=Arial,Helvetica><EM> c</EM></FONT>))<FONT face=Arial,Helvetica><EM> E 
  </EM></FONT><BR></FONT>
  <DL>
    <DT><A name=1207></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">where </FONT></DT></DL><A 
  name=1208></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><FONT 
  face=Arial,Helvetica><EM>E</EM></FONT> = (1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>1</SUB>)<SUP>2</SUP> 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>2</SUB>) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>3</SUB>) 
  (1 +<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>4</SUB>)<SUP>2 
  </SUP>(1 +<FONT face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/zeta.gif"></FONT><SUB>1</SUB>)(1 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/zeta.gif"></FONT><SUB>2</SUB>) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/zeta.gif"></FONT><SUB>3</SUB>) 
  <BR></FONT>
  <DL>
    <DT><A name=1209></A><FONT face="Verdana, Arial, Helvetica, sans-serif">An 
    upper bound for <FONT face=Arial,Helvetica><EM>E</EM></FONT> is (1 + 2<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<SUP>6</SUP>(1 
    + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<SUP>3</SUP>, 
    which expands out to 1&nbsp;+&nbsp;15<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>&nbsp;+&nbsp;O(<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP>). 
    Some writers simply ignore the O(<FONT 
    face=Arial,Helvetica><EM>e</EM></FONT><SUP>2</SUP>) term, but it is easy to 
    account for it. Writing (1&nbsp;+&nbsp;2<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<SUP>6</SUP>(1 
    + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<SUP>3</SUP> 
    = 1 + 15<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
    + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><FONT 
    face=Arial,Helvetica><EM>R</EM></FONT>(<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>), 
    <FONT face=Arial,Helvetica><EM>R</EM></FONT>(<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>) 
    is a polynomial in <FONT face=Arial,Helvetica><EM>e</EM></FONT> with 
    positive coefficients, so it is an increasing function of <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    Since <FONT face=Arial,Helvetica><EM>R</EM></FONT>(.005)&nbsp;= .505, <FONT 
    face=Arial,Helvetica><EM>R</EM></FONT>(<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>) 
    &lt; 1 for all <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
    &lt; .005, and hence <FONT face=Arial,Helvetica><EM>E</EM></FONT>&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT>&nbsp;(1&nbsp;+&nbsp;2<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<SUP>6</SUP>(1&nbsp;+&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<SUP>3</SUP>&nbsp;&lt;&nbsp;1&nbsp;+&nbsp;16<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    To get a lower bound on <FONT face=Arial,Helvetica><EM>E</EM></FONT>, note 
    that 1&nbsp;-&nbsp;15<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>&nbsp;-&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>R(<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>) 
    &lt; E, and so when <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
    &lt; .005, 1 - 16<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
    &lt; (1 - 2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<SUP>6</SUP>(1 
    - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>)<SUP>3</SUP>. 
    Combining these two bounds yields 1&nbsp;- 16<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
    &lt; <FONT face=Arial,Helvetica><EM>E</EM></FONT> 
    &lt;&nbsp;1&nbsp;+&nbsp;16<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    Thus the relative error is at most 16<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    z </FONT></DT></DL>
  <P><A name=1144></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Theorem 
  12 certainly shows that there is no catastrophic cancellation in formula <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1405">(7)</A>. So 
  although it is not necessary to show formula <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1405">(7)</A> is 
  numerically stable, it is satisfying to have a bound for the entire formula, 
  which is what Theorem 3 of <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#700">Cancellation</A> 
  gives.</FONT> </P>
  <H4><A name=1211></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof of Theorem 3</FONT> </H4>
  <DL>
    <DT><A name=1212></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Let 
    </FONT></DT></DL><A name=12086></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><FONT 
  face=Arial,Helvetica><EM>q</EM></FONT> = (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT>)) (<FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> - (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>)) (<FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT>)) (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> + (<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT>)) <BR></FONT>
  <DL>
    <DT><A name=10808></A><FONT face="Verdana, Arial, Helvetica, sans-serif">and 
    </FONT></DT></DL><A name=12087></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><FONT 
  face=Arial,Helvetica><EM>Q</EM></FONT> = (<FONT 
  face=Arial,Helvetica><EM>a</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>b</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>c</EM></FONT>)) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  (c <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg214.gif" 
  width=13> (<FONT face=Arial,Helvetica><EM>a</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg188.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>b</EM></FONT>)) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>c</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>a</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg197.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>b</EM></FONT>)) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>a</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  (<FONT face=Arial,Helvetica><EM>b</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg206.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>c</EM></FONT>)). <BR></FONT>
  <DL>
    <DT><A name=10824></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Then, Theorem 12 shows that 
    Q&nbsp;= <FONT face=Arial,Helvetica><EM>q</EM></FONT>(1 + <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT>), 
    with <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    16<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    It is easy to check that</FONT> </DT></DL><A name=1217></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(28) <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg132.gif" 
  width=231> <BR></FONT>
  <DL>
    <DT><A name=1218></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">provided <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    .04/(.52)<SUP>2</SUP> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
    .15, and since |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT>| 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    16<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    16(.005) = .08, <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT> 
    does satisfy the condition. Thus</FONT> </DT></DL><A name=12088></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=23 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg137.gif" 
  width=169> , <BR></FONT>
  <DL>
    <DT><A name=12090></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">with |<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>|<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT>&nbsp;.52|<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT>|<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    8.5<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    If square roots are computed to within .5 ulp, then the error when computing 
    <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg139.gif" 
    width=21> is (1&nbsp;+&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>)(1&nbsp;+ 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>), 
    with |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>|<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    If <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
    = 2, then there is no further error committed when dividing by 4. Otherwise, 
    one more factor 1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB> 
    with |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>|&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT>&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
    is necessary for the division, and using the method in the proof of Theorem 
    12, the final error bound of (1 +<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>) 
    (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>) 
    (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>) 
    is dominated by 1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>4</SUB>, 
    with |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>4</SUB>| 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    11<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    <FONT face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT> 
    </FONT></DT></DL>
  <P><A name=1219></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To make 
  the heuristic explanation immediately following the statement of Theorem 4 
  precise, the next theorem describes just how closely <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>) approximates a constant. </FONT></P>
  <H4><A name=1220></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 13</FONT> </H4>
  <DL>
    <DT><A name=1221></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>If </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>)<EM> </EM>= ln(1 +<EM> </EM><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>)/<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><EM>, then for </EM>0<EM> </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><EM> 
    </EM><FONT face=Arial,Helvetica><EM>x</EM></FONT><EM> </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><EM> 
    <IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg143.gif" 
    width=8> , <IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg148.gif" 
    width=8> </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><EM> 
    </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<EM>x</EM>)<EM> 
    </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><EM> 
    </EM>1<EM> and the derivative satisfies |</EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT><EM>'</EM>(<EM>x</EM>)|<EM>&nbsp;</EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><EM>&nbsp;<IMG 
    height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg153.gif" 
    width=8> . </EM></FONT></DT></DL>
  <H4><A name=1222></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H4>
  <DL>
    <DT><A name=1223></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Note 
    that <FONT face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>) = 1 - <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>/2 + <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP>/3 - <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT> is an alternating 
    series with decreasing terms, so for <EM>x</EM> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    1, <FONT face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
    1 - <FONT face=Arial,Helvetica><EM>x</EM></FONT>/2 <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
    1/2. It is even easier to see that because the series for <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT> is alternating, <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    1. The Taylor series of <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>'(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>) is also alternating, and if 
    <EM>x</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg159.gif" 
    width=8> has decreasing terms, so - <EM><IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg164.gif" 
    width=8> </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>'(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    -<EM><IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg169.gif" 
    width=8> </EM>+ 2<FONT face=Arial,Helvetica><EM>x</EM></FONT>/3, or 
    -<EM><IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg173.gif" 
    width=8> </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    µ'(<FONT face=Arial,Helvetica><EM>x</EM></FONT>) <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    0, thus |<FONT face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>'(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>)| <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <EM><IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg179.gif" 
    width=8> </EM>. <FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=1>z</FONT> </FONT></DT></DL>
  <H4><A name=1224></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof of Theorem 4 </FONT></H4>
  <DL>
    <DT><A name=1225></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Since the Taylor series for ln 
    </FONT></DT></DL><A name=1227></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=33 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg183.gif" 
  width=150> <BR></FONT>
  <DL>
    <DT><A name=1228></A><FONT face="Verdana, Arial, Helvetica, sans-serif">is 
    an alternating series, 0 &lt; <FONT face=Arial,Helvetica><EM>x</EM></FONT> - 
    ln(1 + <FONT face=Arial,Helvetica><EM>x</EM></FONT>) &lt; <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP>/2, the relative error 
    incurred when approximating ln(1 + <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>) by <EM>x</EM> is bounded by 
    <EM>x</EM>/2. If 1 <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> = 1, then |<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>|&nbsp;&lt;&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>, 
    so the relative error is bounded by <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>/2. 
    </FONT>
    <DT><A name=9691></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
    1 <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/notequal.gif"></FONT> 
    1, define <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg5.gif" 
    width=10> via 1 <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> = 1 + <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg194.gif" 
    width=10> . Then since 0 <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> &lt; 1, (1<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT>) <IMG height=10 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg141.gif" 
    width=10> 1 = <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg191.gif" 
    width=10> . If division and logarithms are computed to within <EM><IMG 
    height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg195.gif" 
    width=8> </EM>ulp, then the computed value of the expression ln(1 + <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>)/((1 + <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>) - 1) is </FONT></DT></DL><A 
  name=9709></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(29) 
  <IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg201.gif" 
  width=63> (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>) 
  = <IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg192.gif" 
  width=51> (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>) 
  = <FONT face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg196.gif" 
  width=10> ) (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>)<BR><BR></FONT>
  <P><A name=987></A><FONT face="Verdana, Arial, Helvetica, sans-serif">where 
  |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  and |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  To estimate <FONT face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<IMG 
  height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg189.gif" 
  width=10> ), use the mean value theorem, which says that </FONT></P><A 
  name=1233></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(30) 
  <FONT face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg193.gif" 
  width=10> ) - <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<EM>x</EM>) = (<IMG 
  height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg198.gif" 
  width=10> - <FONT face=Arial,Helvetica><EM>x</EM></FONT>)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">µ'</FONT>(<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/xi.gif"></FONT>)<BR></FONT>
  <DL>
    <DT><A name=1234></A><FONT face="Verdana, Arial, Helvetica, sans-serif">for 
    some <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/xi.gif"></FONT> 
    between <EM>x</EM> and <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg203.gif" 
    width=10> . From the definition of <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg207.gif" 
    width=10> , it follows that |<IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg211.gif" 
    width=10> - <FONT face=Arial,Helvetica><EM>x</EM></FONT>| <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>, 
    and combining this with Theorem 13 gives |<FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg215.gif" 
    width=10> ) - <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>)| <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>/2, 
    or |<FONT face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<IMG 
    height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg220.gif" 
    width=10> )/<FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>)&nbsp;-&nbsp;1| <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>/(2|<FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>)|) <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><EM> 
    </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
    which means that <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg225.gif" 
    width=10> ) = <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">µ</FONT>(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>)<EM> </EM>(1 + <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>), 
    with |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>| 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    Finally, multiplying by <FONT face=Arial,Helvetica><EM>x</EM></FONT> 
    introduces a final <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>4</SUB>, 
    so the computed value of </FONT></DT></DL><A name=12106></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><EM>x</EM><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">·</FONT>ln(1&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT>)/((1 <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT>) <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg224.gif" 
  width=13> 1)<BR></FONT>
  <P><A name=12107></A><FONT face="Verdana, Arial, Helvetica, sans-serif">is 
  </FONT></P><A name=1236></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2><IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg229.gif" 
  width=279> <BR></FONT>
  <DL>
    <DT><A name=1237></A><FONT face="Verdana, Arial, Helvetica, sans-serif">It 
    is easy to check that if <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
    &lt; 0.1, then </FONT></DT></DL><A name=12109></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>4</SUB>) 
  = 1 +&nbsp;<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT>, 
  <BR></FONT>
  <P><A name=12110></A><FONT face="Verdana, Arial, Helvetica, sans-serif">with 
  |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT>|&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  5<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  <FONT face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT></FONT> </P>
  <P><A name=1238></A><FONT face="Verdana, Arial, Helvetica, sans-serif">An 
  interesting example of error analysis using formulas <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#6266">(19)</A>, <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1154">(20)</A>, 
  and <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1156">(21)</A> 
  occurs in the quadratic formula <IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg234.gif" 
  width=117> . The section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#700">Cancellation</A>, 
  explained how rewriting the equation will eliminate the potential cancellation 
  caused by the <FONT face="Verdana, Arial, Helvetica, sans-serif">±</FONT> 
  operation. But there is another potential cancellation that can occur when 
  computing <FONT face=Arial,Helvetica><EM>d</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>2</SUB> - 4<FONT 
  face=Arial,Helvetica><EM>ac</EM></FONT>. This one cannot be eliminated by a 
  simple rearrangement of the formula. Roughly speaking, when <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  4<FONT face=Arial,Helvetica><EM>ac</EM></FONT>, rounding error can contaminate 
  up to half the digits in the roots computed with the quadratic formula. Here 
  is an informal proof (another approach to estimating the error in the 
  quadratic formula appears in Kahan [1972]).</FONT> </P>
  <P><A name=1239></A><FONT face="Verdana, Arial, Helvetica, sans-serif"><FONT 
  face=Arial,Helvetica><EM>If b</EM></FONT><SUP>2</SUP><EM> </EM><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT><EM> 
  </EM>4<EM>ac, rounding error can contaminate up to half the digits in the 
  roots computed with the quadratic formula </EM><IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg239.gif" 
  width=117> <EM>. </EM></FONT></P>
  <P><A name=1240></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Proof: 
  Write (<FONT face=Arial,Helvetica><EM>b</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  b) <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg233.gif" 
  width=13> (4<FONT face=Arial,Helvetica><EM>a</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>c</EM></FONT>) = (<FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP>(1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>) 
  - 4<FONT face=Arial,Helvetica><EM>ac</EM></FONT>(1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>)) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>), 
  where |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>i</EM></SUB>|<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>.<FONT 
  face=Arial,Helvetica><EM> </EM></FONT><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1241"><SUP>30</SUP></A> 
  Using <FONT face=Arial,Helvetica><EM>d</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> - 4<FONT 
  face=Arial,Helvetica><EM>ac</EM></FONT>, this can be rewritten as (<FONT 
  face=Arial,Helvetica><EM>d</EM></FONT>(1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>) 
  - 4<FONT face=Arial,Helvetica><EM>ac</EM></FONT>(<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB> 
  - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>)) 
  (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>). 
  To get an estimate for the size of this error, ignore second order terms in 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>i</EM></SUB>, 
  in which case the absolute error is <FONT 
  face=Arial,Helvetica><EM>d</EM></FONT>(<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>) 
  - 4ac<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>4</SUB>, 
  where |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>4</SUB>| 
  = |<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB>&nbsp;-&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  Since <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg245.gif" 
  width=42> , the first term <FONT face=Arial,Helvetica><EM>d</EM></FONT>(<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>1</SUB> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>) 
  can be ignored. To estimate the second term, use the fact that <FONT 
  face=Arial,Helvetica><EM>ax</EM></FONT><SUP>2</SUP>&nbsp;+&nbsp;<FONT 
  face=Arial,Helvetica><EM>bx</EM></FONT>&nbsp;+ <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>a</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>r</EM></FONT><SUB>1</SUB>) (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>r</EM></FONT><SUB>2</SUB>), so <FONT 
  face=Arial,Helvetica><EM>ar</EM></FONT><SUB>1</SUB><FONT 
  face=Arial,Helvetica><EM>r</EM></FONT><SUB>2</SUB>&nbsp;= <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT>. Since <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUP>2</SUP> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  4<FONT face=Arial,Helvetica><EM>ac</EM></FONT>, then<FONT 
  face=Arial,Helvetica><EM> r</EM></FONT><SUB>1</SUB> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  <SUB><EM>r</EM></SUB><SUB>2</SUB>, so the second error term is <IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg250.gif" 
  width=96> . Thus the computed value of <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg256.gif" 
  width=19> is</FONT> </P><A name=12176></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=24 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg261.gif" 
  width=75> . <BR></FONT>
  <P><A name=12178></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  inequality </FONT></P><A name=1242></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=21 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg267.gif" 
  width=282> <BR></FONT>
  <P><A name=1243></A><FONT face="Verdana, Arial, Helvetica, sans-serif">shows 
  that</FONT> </P><A name=12172></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=24 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg272.gif" 
  width=131> ,<BR></FONT>
  <P><A name=12174></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">where</FONT> </P><A 
  name=6453></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG 
  height=24 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg277.gif" 
  width=88> , <BR></FONT>
  <P><A name=6455></A><FONT face="Verdana, Arial, Helvetica, sans-serif">so the 
  absolute error in <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg282.gif" 
  width=34> <EM>a</EM> is about <IMG height=23 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg288.gif" 
  width=35> . Since <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>4</SUB> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>-</SUP><SUP><EM>p</EM></SUP>, 
  <IMG height=23 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg292.gif" 
  width=67> , and thus the absolute error of <IMG height=23 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg297.gif" 
  width=35> destroys the bottom half of the bits of the roots <FONT 
  face=Arial,Helvetica><EM>r</EM></FONT><SUB>1</SUB> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  r<SUB>2</SUB>. In other words, since the calculation of the roots involves 
  computing with <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg301.gif" 
  width=61> , and this expression does not have meaningful bits in the position 
  corresponding to the lower order half of <FONT 
  face=Arial,Helvetica><EM>r</EM></FONT><SUB>i</SUB>, then the lower order bits 
  of <FONT face=Arial,Helvetica><EM>r</EM></FONT><SUB>i</SUB> cannot be 
  meaningful. <FONT face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT> 
  </FONT></P>
  <P><A name=1244></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Finally, we turn to the proof of 
  Theorem 6. It is based on the following fact, which is proven in the section 
  <A href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1324">Theorem 
  14 and Theorem 8</A>. </FONT></P>
  <H4><A name=1245></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 14</FONT> </H4>
  <DL>
    <DT><A name=1246></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>Let </EM>0<EM> &lt; k &lt; 
    p, and set m = </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><EM> 
    + </EM>1<EM>, and assume that floating-point operations are exactly rounded. 
    Then (m </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT><EM> 
    x) </EM><IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg244.gif" 
    width=13> <EM>(m </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT><EM> 
    x </EM><IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg255.gif" 
    width=13> <EM>x) is exactly equal to x rounded to p - k significant digits. 
    More precisely, x is rounded by taking the significand of x, imagining a 
    radix point just left of the k least significant digits and rounding to an 
    integer. </EM></FONT></DT></DL>
  <H4><A name=1247></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof of Theorem 6 </FONT></H4>
  <DL>
    <DT><A name=1248></A><FONT face="Verdana, Arial, Helvetica, sans-serif">By 
    Theorem 14, <EM>x</EM><SUB>h</SUB> is <EM>x</EM> rounded to <EM>p</EM> - k 
    =<FONT face="Verdana, Arial, Helvetica, sans-serif"> </FONT><IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg110.gif" 
    width=39> places. If there is no carry out, then certainly <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>h</SUB> can be represented with 
    <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg107.gif" 
    width=39> significant digits. Suppose there is a carry-out. If <EM>x</EM> = 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT><SUB>0</SUB>.<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif">...</FONT> <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>p - 1</SUB> × <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP>, 
    then rounding adds 1 to <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>p&nbsp;-&nbsp;</SUB><SUB><EM>k</EM></SUB><SUB>&nbsp;-&nbsp;1</SUB>, 
    and the only way there can be a carry-out is if <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>p - 
    </SUB><SUB><EM>k</EM></SUB><SUB> - 1</SUB> = <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"> 
    </FONT>- 1, but then the low order digit of <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>h</SUB> is 1&nbsp;+&nbsp;<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>p&nbsp;-&nbsp;</SUB><SUB><EM>k</EM></SUB><SUB>-&nbsp;1</SUB>&nbsp;=&nbsp;0, 
    and so again <EM>x</EM><SUB>h</SUB> is representable in <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg116.gif" 
    width=39> digits. </FONT>
    <DT><A name=1249></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To 
    deal with <EM>x</EM><SUB>l</SUB>, scale <EM>x</EM> to be an integer 
    satisfying <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>p</EM></SUP><SUP> 
    - 1</SUP> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>p</EM></SUP> 
    - 1. Let <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg307.gif" 
    width=63> where <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg4.gif" 
    width=15> is the <EM>p</EM> - <FONT face=Arial,Helvetica><EM>k</EM></FONT> 
    high order digits of <EM>x</EM>, and <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg9.gif" 
    width=13> is the <FONT face=Arial,Helvetica><EM>k</EM></FONT> low order 
    digits. There are three cases to consider. If <IMG height=21 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg14.gif" 
    width=85> , then rounding <EM>x</EM> to <EM>p</EM> - <FONT 
    face=Arial,Helvetica><EM>k</EM></FONT> places is the same as chopping and 
    <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg20.gif" 
    width=46> , and <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg25.gif" 
    width=41> . Since <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg31.gif" 
    width=13> has at most <FONT face=Arial,Helvetica><EM>k</EM></FONT> digits, 
    if p is even, then <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg34.gif" 
    width=13> has at most k = <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg129.gif" 
    width=39> =<IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg121.gif" 
    width=39> <FONT face="Verdana, Arial, Helvetica, sans-serif"></FONT>digits. 
    Otherwise, <IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"> 
    = 2 and <IMG height=21 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg39.gif" 
    width=54> is representable with <FONT face=Arial,Helvetica><EM>k</EM></FONT> 
    - 1 <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
    <IMG height=16 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg125.gif" 
    width=39> significant bits. The second case is when <IMG height=18 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg44.gif" 
    width=82> , and then computing <EM>x</EM><SUB>h</SUB> involves rounding up, 
    so <EM>x</EM><SUB>h</SUB> = <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg49.gif" 
    width=15> + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>, 
    and <EM>x</EM><SUB>l</SUB>&nbsp;=&nbsp;<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;-&nbsp;<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>h</SUB>&nbsp;=&nbsp;<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;-&nbsp;<IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg54.gif" 
    width=15> <FONT face="Verdana, Arial, Helvetica, sans-serif">-<IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>k</SUP> 
    = <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg59.gif" 
    width=13> - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>. 
    Once again, <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg64.gif" 
    width=13> has at most <FONT face=Arial,Helvetica><EM>k</EM></FONT> digits, 
    so is representable with <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakltbt.gif"></FONT>p/2<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakrtbt.gif"> 
    </FONT>digits. Finally, if <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg68.gif" 
    width=13> = (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2)<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><SUP> 
    - 1</SUP>, then <EM>x</EM><SUB>h</SUB> = <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg73.gif" 
    width=15> or <IMG height=19 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg77.gif" 
    width=15> &nbsp;+&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP> 
    depending on whether there is a round up. So <EM>x</EM><SUB>l</SUB> is 
    either (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2)<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><SUP> 
    - 1</SUP> or (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2)<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><SUP>&nbsp;-&nbsp;1</SUP>&nbsp;-&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>&nbsp;=&nbsp;-<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>k</SUP>/2, 
    both of which are represented with 1 digit. <FONT 
    face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT> </FONT></DT></DL>
  <P><A name=1250></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Theorem 
  6 gives a way to express the product of two working precision numbers exactly 
  as a sum. There is a companion formula for expressing a sum exactly. If |<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>|<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
  |<FONT face=Arial,Helvetica><EM>y</EM></FONT>| then <EM>x</EM> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT> = (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT>) + (<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg266.gif" 
  width=13> (<FONT face=Arial,Helvetica><EM>x</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT>)) <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT> [Dekker 1971; Knuth 1981, Theorem 
  C in section 4.2.2]. However, when using exactly rounded operations, this 
  formula is only true for <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 2, and not for <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10 as the example <EM>x</EM>&nbsp;=&nbsp;.99998, 
  <EM>y</EM>&nbsp;=&nbsp;.99997 shows. </FONT></P>
  <H3><A name=1251></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Binary to Decimal Conversion </FONT></H3>
  <P><A name=1252></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Since 
  single precision has <EM>p</EM> = 24, and 2<SUP>24</SUP> &lt; 10<SUP>8</SUP>, 
  you might expect that converting a binary number to 8 decimal digits would be 
  sufficient to recover the original binary number. However, this is not the 
  case. </FONT></P>
  <H4><A name=1253></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 15</FONT> </H4>
  <DL>
    <DT><A name=1254></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>When a binary IEEE single 
    precision number is converted to the closest eight digit decimal number, it 
    is not always possible to uniquely recover the binary number from the 
    decimal one. However, if nine decimal digits are used, then converting the 
    decimal number to the closest binary number will recover the original 
    floating-point number.</EM> </FONT></DT></DL>
  <H4><A name=1255></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H4>
  <DL>
    <DT><A name=1256></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Binary single precision numbers 
    lying in the half open interval [10<SUP>3</SUP>, 2<SUP>10</SUP>) = 
    [1000,&nbsp;1024) have 10 bits to the left of the binary point, and 14 bits 
    to the right of the binary point. Thus there are (2<SUP>10</SUP> - 
    10<SUP>3</SUP>)2<SUP>14</SUP> = 393,216 different binary numbers in that 
    interval. If decimal numbers are represented with 8 digits, then there are 
    (2<SUP>10</SUP>&nbsp;-&nbsp;10<SUP>3</SUP>)10<SUP>4</SUP> = 240,000 decimal 
    numbers in the same interval. There is no way that 240,000 decimal numbers 
    could represent 393,216 different binary numbers. So 8 decimal digits are 
    not enough to uniquely represent each single precision binary number. 
</FONT>
    <DT><A name=1257></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To 
    show that 9 digits are sufficient, it is enough to show that the spacing 
    between binary numbers is always greater than the spacing between decimal 
    numbers. This will ensure that for each decimal number <FONT 
    face=Arial,Helvetica><EM>N</EM></FONT>, the interval </FONT></DT></DL><A 
  name=10951></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2>[<FONT face=Arial,Helvetica><EM>N</EM></FONT> - <IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg83.gif" 
  width=10> ulp, <FONT face=Arial,Helvetica><EM>N</EM></FONT> + <IMG height=31 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg88.gif" 
  width=10> ulp] <BR></FONT>
  <DL>
    <DT><A name=10952></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">contains at most one binary 
    number. Thus each binary number rounds to a unique decimal number which in 
    turn rounds to a unique binary number. </FONT>
    <DT><A name=1258></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To 
    show that the spacing between binary numbers is always greater than the 
    spacing between decimal numbers, consider an interval 
    [10<SUP><EM>n</EM></SUP>, 10<SUP><EM>n</EM></SUP><SUP> + 1</SUP>]. On this 
    interval, the spacing between consecutive decimal numbers is 
    10<SUP>(</SUP><SUP><EM>n</EM></SUP><SUP>&nbsp;+&nbsp;1)&nbsp;-&nbsp;9</SUP>. 
    On [10<SUP><EM>n</EM></SUP>, 2<SUP><EM>m</EM></SUP>], where <FONT 
    face=Arial,Helvetica><EM>m</EM></FONT> is the smallest integer so that 
    10<SUP>n</SUP> &lt; 2<SUP><EM>m</EM></SUP>, the spacing of binary numbers is 
    2<SUP><EM>m</EM></SUP><SUP> - 24</SUP>, and the spacing gets larger further 
    on in the interval. Thus it is enough to check that 
    10<SUP>(</SUP><SUP><EM>n</EM></SUP><SUP>&nbsp;+&nbsp;1)&nbsp;-&nbsp;9</SUP> 
    &lt; 2<SUP><EM>m</EM></SUP><SUP> - 24</SUP>. But in fact, since 
    10<SUP><EM>n</EM></SUP> &lt; 2<SUP><EM>m</EM></SUP>, then 
    10<SUP>(</SUP><SUP><EM>n</EM></SUP><SUP>&nbsp;+&nbsp;1)&nbsp;-&nbsp;9</SUP> 
    = 10<SUP><EM>n</EM></SUP>10<SUP>-8</SUP> &lt; 
    2<SUP><EM>m</EM></SUP>10<SUP>-8</SUP> &lt; 
    2<SUP><EM>m</EM></SUP>2<SUP>-24</SUP>. <FONT 
    face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT></FONT> </DT></DL>
  <P><A name=1259></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  same argument applied to double precision shows that 17 decimal digits are 
  required to recover a double precision number. </FONT></P>
  <P><A name=1260></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Binary-decimal conversion also 
  provides another example of the use of flags. Recall from the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#810">Precision</A>, 
  that to recover a binary number from its decimal expansion, the decimal to 
  binary conversion must be computed exactly. That conversion is performed by 
  multiplying the quantities <FONT face=Arial,Helvetica><EM>N</EM></FONT> and 
  10<SUP>|</SUP><SUP><EM>P</EM></SUP><SUP>|</SUP> (which are both exact if 
  <EM>p</EM> &lt; 13) in single-extended precision and then rounding this to 
  single precision (or dividing if <EM>p</EM> &lt; 0; both cases are similar). 
  Of course the computation of <FONT face=Arial,Helvetica><EM>N</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> · 
  </FONT>10<SUP>|</SUP><SUP><EM>P</EM></SUP><SUP>|</SUP> cannot be exact; it is 
  the combined operation round(<FONT face=Arial,Helvetica><EM>N</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> · 
  </FONT>10<SUP>|</SUP><SUP><EM>P</EM></SUP><SUP>|</SUP>) that must be exact, 
  where the rounding is from single-extended to single precision. To see why it 
  might fail to be exact, take the simple case of <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT> 
  = 10, <EM>p</EM> = 2 for single, and <EM>p</EM> = 3 for single-extended. If 
  the product is to be 12.51, then this would be rounded to 12.5 as part of the 
  single-extended multiply operation. Rounding to single precision would give 
  12. But that answer is not correct, because rounding the product to single 
  precision should give 13. The error is due to double rounding. </FONT></P>
  <P><A name=1261></A><FONT face="Verdana, Arial, Helvetica, sans-serif">By 
  using the IEEE flags, double rounding can be avoided as follows. Save the 
  current value of the inexact flag, and then reset it. Set the rounding mode to 
  round-to-zero. Then perform the multiplication <FONT 
  face=Arial,Helvetica><EM>N</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> · 
  </FONT>10<SUP>|</SUP><SUP><EM>P</EM></SUP><SUP>|</SUP>. Store the new value of 
  the inexact flag in <CODE>ixflag</CODE>, and restore the rounding mode and 
  inexact flag. If <CODE>ixflag</CODE> is 0, then <FONT 
  face=Arial,Helvetica><EM>N</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> · 
  </FONT>10<SUP>|</SUP><SUP><EM>P</EM></SUP><SUP>|</SUP> is exact, so 
  round(<FONT face=Arial,Helvetica><EM>N</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> · 
  </FONT>10<SUP>|</SUP><SUP><EM>P</EM></SUP><SUP>|</SUP>) will be correct down 
  to the last bit. If <CODE>ixflag</CODE> is 1, then some digits were truncated, 
  since round-to-zero always truncates. The significand of the product will look 
  like 1<FONT face=Arial,Helvetica><EM>.b</EM></FONT><SUB>1</SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>22</SUB><FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>23</SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>31</SUB>. A double rounding error 
  may occur if <FONT face=Arial,Helvetica><EM>b</EM></FONT><SUB>23</SUB> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>31</SUB> = 10<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>0. A simple way to 
  account for both cases is to perform a logical <CODE>OR</CODE> of 
  <CODE>ixflag</CODE> with <FONT 
  face=Arial,Helvetica><EM>b</EM></FONT><SUB>31</SUB>. Then round(<FONT 
  face=Arial,Helvetica><EM>N</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> · 
  </FONT>10<SUP>|</SUP><SUP><EM>P</EM></SUP><SUP>|</SUP>) will be computed 
  correctly in all cases. </FONT></P>
  <H3><A name=1262></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Errors In Summation </FONT></H3>
  <P><A name=1263></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1070">Optimizers</A>, 
  mentioned the problem of accurately computing very long sums. The simplest 
  approach to improving accuracy is to double the precision. To get a rough 
  estimate of how much doubling the precision improves the accuracy of a sum, 
  let <FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB> = <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB>, <FONT 
  face=Arial,Helvetica><EM>s</EM></FONT><SUB>2</SUB>&nbsp;=&nbsp;<FONT 
  face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB>&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT>&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>2</SUB><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT>, <FONT 
  face=Arial,Helvetica><EM>s</EM></FONT><SUB>i</SUB> = <FONT 
  face=Arial,Helvetica><EM>s</EM></FONT><SUB>i</SUB> - 1<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT><SUB>i</SUB>. Then <FONT 
  face=Arial,Helvetica><EM>s</EM></FONT><SUB>i</SUB>&nbsp;=&nbsp;(1&nbsp;+&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>i</EM></SUB>) 
  (<FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>i - 1</SUB> + <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUB>i</SUB>), where <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakmidl.gif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>i</EM></SUB><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakmidl.gif"> 
  <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"> 
  <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif">, 
  and ignoring second order terms in <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>i</EM></SUB> 
  gives </FONT></P>
  <P><A name=10963></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"></FONT></P><A name=1264></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(31) <IMG height=47 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg92.gif" 
  width=272> <BR></FONT>
  <P><A name=1265></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  first equality of <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1264">(31)</A> 
  shows that the computed value of <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg98.gif" 
  width=22> is the same as if an exact summation was performed on perturbed 
  values of <EM>x</EM><SUB>j</SUB>. The first term <EM>x</EM><SUB>1</SUB> is 
  perturbed by <FONT face=Arial,Helvetica><EM>n</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>, 
  the last term <EM>x</EM><SUB>n</SUB> by only <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  The second equality in <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1264">(31)</A> 
  shows that error term is bounded by <IMG height=19 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg102.gif" 
  width=41> . Doubling the precision has the effect of squaring <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  If the sum is being done in an IEEE double precision format, 1/<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT> 
  10<SUP>16</SUP>, so that <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg108.gif" 
  width=35> for any reasonable value of <FONT 
  face=Arial,Helvetica><EM>n</EM></FONT>. Thus, doubling the precision takes the 
  maximum perturbation of <FONT face=Arial,Helvetica><EM>n</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  and changes it to <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg111.gif" 
  width=40> . Thus the 2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  error bound for the Kahan summation formula (Theorem 8) is not as good as 
  using double precision, even though it is much better than single precision. 
  </FONT></P>
  <P><A name=1266></A><FONT face="Verdana, Arial, Helvetica, sans-serif">For an 
  intuitive explanation of why the Kahan summation formula works, consider the 
  following diagram of the procedure. </FONT></P><A name=1282></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><IMG height=297 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg117.gif" 
  width=700> <BR></FONT>
  <P><A name=1283></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Each 
  time a summand is added, there is a correction factor <FONT 
  face=Arial,Helvetica><EM>C</EM></FONT> which will be applied on the next loop. 
  So first subtract the correction <FONT face=Arial,Helvetica><EM>C</EM></FONT> 
  computed in the previous loop from <FONT 
  face=Arial,Helvetica><EM>X</EM></FONT><SUB>j</SUB>, giving the corrected 
  summand <EM>Y</EM>. Then add this summand to the running sum <FONT 
  face=Arial,Helvetica><EM>S</EM></FONT>. The low order bits of <EM>Y</EM> 
  (namely <EM>Y</EM><SUB>l</SUB>) are lost in the sum. Next compute the high 
  order bits of <EM>Y</EM> by computing <FONT 
  face=Arial,Helvetica><EM>T</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>S</EM></FONT>. When <EM>Y</EM> is subtracted from 
  this, the low order bits of <EM>Y</EM> will be recovered. These are the bits 
  that were lost in the first sum in the diagram. They become the correction 
  factor for the next loop. A formal proof of Theorem 8, taken from Knuth [1981] 
  page 572, appears in the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1324">Theorem 14 
  and Theorem 8</A>." </FONT></P>
  <H2><A name=1284></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Summary </FONT></H2>
  <P><A name=1285></A><FONT face="Verdana, Arial, Helvetica, sans-serif">It is 
  not uncommon for computer system designers to neglect the parts of a system 
  related to floating-point. This is probably due to the fact that 
  floating-point is given very little (if any) attention in the computer science 
  curriculum. This in turn has caused the apparently widespread belief that 
  floating-point is not a quantifiable subject, and so there is little point in 
  fussing over the details of hardware and software that deal with it. 
  </FONT></P>
  <P><A name=1286></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
  paper has demonstrated that it is possible to reason rigorously about 
  floating-point. For example, floating-point algorithms involving cancellation 
  can be proven to have small relative errors if the underlying hardware has a 
  guard digit, and there is an efficient algorithm for binary-decimal conversion 
  that can be proven to be invertible, provided that extended precision is 
  supported. The task of constructing reliable floating-point software is made 
  much easier when the underlying computer system is supportive of 
  floating-point. In addition to the two examples just mentioned (guard digits 
  and extended precision), the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1015">Systems 
  Aspects</A> of this paper has examples ranging from instruction set design to 
  compiler optimization illustrating how to better support floating-point. 
  </FONT></P>
  <P><A name=1287></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  increasing acceptance of the IEEE floating-point standard means that codes 
  that utilize features of the standard are becoming ever more portable. The 
  section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#799">The IEEE 
  Standard</A>, gave numerous examples illustrating how the features of the IEEE 
  standard can be used in writing practical floating-point codes. </FONT></P>
  <H2><A name=1288></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Acknowledgments </FONT></H2>
  <P><A name=1289></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
  article was inspired by a course given by W. Kahan at Sun Microsystems from 
  May through July of 1988, which was very ably organized by David Hough of Sun. 
  My hope is to enable others to learn about the interaction of floating-point 
  and computer systems without having to get up in time to attend 8:00 a.m. 
  lectures. Thanks are due to Kahan and many of my colleagues at Xerox PARC 
  (especially John Gilbert) for reading drafts of this paper and providing many 
  useful comments. Reviews from Paul Hilfinger and an anonymous referee also 
  helped improve the presentation. </FONT></P>
  <H2><A name=1290></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>References </FONT></H2>
  <P><A name=1291></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Aho, 
  Alfred V., Sethi, R., and Ullman J. D. 1986. <EM>Compilers: Principles, 
  Techniques and Tools</EM>, Addison-Wesley, Reading, MA. </FONT></P>
  <P><A name=1292></A><FONT face="Verdana, Arial, Helvetica, sans-serif">ANSI 
  1978. <EM>American National Standard Programming Language FORTRAN</EM>, ANSI 
  Standard X3.9-1978, American National Standards Institute, New York, NY. 
  </FONT></P>
  <P><A name=1293></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Barnett, David 1987. <EM>A 
  Portable Floating-Point Environment</EM>, unpublished manuscript. </FONT></P>
  <P><A name=1294></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Brown, 
  W. S. 1981. <EM>A Simple but Realistic Model of Floating-Point 
  Computation</EM>, ACM Trans. on Math. Software 7(4), pp. 445-480. </FONT></P>
  <P><A name=1295></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Cody, 
  W. J et. al. 1984. <EM>A Proposed Radix- and Word-length-independent Standard 
  for Floating-point Arithmetic</EM>, IEEE Micro 4(4), pp. 86-100. </FONT></P>
  <P><A name=1296></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Cody, 
  W. J. 1988. <EM>Floating-Point Standards -- Theory and Practice</EM>, in 
  "Reliability in Computing: the role of interval methods in scientific 
  computing", ed. by Ramon E. Moore, pp. 99-107, Academic Press, Boston, MA. 
  </FONT></P>
  <P><A name=1297></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Coonen, 
  Jerome 1984. <EM>Contributions to a Proposed Standard for Binary 
  Floating-Point Arithmetic</EM>, PhD Thesis, Univ. of California, Berkeley. 
  </FONT></P>
  <P><A name=1298></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Dekker, 
  T. J. 1971. <EM>A Floating-Point Technique for Extending the Available 
  Precision</EM>, Numer. Math. 18(3), pp. 224-242. </FONT></P>
  <P><A name=1299></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Demmel, 
  James 1984. <EM>Underflow and the Reliability of Numerical Software</EM>, SIAM 
  J. Sci. Stat. Comput. 5(4), pp. 887-919. </FONT></P>
  <P><A name=1300></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Farnum, 
  Charles 1988. <EM>Compiler Support for Floating-point Computation</EM>, 
  Software-Practice and Experience, 18(7), pp. 701-709. </FONT></P>
  <P><A name=1301></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Forsythe, G. E. and Moler, C. B. 
  1967. <EM>Computer Solution of Linear Algebraic Systems</EM>, Prentice-Hall, 
  Englewood Cliffs, NJ.</FONT> </P>
  <P><A name=1302></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Goldberg, I. Bennett 1967. <EM>27 
  Bits Are Not Enough for 8-Digit Accuracy</EM>, Comm. of the ACM. 10(2), pp 
  105-106.</FONT> </P>
  <P><A name=1303></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Goldberg, David 1990. 
  <EM>Computer Arithmetic</EM>, in "Computer Architecture: A Quantitative 
  Approach", by David Patterson and John L. Hennessy, Appendix A, Morgan 
  Kaufmann, Los Altos, CA. </FONT></P>
  <P><A name=1304></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Golub, 
  Gene H. and Van Loan, Charles F. 1989. <EM>Matrix Computations</EM>, 2nd 
  edition,The Johns Hopkins University Press, Baltimore Maryland. </FONT></P>
  <P><A name=1305></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Graham, 
  Ronald L. , Knuth, Donald E. and Patashnik, Oren. 1989. <EM>Concrete 
  Mathematics, </EM>Addison-Wesley, Reading, MA, p.162.</FONT> </P>
  <P><A name=1306></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Hewlett 
  Packard 1982. <EM>HP-15C Advanced Functions Handbook</EM>.</FONT> </P>
  <P><A name=1307></A><FONT face="Verdana, Arial, Helvetica, sans-serif">IEEE 
  1987. <EM>IEEE Standard 754-1985 for Binary Floating-point Arithmetic</EM>, 
  IEEE, (1985). Reprinted in SIGPLAN 22(2) pp. 9-25.</FONT> </P>
  <P><A name=1308></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Kahan, 
  W. 1972. <EM>A Survey Of Error Analysis</EM>, in Information Processing 71, 
  Vol 2, pp. 1214 - 1239 (Ljubljana, Yugoslavia), North Holland, 
  Amsterdam.</FONT> </P>
  <P><A name=1309></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Kahan, 
  W. 1986. <EM>Calculating Area and Angle of a Needle-like Triangle</EM>, 
  unpublished manuscript. </FONT></P>
  <P><A name=1310></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Kahan, 
  W. 1987. <EM>Branch Cuts for Complex Elementary Functions</EM>, in "The State 
  of the Art in Numerical Analysis", ed. by M.J.D. Powell and A. Iserles (Univ 
  of Birmingham, England), Chapter 7, Oxford University Press, New York. 
  </FONT></P>
  <P><A name=1311></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Kahan, 
  W. 1988. Unpublished lectures given at Sun Microsystems, Mountain View, 
  CA.</FONT> </P>
  <P><A name=1312></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Kahan, 
  W. and Coonen, Jerome T. 1982. <EM>The Near Orthogonality of Syntax, 
  Semantics, and Diagnostics in Numerical Programming Environments</EM>, in "The 
  Relationship Between Numerical Computation And Programming Languages", ed. by 
  J. K. Reid, pp. 103-115, North-Holland, Amsterdam. </FONT></P>
  <P><A name=1313></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Kahan, 
  W. and LeBlanc, E. 1985. <EM>Anomalies in the IBM Acrith Package</EM>, Proc. 
  7th IEEE Symposium on Computer Arithmetic (Urbana, Illinois), pp. 322-331. 
  </FONT></P>
  <P><A name=1314></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Kernighan, Brian W. and Ritchie, 
  Dennis M. 1978. <EM>The C Programming Language</EM>, Prentice-Hall, Englewood 
  Cliffs, NJ.</FONT> </P>
  <P><A name=1315></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Kirchner, R. and Kulisch, U. 
  1987. <EM>Arithmetic for Vector Processors</EM>, Proc. 8th IEEE Symposium on 
  Computer Arithmetic (Como, Italy), pp. 256-269. </FONT></P>
  <P><A name=1316></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Knuth, 
  Donald E., 1981. <EM>The Art of Computer Programming, Volume II</EM>, Second 
  Edition, Addison-Wesley, Reading, MA. </FONT></P>
  <P><A name=1317></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Kulisch, U. W., and Miranker, W. 
  L. 1986. <EM>The Arithmetic of the Digital Computer: A New Approach</EM>, SIAM 
  Review 28(1), pp 1-36.</FONT> </P>
  <P><A name=1318></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Matula, 
  D. W. and Kornerup, P. 1985. <EM>Finite Precision Rational Arithmetic: Slash 
  Number Systems</EM>, IEEE Trans. on Comput. C-34(1), pp 3-18. </FONT></P>
  <P><A name=1319></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Nelson, 
  G. 1991. <EM>Systems Programming With Modula-3</EM>, Prentice-Hall, Englewood 
  Cliffs, NJ. </FONT></P>
  <P><A name=1320></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Reiser, 
  John F. and Knuth, Donald E. 1975. <EM>Evading the Drift in Floating-point 
  Addition</EM>, Information Processing Letters 3(3), pp 84-87. </FONT></P>
  <P><A name=1321></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Sterbenz, Pat H. 1974. 
  <EM>Floating-Point Computation</EM>, Prentice-Hall, Englewood Cliffs, NJ. 
  </FONT></P>
  <P><A name=1322></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Swartzlander, Earl E. and 
  Alexopoulos, Aristides G. 1975. <EM>The Sign/Logarithm Number System</EM>, 
  IEEE Trans. Comput. C-24(12), pp. 1238-1242.</FONT> </P>
  <P><A name=1323></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Walther, J. S., 1971. <EM>A 
  unified algorithm for elementary functions</EM>, Proceedings of the AFIP 
  Spring Joint Computer Conf. 38, pp. 379-385. </FONT></P>
  <H2><A name=1324></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 14 and Theorem 8 </FONT></H2>
  <P><A name=1325></A><FONT face="Verdana, Arial, Helvetica, sans-serif">This 
  section contains two of the more technical proofs that were omitted from the 
  text. </FONT></P>
  <H3><A name=1326></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 14</FONT> </H3>
  <DL>
    <DT><A name=1327></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>Let </EM>0<EM> &lt; k &lt; 
    p, and set m = </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><EM> 
    + </EM>1<EM>, and assume that floating-point operations are exactly rounded. 
    Then </EM>(<EM>m </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT><EM> 
    x</EM>)<EM> </EM><IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg276.gif" 
    width=13> <EM></EM>(<EM>m </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT><EM> 
    x </EM><IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg287.gif" 
    width=13> <EM>x</EM>)<EM> is exactly equal to x rounded to p&nbsp;-&nbsp;k 
    significant digits. More precisely, x is rounded by taking the significand 
    of x, imagining a radix point just left of the k least significant digits, 
    and rounding to an integer.</EM></FONT> </DT></DL>
  <H3><A name=1328></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H3>
  <DL>
    <DT><A name=1329></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
    proof breaks up into two cases, depending on whether or not the computation 
    of <FONT face=Arial,Helvetica><EM>mx</EM></FONT> = <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> has a carry-out or not. </FONT>
    <DT><A name=1162></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Assume there is no carry out. 
    It is harmless to scale <EM>x</EM> so that it is an integer. Then the 
    computation of <FONT face=Arial,Helvetica><EM>mx</EM></FONT> = <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> looks like this: </FONT>
    <DL>
      <DT><A name=1165></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><CODE>aa...aabb...bb<BR>+ 
      </CODE><FONT face="Verdana, Arial, Helvetica, sans-serif" 
      size=3>aa...aabb...bb<BR></FONT><CODE>zz...zzbb...bb</CODE></FONT> 
</DT></DL>
    <DT><A name=12191></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">where <EM>x</EM> has been 
    partitioned into two parts. The low order <FONT 
    face=Arial,Helvetica><EM>k</EM></FONT> digits are marked <CODE>b</CODE> and 
    the high order <EM>p</EM> - <FONT face=Arial,Helvetica><EM>k</EM></FONT> 
    digits are marked <CODE>a</CODE>. To compute <FONT 
    face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> from <FONT 
    face=Arial,Helvetica><EM>mx </EM></FONT>involves rounding off the low order 
    <FONT face=Arial,Helvetica><EM>k</EM></FONT> digits (the ones marked with 
    <CODE>b</CODE>) so </FONT></DT></DL><A name=12192></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(32) <FONT 
  face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT> = <FONT 
  face=Arial,Helvetica><EM>mx</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> mod(<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>) 
  + r<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>k</SUP><BR></FONT>
  <DL>
    <DT><A name=12196></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
    value of <FONT face=Arial,Helvetica><EM>r</EM></FONT> is 1 if 
    <CODE>.bb...b</CODE> is greater than <IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg30.gif" 
    width=8> and 0 otherwise. More precisely</FONT> </DT></DL><A 
  name=12201></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(33) 
  <FONT face=Arial,Helvetica><EM>r</EM></FONT>&nbsp;=&nbsp;1 if 
  <CODE>a.bb...b</CODE> rounds to <FONT face=Arial,Helvetica><EM>a</EM></FONT> + 
  1, <FONT face=Arial,Helvetica><EM>r</EM></FONT> = 0 otherwise. <BR></FONT>
  <DL>
    <DT><A name=1334></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Next 
    compute <FONT face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> = <FONT 
    face=Arial,Helvetica><EM>mx</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> mod(<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>) 
    + <FONT face=Arial,Helvetica><EM>r</EM></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP> 
    - <FONT face=Arial,Helvetica><EM>x</EM></FONT> = <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
    face=Arial,Helvetica><EM>r</EM></FONT>) - <FONT face=Arial,Helvetica><EM>x 
    </EM></FONT>mod(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>). 
    The picture below shows the computation of <FONT 
    face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> rounded, that is, (<FONT 
    face=Arial,Helvetica><EM>m</EM></FONT>&nbsp;<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT>) <IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg296.gif" 
    width=13> <FONT face=Arial,Helvetica><EM>x</EM></FONT>. The top line is 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>(<FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
    face=Arial,Helvetica><EM>r</EM></FONT>), where <CODE>B</CODE> is the digit 
    that results from adding <CODE>r</CODE> to the lowest order digit 
    <CODE>b</CODE>.</FONT> 
    <DL>
      <DT><A name=9755></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><CODE>aa...aabb...bB00...00<BR>- 
      </CODE><FONT face="Verdana, Arial, Helvetica, sans-serif" size=3>bb...bb 
      <BR></FONT><CODE>zz... zzZ00...00</CODE></FONT> </DT></DL>
    <DT><A name=11025></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If 
    <CODE>.bb...b</CODE> &lt; <IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg235.gif" 
    width=8> then <FONT face=Arial,Helvetica><EM>r</EM></FONT> = 0, subtracting 
    causes a borrow from the digit marked <CODE>B</CODE>, but the difference is 
    rounded up, and so the net effect is that the rounded difference equals the 
    top line, which is <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>. If <CODE>.bb...b</CODE> &gt; <IMG 
    height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg202.gif" 
    width=8> then <FONT face=Arial,Helvetica><EM>r</EM></FONT>&nbsp;=&nbsp;1, 
    and 1 is subtracted from <CODE>B</CODE> because of the borrow, so the result 
    is <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>. Finally consider the case 
    <CODE>.bb...b</CODE>&nbsp;= <IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg205.gif" 
    width=8> . If <FONT face=Arial,Helvetica><EM>r</EM></FONT> = 0 then 
    <CODE>B</CODE> is even, <CODE>Z</CODE> is odd, and the difference is rounded 
    up, giving <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>. Similarly when <FONT 
    face=Arial,Helvetica><EM>r</EM></FONT> = 1, <CODE>B</CODE> is odd, 
    <CODE>Z</CODE> is even, the difference is rounded down, so again the 
    difference is <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>. To summarize </FONT></DT></DL><A 
  name=1337></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2>(34) 
  (<FONT face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT>) <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg306.gif" 
  width=13> <FONT face=Arial,Helvetica><EM>x</EM></FONT> = <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> <BR></FONT>
  <DL>
    <DT><A name=1338></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Combining equations <A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#12192">(32)</A> 
    and <A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1337">(34)</A> 
    gives (<FONT face=Arial,Helvetica><EM>m</EM></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT>) - (<FONT 
    face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg8.gif" 
    width=13> <FONT face=Arial,Helvetica><EM>x</EM></FONT>) = <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> mod(<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>) 
    + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/rho.gif">·<IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>. 
    The result of performing this computation is </FONT>
    <DL>
      <DT><A name=9823></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><CODE>r00...00<BR>+ 
      aa...aabb...bb<BR>- </CODE><FONT 
      face="Verdana, Arial, Helvetica, sans-serif" 
      size=3>bb...bb<BR></FONT><CODE>aa...aA00...00</CODE></FONT> </DT></DL>
    <DT><A name=1340></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
    rule for computing <FONT face=Arial,Helvetica><EM>r</EM></FONT>, equation 
    (33), is the same as the rule for rounding <CODE>a...</CODE><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"> </FONT><CODE>ab...b</CODE> to 
    <EM>p</EM> - <FONT face=Arial,Helvetica><EM>k</EM></FONT> places. Thus 
    computing <FONT face=Arial,Helvetica><EM>mx</EM></FONT> - (<FONT 
    face=Arial,Helvetica><EM>mx</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT>) in floating-point arithmetic 
    precision is exactly equal to rounding <EM>x</EM> to <EM>p</EM> - <FONT 
    face=Arial,Helvetica><EM>k</EM></FONT> places, in the case when <EM>x</EM> + 
    <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>k</SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> does not carry out. </FONT>
    <DT><A name=1341></A><FONT face="Verdana, Arial, Helvetica, sans-serif">When 
    <EM>x</EM> + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> does carry out, then <FONT 
    face=Arial,Helvetica><EM>mx</EM></FONT> = <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> looks like this: </FONT>
    <DL>
      <DT><A name=9798></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><CODE>aa...aabb...bb<BR>+ 
      </CODE><FONT face="Verdana, Arial, Helvetica, sans-serif" 
      size=3>aa...aabb...bb<BR></FONT><CODE>zz...zZbb...bb</CODE></FONT> 
</DT></DL>
    <DT><A name=9799></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Thus, <FONT 
    face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> = <FONT 
    face=Arial,Helvetica><EM>mx</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> mod(<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>) 
    + <FONT face=Arial,Helvetica><EM>w</EM></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>, 
    where <FONT face=Arial,Helvetica><EM>w</EM></FONT> = -<FONT 
    face=Arial,Helvetica><EM>Z</EM></FONT> if <FONT 
    face=Arial,Helvetica><EM>Z</EM></FONT> &lt; <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT>/2, 
    but the exact value of <FONT face=Arial,Helvetica><EM>w</EM></FONT> is 
    unimportant. Next, <FONT face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> = <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> mod(<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>) 
    + <FONT face=Arial,Helvetica><EM>w</EM></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>. 
    In a picture </FONT>
    <DL>
      <DT><A name=1196></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><CODE>aa...aabb...bb00...00<BR>- 
      bb... bb<BR>+ </CODE><FONT face="Verdana, Arial, Helvetica, sans-serif" 
      size=3>w <BR></FONT><CODE>zz ... zZbb ...bb<A 
      href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1343"><SUP>31</SUP></A></CODE></FONT> 
      </DT></DL>
    <DT><A name=1344></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Rounding gives (<FONT 
    face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT>) <IMG height=15 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg19.gif" 
    width=13> <FONT face=Arial,Helvetica><EM>x</EM></FONT> = <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
    face=Arial,Helvetica><EM>w</EM></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP> 
    - <FONT face=Arial,Helvetica><EM>r</EM></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>, 
    where <FONT face=Arial,Helvetica><EM>r</EM></FONT> = 1 if 
    <CODE>.bb...b</CODE> &gt;&nbsp;<IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg257.gif" 
    width=8> or if <CODE>.bb...b</CODE> = <IMG height=22 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg262.gif" 
    width=8> and <FONT face=Arial,Helvetica><EM>b</EM></FONT><SUB>0</SUB> = 1.<A 
    href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1345"><SUP>32</SUP></A> 
    Finally, </FONT></DT></DL><A name=12144></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>(<FONT 
  face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT>) - (<FONT 
  face=Arial,Helvetica><EM>m</EM></FONT> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT> <IMG height=15 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg62.gif" 
  width=13> x) = <FONT face=Arial,Helvetica><EM>mx</EM></FONT>&nbsp;-&nbsp;<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>&nbsp;mod(<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>) 
  + <FONT face=Arial,Helvetica><EM>w</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP>k</SUP> 
  - (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>w</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP> 
  - <FONT face=Arial,Helvetica><EM>r</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>)<BR>= 
  <FONT face=Arial,Helvetica><EM>x</EM></FONT> - <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> mod(<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>) 
  + <FONT face=Arial,Helvetica><EM>r</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP>.<BR></FONT>
  <DL>
    <DT><A name=12146></A><FONT face="Verdana, Arial, Helvetica, sans-serif">And 
    once again, <FONT face=Arial,Helvetica><EM>r</EM></FONT> = 1 exactly when 
    rounding <CODE>a...ab...b</CODE> to <EM>p</EM> - <FONT 
    face=Arial,Helvetica><EM>k</EM></FONT> places involves rounding up. Thus 
    Theorem 14 is proven in all cases. <FONT 
    face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT> </FONT></DT></DL>
  <H4><A name=1346></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 8 (Kahan Summation Formula)</FONT> </H4>
  <DL>
    <DT><A name=1347></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Suppose that <IMG height=21 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg268.gif" 
    width=44> is computed using the following algorithm 
    <P>
    <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
    borderColorLight=#ffffff border=1>
      <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
      size=-1></FONT></B></CAPTION>
      <TBODY>
      <TR>
        <TD><A name=1348></A><PRE>S = X [1];
</PRE></TD></TR>
      <TR>
        <TD><A name=1349></A><PRE>C = 0;
</PRE></TD></TR>
      <TR>
        <TD><A name=1350></A><PRE>for j = 2 to N {
</PRE></TD></TR>
      <TR>
        <TD><A name=1351></A><PRE>Y = X [j] - C;
</PRE></TD></TR>
      <TR>
        <TD><A name=1352></A><PRE>   T = S + Y;
</PRE></TD></TR>
      <TR>
        <TD><A name=1353></A><PRE>   C = (T - S) - Y;
</PRE></TD></TR>
      <TR>
        <TD><A name=1354></A><PRE>   S = T;
</PRE></TD></TR>
      <TR>
        <TD><A name=1355></A><PRE>}
</PRE></TD></TR></TBODY></TABLE></P><BR></FONT>
    <DT><A name=1357></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>Then the computed sum 
    </EM><FONT face=Arial,Helvetica><EM>S</EM></FONT><EM> is equal to </EM><FONT 
    face=Arial,Helvetica><EM>S</EM></FONT><EM> = </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/capsigma.gif"> 
    </FONT><EM>x</EM><SUB>j</SUB><EM> (</EM>1<EM> + </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>j</EM></SUB><EM>) 
    + </EM><FONT face=Arial,Helvetica><EM>O</EM></FONT><EM>(</EM><FONT 
    face=Arial,Helvetica><EM>N</EM></FONT><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP><EM>2</EM></SUP><EM>) 
    </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/capsigma.gif"> 
    </FONT><EM>|</EM><FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>j</SUB><EM>|, where |</EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>j</EM></SUB><EM>| 
    </EM><FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT><EM> 
    </EM>2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><EM>.</EM> 
    </FONT></DT></DL>
  <H4><A name=1358></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H4>
  <DL>
    <DT><A name=1359></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">First recall how the error 
    estimate for the simple formula <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/capsigma.gif"></FONT> 
    <FONT face=Arial,Helvetica><EM>x</EM></FONT><SUB>i</SUB> went. Introduce 
    <FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB> = <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB>, <FONT 
    face=Arial,Helvetica><EM>s</EM></FONT><SUB>i</SUB> = (1 + <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>i</EM></SUB>) 
    (<FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>i - 1</SUB> + <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>i</SUB>). Then the computed sum 
    is <FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>n</SUB>, which is a sum 
    of terms, each of which is an <FONT 
    face=Arial,Helvetica><EM>x</EM></FONT><SUB>i</SUB> multiplied by an 
    expression involving <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>j</EM></SUB>'s. 
    The exact coefficient of <EM>x</EM><SUB>1</SUB> is (1 +<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>2</SUB>)(1 
    + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>)<FONT 
    face="Verdana, Arial, Helvetica, sans-serif"> ...</FONT> (1 + <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>n</EM></SUB>), 
    and so by renumbering, the coefficient of <EM>x</EM><SUB>2</SUB> must be 
    (1&nbsp;+&nbsp;<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>3</SUB>)(1 
    +<FONT face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>4</SUB>) 
    <FONT face="Verdana, Arial, Helvetica, sans-serif">...</FONT> (1 + <FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB>n</SUB>), 
    and so on. The proof of Theorem 8 runs along exactly the same lines, only 
    the coefficient of <EM>x</EM><SUB>1</SUB> is more complicated. In detail 
    <FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>0</SUB> = <FONT 
    face=Arial,Helvetica><EM>c</EM></FONT><SUB>0</SUB> = 0 and </FONT>
    <DL>
      <DT><A name=1360></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>y</EM></FONT><SUB>k </SUB><FONT 
      face=Arial,Helvetica><EM>= x</EM></FONT><SUB>k</SUB><FONT 
      face=Arial,Helvetica><EM> </EM></FONT><IMG height=15 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg33.gif" 
      width=13> <FONT face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 
      1</SUB><FONT face=Arial,Helvetica><EM> = </EM></FONT>(<FONT 
      face=Arial,Helvetica><EM>x</EM></FONT><SUB>k</SUB><FONT 
      face=Arial,Helvetica><EM> - c</EM></FONT><SUB>k - 1</SUB>) (1<FONT 
      face=Arial,Helvetica><EM> + </EM></FONT><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>)<FONT 
      face=Arial,Helvetica><EM> </EM></FONT></FONT>
      <DT><A name=9836></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>k </SUB><FONT 
      face=Arial,Helvetica><EM>= s</EM></FONT><SUB>k - 1</SUB><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circplus.gif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/approx.gif"></FONT><FONT 
      face=Arial,Helvetica><EM> y</EM></FONT><SUB>k </SUB><FONT 
      face=Arial,Helvetica><EM>= </EM></FONT>(<FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>k-1</SUB><FONT 
      face=Arial,Helvetica><EM> + y</EM></FONT><SUB>k</SUB>) (1<FONT 
      face=Arial,Helvetica><EM> + </EM></FONT><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      </FONT>
      <DT><A name=9837></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k </SUB><FONT 
      face=Arial,Helvetica><EM>= </EM></FONT>(<FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>k</SUB><FONT 
      face=Arial,Helvetica><EM> </EM></FONT><IMG height=15 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg43.gif" 
      width=13> <FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 
      1</SUB>)<FONT face=Arial,Helvetica><EM> </EM></FONT><IMG height=15 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg53.gif" 
      width=13> <FONT face=Arial,Helvetica><EM>y</EM></FONT><SUB>k</SUB><FONT 
      face=Arial,Helvetica><EM>=</EM></FONT> [(<FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>k</SUB><FONT 
      face=Arial,Helvetica><EM> - s</EM></FONT><SUB>k - 1</SUB>) (1<FONT 
      face=Arial,Helvetica><EM> + </EM></FONT><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      -<FONT face=Arial,Helvetica><EM> y</EM></FONT><SUB>k</SUB>] (1<FONT 
      face=Arial,Helvetica><EM> + </EM></FONT><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB>)</FONT> 
      </DT></DL>
    <DT><A name=1361></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">where all the Greek letters are 
    bounded by <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
    Although the coefficient of <EM>x</EM><SUB>1</SUB> in <FONT 
    face=Arial,Helvetica><EM>s</EM></FONT><SUB>k</SUB> is the ultimate 
    expression of interest, in turns out to be easier to compute the coefficient 
    of <EM>x</EM><SUB>1</SUB> in <FONT 
    face=Arial,Helvetica><EM>s</EM></FONT><SUB>k</SUB> - <FONT 
    face=Arial,Helvetica><EM>c</EM></FONT><SUB>k</SUB> and <FONT 
    face=Arial,Helvetica><EM>c</EM></FONT><SUB>k</SUB>.</FONT> 
    <DT><A name=12151></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">When <FONT 
    face=Arial,Helvetica><EM>k</EM></FONT> = 1, </FONT>
    <DL>
      <DT><A name=1176></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>1</SUB> = (<FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB>(1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB>1</SUB>) 
      - <FONT face=Arial,Helvetica><EM>y</EM></FONT><SUB>1</SUB>) (1 + <FONT 
      face=Arial,Helvetica><EM>d</EM></FONT><SUB>1</SUB>)</FONT> 
      <DT><A name=9839></A><FONT face="Verdana, Arial, Helvetica, sans-serif">= 
      <FONT face=Arial,Helvetica><EM>y</EM></FONT><SUB>1</SUB>((1 + <FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB>) (1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB>1</SUB>) 
      - 1) (1 + <FONT face=Arial,Helvetica><EM>d</EM></FONT><SUB>1</SUB>) 
</FONT>
      <DT><A name=9841></A><FONT face="Verdana, Arial, Helvetica, sans-serif">= 
      <FONT face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB>(<FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB> +<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB>1</SUB> 
      + <FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB><FONT 
      face=Arial,Helvetica><EM>g</EM></FONT><SUB>1</SUB>) (1 + <FONT 
      face=Arial,Helvetica><EM>d</EM></FONT><SUB>1</SUB>) (1 + <FONT 
      face=Arial,Helvetica><EM>h</EM></FONT><SUB>1</SUB>) </FONT>
      <DT><A name=9843></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB> - <FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>1</SUB> = <FONT 
      face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB>[(1 + <FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB>) - (<FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB> + <FONT 
      face=Arial,Helvetica><EM>g</EM></FONT><SUB>1</SUB> + <FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB><FONT 
      face=Arial,Helvetica><EM>g</EM></FONT><SUB>1</SUB>) (1 + <FONT 
      face=Arial,Helvetica><EM>d</EM></FONT><SUB>1</SUB>)](1 + <FONT 
      face=Arial,Helvetica><EM>h</EM></FONT><SUB>1</SUB>) </FONT>
      <DT><A name=9844></A><FONT face="Verdana, Arial, Helvetica, sans-serif">= 
      <FONT face=Arial,Helvetica><EM>x</EM></FONT><SUB>1</SUB>[1 - <FONT 
      face=Arial,Helvetica><EM>g</EM></FONT><SUB>1</SUB> - <FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB><FONT 
      face=Arial,Helvetica><EM>d</EM></FONT><SUB>1</SUB> - <FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB><FONT 
      face=Arial,Helvetica><EM>g</EM></FONT><SUB>1</SUB> - <FONT 
      face=Arial,Helvetica><EM>d</EM></FONT><SUB>1</SUB><FONT 
      face=Arial,Helvetica><EM>g</EM></FONT><SUB>1</SUB> - <FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>1</SUB><FONT 
      face=Arial,Helvetica><EM>g</EM></FONT><SUB>1</SUB><FONT 
      face=Arial,Helvetica><EM>d</EM></FONT><SUB>1</SUB>](1 + <FONT 
      face=Arial,Helvetica><EM>h</EM></FONT><SUB>1</SUB>)</FONT> </DT></DL>
    <DT><A name=1363></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Calling the coefficients of 
    <EM>x</EM><SUB>1</SUB> in these expressions <EM>C</EM><SUB>k</SUB> and <FONT 
    face=Arial,Helvetica><EM>S</EM></FONT><SUB>k</SUB> respectively, then</FONT> 
    </DT></DL><A name=1364></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2><FONT face=Arial,Helvetica><EM>C</EM></FONT><SUB>1 </SUB>= 2<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  + O(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP>) 
  <BR></FONT><A name=9846></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2><FONT face=Arial,Helvetica><EM>S</EM></FONT><SUB>1 </SUB>= + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>1</SUB> 
  - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB>1</SUB> 
  + 4<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP> 
  + O(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>3</SUP>) 
  <BR></FONT>
  <DL>
    <DT><A name=12242></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To 
    get the general formula for <FONT 
    face=Arial,Helvetica><EM>S</EM></FONT><SUB>k</SUB> and 
    <EM>C</EM><SUB>k</SUB>, expand the definitions of <FONT 
    face=Arial,Helvetica><EM>s</EM></FONT><SUB>k</SUB> and <FONT 
    face=Arial,Helvetica><EM>c</EM></FONT><SUB>k</SUB>, ignoring all terms 
    involving <EM>x</EM><SUB>i</SUB> with <FONT 
    face=Arial,Helvetica><EM>i</EM></FONT> &gt; 1 to get </FONT>
    <DL>
      <DT><A name=12243></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>k </SUB>= (<FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 1</SUB> + <FONT 
      face=Arial,Helvetica><EM>y</EM></FONT><SUB>k</SUB>)(1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      </FONT>
      <DT><A name=12244></A><FONT face="Verdana, Arial, Helvetica, sans-serif">= 
      [<FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 1</SUB> + (<FONT 
      face=Arial,Helvetica><EM>x</EM></FONT><SUB>k</SUB> - <FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>) (1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>)](1 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      </FONT>
      <DT><A name=5718></A><FONT face="Verdana, Arial, Helvetica, sans-serif">= 
      [(<FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 1</SUB> - <FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>) - <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB><FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>](1+<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      </FONT>
      <DT><A name=5719></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k </SUB>= [{<FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>k</SUB> - <FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 1</SUB>}(1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      - <FONT face=Arial,Helvetica><EM>y</EM></FONT><SUB>k</SUB>](1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB>) 
      </FONT>
      <DT><A name=5720></A><FONT face="Verdana, Arial, Helvetica, sans-serif">= 
      [{((<FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 1</SUB> - <FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>) - <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB><FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>)(1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      - <FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 1</SUB>}(1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      + <FONT face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>(1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>)](1&nbsp;+&nbsp;<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB>) 
      </FONT>
      <DT><A name=5721></A><FONT face="Verdana, Arial, Helvetica, sans-serif">= 
      [{(<FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 1</SUB> - <FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>)<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB> 
      - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>c<SUB><EM>k</EM></SUB><SUB>-1</SUB>(1 
      +<FONT face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      - <FONT face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>}(1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      + c<SUB><EM>k</EM></SUB><SUB> - 1</SUB>(1 +<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"> <IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>)](1 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB>) 
      </FONT>
      <DT><A name=9847></A><FONT face="Verdana, Arial, Helvetica, sans-serif">= 
      [(<FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 1</SUB> - <FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>)<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>(1 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      - <FONT face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>(<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>(<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>))](1 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB>),</FONT> 

      <DT><A name=9848></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><EM>s</EM><SUB>k</SUB> - 
      <EM>c</EM><SUB>k </SUB>= ((<FONT 
      face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 1</SUB> - <FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>) - <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB><FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>) (1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      </FONT>
      <DT><A name=9849></A><FONT face="Verdana, Arial, Helvetica, sans-serif">- 
      [(<FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>k - 1</SUB> - <FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>)<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>(1 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      - <FONT face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>(<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>(<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>)](1 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB>) 
      </FONT>
      <DT><A name=5725></A><FONT face="Verdana, Arial, Helvetica, sans-serif">= 
      (<FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>k- 1</SUB> - <FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>)((1 + <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>(1 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>)(1 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB>)) 
      </FONT>
      <DT><A name=5726></A><FONT face="Verdana, Arial, Helvetica, sans-serif">+ 
      <FONT face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>(-<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>(1 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      + (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>(<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>)) 
      (1 + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB>)) 
      </FONT>
      <DT><A name=5727></A><FONT face="Verdana, Arial, Helvetica, sans-serif">= 
      (<FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>- 1</SUB> - <FONT 
      face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB>) (1 - <FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB>(<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB>)) 
      </FONT>
      <DT><A name=5728></A><FONT face="Verdana, Arial, Helvetica, sans-serif">+ 
      <FONT face=Arial,Helvetica><EM>c</EM></FONT><SUB>k - 1</SUB> -<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"> [<IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>(<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>) 
      + (<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB><EM>k</EM></SUB>(<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB>))<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>k</EM></SUB>]</FONT> 
      </DT></DL>
    <DT><A name=1375></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Since <FONT 
    face=Arial,Helvetica><EM>S</EM></FONT><SUB>k</SUB> and <FONT 
    face=Arial,Helvetica><EM>C</EM></FONT><SUB>k</SUB> are only being computed 
    up to order <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP>, 
    these formulas can be simplified to </FONT>
    <DL>
      <DT><A name=1376></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>C</EM></FONT><SUB>k</SUB>= (<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + O(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP>))<FONT 
      face=Arial,Helvetica><EM>S</EM></FONT><SUB>k - 1</SUB> + (-<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB><EM>k</EM></SUB> 
      + O(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP>))<FONT 
      face=Arial,Helvetica><EM>C</EM></FONT><SUB>k - 1</SUB> </FONT>
      <DT><A name=1384></A><FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><FONT 
      face=Arial,Helvetica><EM>S</EM></FONT><SUB>k</SUB>= ((1 + 2<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP> 
      + O(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>3</SUP>))<FONT 
      face=Arial,Helvetica><EM>S</EM></FONT><SUB>k - 1</SUB> + (2<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
      + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/capomicr.gif"></FONT>(<FONT 
      face="Verdana, Arial, Helvetica, sans-serif"><IMG 
      src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP>))<FONT 
      face=Arial,Helvetica><EM>C</EM></FONT><SUB>k - 1</SUB> </FONT></DT></DL>
    <DT><A name=1387></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Using these formulas gives 
    </FONT></DT></DL><A name=1389></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2><FONT 
  face=Arial,Helvetica><EM>C</EM></FONT><SUB>2</SUB> = <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB>2</SUB> 
  + O(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP>) 
  <BR></FONT><A name=1398></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2><FONT face=Arial,Helvetica><EM>S</EM></FONT><SUB>2 </SUB>= 1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>1</SUB> 
  - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB>1</SUB> 
  + 10<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP> 
  + O(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>3</SUP>) 
  <BR></FONT>
  <DL>
    <DT><A name=1399></A><FONT face="Verdana, Arial, Helvetica, sans-serif">and 
    in general it is easy to check by induction that </FONT></DT></DL><A 
  name=1400></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=2><FONT 
  face=Arial,Helvetica><EM>C</EM></FONT><SUB>k </SUB>= <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/sigma.gif"></FONT><SUB><EM>k</EM></SUB> 
  + O(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP>) 
  <BR></FONT><A name=1401></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2><FONT face=Arial,Helvetica><EM>S</EM></FONT><SUB>k </SUB>= 1 + <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>1</SUB> 
  - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB>1</SUB> 
  + (4<SUB><EM>k</EM></SUB>+2)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP> 
  + O(<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>3</SUP>) 
  <BR></FONT>
  <P><A name=1210></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Finally, what is wanted is the 
  coefficient of <EM>x</EM><SUB>1</SUB> in <FONT 
  face=Arial,Helvetica><EM>s</EM></FONT><SUB>k</SUB>. To get this value, let 
  <EM>x</EM><SUB>n&nbsp;+&nbsp;1</SUB> = 0, let all the Greek letters with 
  subscripts of <FONT face=Arial,Helvetica><EM>n</EM></FONT> + 1 equal 0, and 
  compute <FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>n + 1</SUB>. Then 
  <FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>n + 1</SUB> =<FONT 
  face=Arial,Helvetica><EM> s</EM></FONT><SUB>n</SUB> - <FONT 
  face=Arial,Helvetica><EM>c</EM></FONT><SUB>n</SUB>, and the coefficient of 
  <EM>x</EM><SUB>1</SUB> in <FONT 
  face=Arial,Helvetica><EM>s</EM></FONT><SUB>n</SUB> is less than the 
  coefficient in <FONT face=Arial,Helvetica><EM>s</EM></FONT><SUB>n + 1</SUB>, 
  which is <FONT 
  face=Arial,Helvetica><EM>S</EM></FONT><SUB>n</SUB>&nbsp;=&nbsp;1&nbsp;+ <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/eta.gif"></FONT><SUB>1</SUB> 
  - <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gamma.gif"></FONT><SUB>1</SUB> 
  + (4<FONT face=Arial,Helvetica><EM>n</EM></FONT> + 2)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP> 
  = (1 + 2<FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT> 
  + <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/capomicr.gif"></FONT>(<FONT 
  face=Arial,Helvetica><EM>n</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT><SUP>2</SUP>)). 
  <FONT face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT></FONT> </P>
  <H2><A name=3098></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Differences Among IEEE 754 Implementations</FONT> </H2>
  <P>
  <HR noShade SIZE=1>
  <A name=3099></A><FONT face="Verdana, Arial, Helvetica, sans-serif"><B>Note – 
  </B>This section is not part of the published paper. It has been added to 
  clarify certain points and correct possible misconceptions about the IEEE 
  standard that the reader might infer from the paper. This material was not 
  written by David Goldberg, but it appears here with his permission.</FONT> 
  <HR noShade SIZE=1>

  <P></P>
  <P><A name=3093></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  preceding paper has shown that floating-point arithmetic must be implemented 
  carefully, since programmers may depend on its properties for the correctness 
  and accuracy of their programs. In particular, the IEEE standard requires a 
  careful implementation, and it is possible to write useful programs that work 
  correctly and deliver accurate results only on systems that conform to the 
  standard. The reader might be tempted to conclude that such programs should be 
  portable to all IEEE systems. Indeed, portable software would be easier to 
  write if the remark "When a program is moved between two machines and both 
  support IEEE arithmetic, then if any intermediate result differs, it must be 
  because of software bugs, not from differences in arithmetic," were 
  true.</FONT> </P>
  <P><A name=3105></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Unfortunately, the IEEE standard 
  does not guarantee that the same program will deliver identical results on all 
  conforming systems. Most programs will actually produce different results on 
  different systems for a variety of reasons. For one, most programs involve the 
  conversion of numbers between decimal and binary formats, and the IEEE 
  standard does not completely specify the accuracy with which such conversions 
  must be performed. For another, many programs use elementary functions 
  supplied by a system library, and the standard doesn't specify these functions 
  at all. Of course, most programmers know that these features lie beyond the 
  scope of the IEEE standard.</FONT> </P>
  <P><A name=3663></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Many 
  programmers may not realize that even a program that uses only the numeric 
  formats and operations prescribed by the IEEE standard can compute different 
  results on different systems. In fact, the authors of the standard intended to 
  allow different implementations to obtain different results. Their intent is 
  evident in the definition of the term <EM>destination</EM> in the IEEE 754 
  standard: "A destination may be either explicitly designated by the user or 
  implicitly supplied by the system (for example, intermediate results in 
  subexpressions or arguments for procedures). Some languages place the results 
  of intermediate calculations in destinations beyond the user's control. 
  Nonetheless, this standard defines the result of an operation in terms of that 
  destination's format and the operands' values." (IEEE 754-1985, p. 7) In other 
  words, the IEEE standard requires that each result be rounded correctly to the 
  precision of the destination into which it will be placed, but the standard 
  does not require that the precision of that destination be determined by a 
  user's program. Thus, different systems may deliver their results to 
  destinations with different precisions, causing the same program to produce 
  different results (sometimes dramatically so), even though those systems all 
  conform to the standard.</FONT> </P>
  <P><A name=3756></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Several 
  of the examples in the preceding paper depend on some knowledge of the way 
  floating-point arithmetic is rounded. In order to rely on examples such as 
  these, a programmer must be able to predict how a program will be interpreted, 
  and in particular, on an IEEE system, what the precision of the destination of 
  each arithmetic operation may be. Alas, the loophole in the IEEE standard's 
  definition of <EM>destination</EM> undermines the programmer's ability to know 
  how a program will be interpreted. Consequently, several of the examples given 
  above, when implemented as apparently portable programs in a high-level 
  language, may not work correctly on IEEE systems that normally deliver results 
  to destinations with a different precision than the programmer expects. Other 
  examples may work, but proving that they work may lie beyond the average 
  programmer's ability.</FONT> </P>
  <P><A name=3766></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In this 
  section, we classify existing implementations of IEEE 754 arithmetic based on 
  the precisions of the destination formats they normally use. We then review 
  some examples from the paper to show that delivering results in a wider 
  precision than a program expects can cause it to compute wrong results even 
  though it is provably correct when the expected precision is used. We also 
  revisit one of the proofs in the paper to illustrate the intellectual effort 
  required to cope with unexpected precision even when it doesn't invalidate our 
  programs. These examples show that despite all that the IEEE standard 
  prescribes, the differences it allows among different implementations can 
  prevent us from writing portable, efficient numerical software whose behavior 
  we can accurately predict. To develop such software, then, we must first 
  create programming languages and environments that limit the variability the 
  IEEE standard permits and allow programmers to express the floating-point 
  semantics upon which their programs depend.</FONT> </P>
  <H3><A name=3164></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Current IEEE 754 Implementations</FONT> </H3>
  <P><A name=3154></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Current 
  implementations of IEEE 754 arithmetic can be divided into two groups 
  distinguished by the degree to which they support different floating-point 
  formats in hardware. <EM>Extended-based</EM> systems, exemplified by the Intel 
  x86 family of processors, provide full support for an extended double 
  precision format but only partial support for single and double precision: 
  they provide instructions to load or store data in single and double 
  precision, converting it on-the-fly to or from the extended double format, and 
  they provide special modes (not the default) in which the results of 
  arithmetic operations are rounded to single or double precision even though 
  they are kept in registers in extended double format. (Motorola 68000 series 
  processors round results to both the precision and range of the single or 
  double formats in these modes. Intel x86 and compatible processors round 
  results to the precision of the single or double formats but retain the same 
  range as the extended double format.) <EM>Single/double</EM> systems, 
  including most RISC processors, provide full support for single and double 
  precision formats but no support for an IEEE-compliant extended double 
  precision format. (The IBM POWER architecture provides only partial support 
  for single precision, but for the purpose of this section, we classify it as a 
  single/double system.)</FONT> </P>
  <P><A name=3172></A><FONT face="Verdana, Arial, Helvetica, sans-serif">To see 
  how a computation might behave differently on an extended-based system than on 
  a single/double system, consider a C version of the example from the section 
  <A href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1015">Systems 
  Aspects</A>: 
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B><FONT face="Verdana, Arial, Helvetica, sans-serif" 
    size=-1></FONT></B></CAPTION>
    <TBODY>
    <TR>
      <TD><A name=3169></A><PRE>int main() {
</PRE><A name=3183></A><PRE>    double  q;
</PRE><A name=3184></A><PRE></PRE><A name=3185></A><PRE>    q = 3.0/7.0;
</PRE><A name=3170></A><PRE>    if (q == 3.0/7.0) printf("Equal\n");
</PRE><A name=3171></A><PRE>    else printf("Not Equal\n");
</PRE><A name=3186></A><PRE>    return 0;
</PRE><A name=3187></A><PRE>}
</PRE></TD></TR></TBODY></TABLE></P><BR></FONT>
  <P></P>
  <P><A name=3165></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Here 
  the constants 3.0 and 7.0 are interpreted as double precision floating-point 
  numbers, and the expression 3.0/7.0 inherits the <CODE>double</CODE> data 
  type. On a single/double system, the expression will be evaluated in double 
  precision since that is the most efficient format to use. Thus, <CODE>q</CODE> 
  will be assigned the value 3.0/7.0 rounded correctly to double precision. In 
  the next line, the expression 3.0/7.0 will again be evaluated in double 
  precision, and of course the result will be equal to the value just assigned 
  to <CODE>q</CODE>, so the program will print "Equal" as expected.</FONT> </P>
  <P><A name=3191></A><FONT face="Verdana, Arial, Helvetica, sans-serif">On an 
  extended-based system, even though the expression 3.0/7.0 has type 
  <CODE>double</CODE>, the quotient will be computed in a register in extended 
  double format, and thus in the default mode, it will be rounded to extended 
  double precision. When the resulting value is assigned to the variable 
  <CODE>q</CODE>, however, it may then be stored in memory, and since 
  <CODE>q</CODE> is declared <CODE>double</CODE>, the value will be rounded to 
  double precision. In the next line, the expression 3.0/7.0 may again be 
  evaluated in extended precision yielding a result that differs from the double 
  precision value stored in <CODE>q</CODE>, causing the program to print "Not 
  equal". Of course, other outcomes are possible, too: the compiler could decide 
  to store and thus round the value of the expression 3.0/7.0 in the second line 
  before comparing it with <CODE>q</CODE>, or it could keep <CODE>q</CODE> in a 
  register in extended precision without storing it. An optimizing compiler 
  might evaluate the expression 3.0/7.0 at compile time, perhaps in double 
  precision or perhaps in extended double precision. (With one x86 compiler, the 
  program prints "Equal" when compiled with optimization and "Not Equal" when 
  compiled for debugging.) Finally, some compilers for extended-based systems 
  automatically change the rounding precision mode to cause operations producing 
  results in registers to round those results to single or double precision, 
  albeit possibly with a wider range. Thus, on these systems, we can't predict 
  the behavior of the program simply by reading its source code and applying a 
  basic understanding of IEEE 754 arithmetic. Neither can we accuse the hardware 
  or the compiler of failing to provide an IEEE 754 compliant environment; the 
  hardware has delivered a correctly rounded result to each destination, as it 
  is required to do, and the compiler has assigned some intermediate results to 
  destinations that are beyond the user's control, as it is allowed to 
  do.</FONT> </P>
  <H3><A name=3377></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Pitfalls in Computations on Extended-Based Systems</FONT> </H3>
  <P><A name=3201></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Conventional wisdom maintains 
  that extended-based systems must produce results that are at least as 
  accurate, if not more accurate than those delivered on single/double systems, 
  since the former always provide at least as much precision and often more than 
  the latter. Trivial examples such as the C program above as well as more 
  subtle programs based on the examples discussed below show that this wisdom is 
  naive at best: some apparently portable programs, which are indeed portable 
  across single/double systems, deliver incorrect results on extended-based 
  systems precisely because the compiler and hardware conspire to occasionally 
  provide more precision than the program expects.</FONT> </P>
  <P><A name=3212></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Current 
  programming languages make it difficult for a program to specify the precision 
  it expects. As the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1043">Languages 
  and Compilers</A> mentions, many programming languages don't specify that each 
  occurrence of an expression like <CODE>10.0*x</CODE> in the same context 
  should evaluate to the same value. Some languages, such as Ada, were 
  influenced in this respect by variations among different arithmetics prior to 
  the IEEE standard. More recently, languages like ANSI C have been influenced 
  by standard-conforming extended-based systems. In fact, the ANSI C standard 
  explicitly allows a compiler to evaluate a floating-point expression to a 
  precision wider than that normally associated with its type. As a result, the 
  value of the expression <CODE>10.0*x</CODE> may vary in ways that depend on a 
  variety of factors: whether the expression is immediately assigned to a 
  variable or appears as a subexpression in a larger expression; whether the 
  expression participates in a comparison; whether the expression is passed as 
  an argument to a function, and if so, whether the argument is passed by value 
  or by reference; the current precision mode; the level of optimization at 
  which the program was compiled; the precision mode and expression evaluation 
  method used by the compiler when the program was compiled; and so on.</FONT> 
  </P>
  <P><A name=3258></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Language standards are not 
  entirely to blame for the vagaries of expression evaluation. Extended-based 
  systems run most efficiently when expressions are evaluated in extended 
  precision registers whenever possible, yet values that must be stored are 
  stored in the narrowest precision required. Constraining a language to require 
  that <CODE>10.0*x</CODE> evaluate to the same value everywhere would impose a 
  performance penalty on those systems. Unfortunately, allowing those systems to 
  evaluate <CODE>10.0*x</CODE> differently in syntactically equivalent contexts 
  imposes a penalty of its own on programmers of accurate numerical software by 
  preventing them from relying on the syntax of their programs to express their 
  intended semantics.</FONT> </P>
  <P><A name=3784></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Do real 
  programs depend on the assumption that a given expression always evaluates to 
  the same value? Recall the algorithm presented in Theorem 4 for computing ln(1 
  +<EM> x</EM>), written here in Fortran: 
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B></B></CAPTION>
    <TBODY>
    <TR>
      <TD><FONT face=Courier><A name=3261></A><PRE>real function log1p(x)
</PRE><A name=3262></A><PRE>real x
</PRE><A name=3263></A><PRE>if (1.0 + x .eq. 1.0) then
</PRE><A name=3264></A><PRE>   log1p = x
</PRE><A name=3265></A><PRE>else
</PRE><A name=3266></A><PRE>   log1p = log(1.0 + x) * x / ((1.0 + x) - 1.0)
</PRE><A name=3267></A><PRE>endif
</PRE><A name=3268></A><PRE>return
</PRE></FONT></TD></TR></TBODY></TABLE></P></FONT>
  <P></P>
  <P><A name=3215></A><FONT face="Verdana, Arial, Helvetica, sans-serif">On an 
  extended-based system, a compiler may evaluate the expression 
  <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> in the third line in 
  extended precision and compare the result with <CODE>1.0</CODE>. When the same 
  expression is passed to the log function in the sixth line, however, the 
  compiler may store its value in memory, rounding it to single precision. Thus, 
  if <CODE>x</CODE> is not so small that 
  <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> rounds to 
  <CODE>1.0</CODE> in extended precision but small enough that 
  <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> rounds to 
  <CODE>1.0</CODE> in single precision, then the value returned by 
  <CODE>log1p(x)</CODE> will be zero instead of <CODE>x</CODE>, and the relative 
  error will be one--rather larger than 5<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/epsilon.gif"></FONT>. 
  Similarly, suppose the rest of the expression in the sixth line, including the 
  reoccurrence of the subexpression 
  <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE>, is evaluated in 
  extended precision. In that case, if <CODE>x</CODE> is small but not quite 
  small enough that <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> 
  rounds to <CODE>1.0</CODE> in single precision, then the value returned by 
  <CODE>log1p(x)</CODE> can exceed the correct value by nearly as much as 
  <CODE>x</CODE>, and again the relative error can approach one. For a concrete 
  example, take <CODE>x</CODE> to be 2<SUP>-24</SUP> + 2<SUP>-47</SUP>, so 
  <CODE>x</CODE> is the smallest single precision number such that 
  <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> rounds up to the next 
  larger number, 1 + 2<SUP>-23</SUP>. Then 
  <CODE>log(1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x)</CODE> is approximately 
  2<SUP>-23</SUP>. Because the denominator in the expression in the sixth line 
  is evaluated in extended precision, it is computed exactly and delivers 
  <CODE>x</CODE>, so <CODE>log1p(x)</CODE> returns approximately 
  2<SUP>-23</SUP>, which is nearly twice as large as the exact value. (This 
  actually happens with at least one compiler. When the preceding code is 
  compiled by the Sun WorkShop Compilers 4.2.1 Fortran 77 compiler for x86 
  systems using the <CODE>-O</CODE> optimization flag, the generated code 
  computes <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> exactly as 
  described. As a result, the function delivers zero for 
  <CODE>log1p(1.0e-10)</CODE> and <CODE>1.19209E-07</CODE> for 
  <CODE>log1p(5.97e-8)</CODE>.)</FONT> </P>
  <P><A name=3858></A><FONT face="Verdana, Arial, Helvetica, sans-serif">For the 
  algorithm of Theorem 4 to work correctly, the expression 
  <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> must be evaluated the 
  same way each time it appears; the algorithm can fail on extended-based 
  systems only when <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> is 
  evaluated to extended double precision in one instance and to single or double 
  precision in another. Of course, since <CODE>log</CODE> is a generic intrinsic 
  function in Fortran, a compiler could evaluate the expression 
  <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> in extended precision 
  throughout, computing its logarithm in the same precision, but evidently we 
  cannot assume that the compiler will do so. (One can also imagine a similar 
  example involving a user-defined function. In that case, a compiler could 
  still keep the argument in extended precision even though the function returns 
  a single precision result, but few if any existing Fortran compilers do this, 
  either.) We might therefore attempt to ensure that 
  <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> is evaluated 
  consistently by assigning it to a variable. Unfortunately, if we declare that 
  variable <CODE>real</CODE>, we may still be foiled by a compiler that 
  substitutes a value kept in a register in extended precision for one 
  appearance of the variable and a value stored in memory in single precision 
  for another. Instead, we would need to declare the variable with a type that 
  corresponds to the extended precision format. Standard FORTRAN 77 does not 
  provide a way to do this, and while Fortran 95 offers the 
  <CODE>SELECTED_REAL_KIND</CODE> mechanism for describing various formats, it 
  does not explicitly require implementations that evaluate expressions in 
  extended precision to allow variables to be declared with that precision. In 
  short, there is no portable way to write this program in standard Fortran that 
  is guaranteed to prevent the expression 
  <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> from being evaluated 
  in a way that invalidates our proof.</FONT> </P>
  <P><A name=3340></A><FONT face="Verdana, Arial, Helvetica, sans-serif">There 
  are other examples that can malfunction on extended-based systems even when 
  each subexpression is stored and thus rounded to the same precision. The cause 
  is <EM>double-rounding</EM>. In the default precision mode, an extended-based 
  system will initially round each result to extended double precision. If that 
  result is then stored to double precision, it is rounded again. The 
  combination of these two roundings can yield a value that is different than 
  what would have been obtained by rounding the first result correctly to double 
  precision. This can happen when the result as rounded to extended double 
  precision is a "halfway case", i.e., it lies exactly halfway between two 
  double precision numbers, so the second rounding is determined by the 
  round-ties-to-even rule. If this second rounding rounds in the same direction 
  as the first, the net rounding error will exceed half a unit in the last 
  place. (Note, though, that double-rounding only affects double precision 
  computations. One can prove that the sum, difference, product, or quotient of 
  two <EM>p</EM>-bit numbers, or the square root of a <EM>p</EM>-bit number, 
  rounded first to <EM>q</EM> bits and then to <EM>p</EM> bits gives the same 
  value as if the result were rounded just once to <EM>p</EM> bits provided 
  <EM>q</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
  2<EM>p</EM> + 2. Thus, extended double precision is wide enough that single 
  precision computations don't suffer double-rounding.)</FONT> </P>
  <P><A name=3317></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Some 
  algorithms that depend on correct rounding can fail with double-rounding. In 
  fact, even some algorithms that don't require correct rounding and work 
  correctly on a variety of machines that don't conform to IEEE 754 can fail 
  with double-rounding. The most useful of these are the portable algorithms for 
  performing simulated multiple precision arithmetic mentioned in the section <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#704">Exactly 
  Rounded Operations</A>. For example, the procedure described in Theorem 6 for 
  splitting a floating-point number into high and low parts doesn't work 
  correctly in double-rounding arithmetic: try to split the double precision 
  number 2<SUP>52</SUP> + 3&nbsp;<FONT 
  face="Verdana, Arial, Helvetica, sans-serif">×</FONT>&nbsp;2<SUP>26</SUP> - 1 
  into two parts each with at most 26 bits. When each operation is rounded 
  correctly to double precision, the high order part is 
  2<SUP>52</SUP>&nbsp;+&nbsp;2<SUP>27</SUP> and the low order part is 
  2<SUP>26</SUP> - 1, but when each operation is rounded first to extended 
  double precision and then to double precision, the procedure produces a high 
  order part of 2<SUP>52</SUP> + 2<SUP>28</SUP> and a low order part of 
  -2<SUP>26</SUP> - 1. The latter number occupies 27 bits, so its square can't 
  be computed exactly in double precision. Of course, it would still be possible 
  to compute the square of this number in extended double precision, but the 
  resulting algorithm would no longer be portable to single/double systems. 
  Also, later steps in the multiple precision multiplication algorithm assume 
  that all partial products have been computed in double precision. Handling a 
  mixture of double and extended double variables correctly would make the 
  implementation significantly more expensive.</FONT> </P>
  <P><A name=3214></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Likewise, portable algorithms for 
  adding multiple precision numbers represented as arrays of double precision 
  numbers can fail in double-rounding arithmetic. These algorithms typically 
  rely on a technique similar to Kahan's summation formula. As the informal 
  explanation of the summation formula given on <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1262">Errors In 
  Summation</A> suggests, if <CODE>s</CODE> and <CODE>y</CODE> are 
  floating-point variables with |<CODE>s</CODE>| <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/gtequal.gif"></FONT> 
  |<CODE>y</CODE>| and we compute: 
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B></B></CAPTION>
    <TBODY>
    <TR>
      <TD><FONT face=Courier><A name=3506></A><PRE>t = s + y;
</PRE><A name=3507></A><PRE>e = (s - t) + y;
</PRE></FONT></TD></TR></TBODY></TABLE></P></FONT>
  <P></P>
  <P><A name=3508></A><FONT face="Verdana, Arial, Helvetica, sans-serif">then in 
  most arithmetics, <CODE>e</CODE> recovers exactly the roundoff error that 
  occurred in computing <CODE>t</CODE>. This technique doesn't work in 
  double-rounded arithmetic, however: if <CODE>s</CODE> = 2<SUP>52</SUP> + 1 and 
  <CODE>y</CODE> = 1/2 - 2<SUP>-54</SUP>, then 
  <CODE>s</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>y</CODE> rounds first to 
  2<SUP>52</SUP> + 3/2 in extended double precision, and this value rounds to 
  2<SUP>52</SUP> + 2 in double precision by the round-ties-to-even rule; thus 
  the net rounding error in computing <CODE>t</CODE> is 1/2 + 2<SUP>-54</SUP>, 
  which is not representable exactly in double precision and so can't be 
  computed exactly by the expression shown above. Here again, it would be 
  possible to recover the roundoff error by computing the sum in extended double 
  precision, but then a program would have to do extra work to reduce the final 
  outputs back to double precision, and double-rounding could afflict this 
  process, too. For this reason, although portable programs for simulating 
  multiple precision arithmetic by these methods work correctly and efficiently 
  on a wide variety of machines, they do not work as advertised on 
  extended-based systems.</FONT> </P>
  <P><A name=3216></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Finally, some algorithms that at 
  first sight appear to depend on correct rounding may in fact work correctly 
  with double-rounding. In these cases, the cost of coping with double-rounding 
  lies not in the implementation but in the verification that the algorithm 
  works as advertised. To illustrate, we prove the following variant of Theorem 
  7:</FONT> </P>
  <H4><A name=3382></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Theorem 7'</FONT> </H4>
  <DL>
    <DT><A name=3383></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><EM>If </EM><FONT 
    face=Arial,Helvetica><EM>m</EM></FONT><EM> and </EM><FONT 
    face=Arial,Helvetica><EM>n</EM></FONT><EM> are integers representable in 
    IEEE 754 double precision with |m| &lt; </EM>2<SUP>52</SUP><EM> and 
    </EM><FONT face=Arial,Helvetica><EM>n</EM></FONT><EM> has the special form n 
    = </EM>2<SUP><EM>i</EM></SUP><EM> + </EM>2<SUP><EM>j</EM></SUP><EM>, then (m 
    </EM><IMG height=12 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg72.gif" 
    width=11> <EM>n) </EM><FONT 
    face="Verdana, Arial, Helvetica, sans-serif"><IMG 
    src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT><EM> 
    n = m, provided both floating-point operations are either rounded correctly 
    to double precision or rounded first to extended double precision and then 
    to double precision.</EM> </FONT></DT></DL>
  <H4><A name=3389></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Proof</FONT> </H4>
  <P><A name=3380></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Assume 
  without loss that <EM>m</EM> &gt; 0. Let <EM>q</EM> = <EM>m </EM><IMG 
  height=12 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg63.gif" 
  width=11> <EM>n</EM>. Scaling by powers of two, we can consider an equivalent 
  setting in which 2<SUP>52</SUP> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  <EM>m</EM> &lt; 2<SUP>53</SUP> and likewise for <EM>q</EM>, so that both 
  <EM>m</EM> and <EM>q</EM> are integers whose least significant bits occupy the 
  units place (i.e., ulp(<EM>m</EM>) = ulp(<EM>q</EM>) = 1). Before scaling, we 
  assumed <EM>m</EM> &lt; 2<SUP>52</SUP>, so after scaling, <EM>m </EM>is an 
  even integer. Also, because the scaled values of <EM>m</EM> and <EM>q</EM> 
  satisfy <EM>m</EM>/2 &lt; <EM>q</EM> &lt; 2<EM>m</EM>, the corresponding value 
  of <EM>n</EM> must have one of two forms depending on which of <EM>m</EM> or 
  <EM>q</EM> is larger: if <EM>q</EM>&nbsp;&lt;&nbsp;<EM>m</EM>, then evidently 
  1 &lt; <EM>n</EM> &lt; 2, and since <EM>n</EM> is a sum of two powers of two, 
  <EM>n</EM> = 1 + 2<SUP>-</SUP><SUP><EM>k</EM></SUP> for some <EM>k</EM>; 
  similarly, if <EM>q</EM> &gt; <EM>m</EM>, then 1/2 &lt; <EM>n</EM> &lt; 1, so 
  <EM>n</EM> = 1/2 + 2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP> + 1)</SUP>. (As 
  <EM>n</EM> is the sum of two powers of two, the closest possible value of 
  <EM>n</EM> to one is <EM>n</EM> = 1 + 2<SUP>-52</SUP>. Because 
  <EM>m</EM>/(1&nbsp;+ 2<SUP>-52</SUP>) is no larger than the next smaller 
  double precision number less than <EM>m</EM>, we can't have <EM>q</EM> = 
  <EM>m</EM>.)</FONT> </P>
  <P><A name=3546></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Let 
  <EM>e</EM> denote the rounding error in computing <EM>q</EM>, so that 
  <EM>q</EM> = <EM>m</EM>/<EM>n</EM> + <EM>e</EM>, and the computed value 
  <EM>q</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <EM>n</EM> will be the (once or twice) rounded value of <EM>m</EM> + 
  <EM>ne</EM>. Consider first the case in which each floating-point operation is 
  rounded correctly to double precision. In this case, |<EM>e</EM>| &lt; 1/2. If 
  <EM>n</EM> has the form 1/2 + 2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP> + 
  1)</SUP>, then <EM>ne</EM> = <EM>nq</EM> - <EM>m</EM> is an integer multiple 
  of 2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP> + 1)</SUP> and |<EM>ne</EM>| &lt; 
  1/4 + 2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP>&nbsp;+&nbsp;2)</SUP>. This 
  implies that |<EM>ne</EM>| <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  1/4. Recall that the difference between <EM>m</EM> and the next larger 
  representable number is 1 and the difference between <EM>m</EM> and the next 
  smaller representable number is either 1 if <EM>m</EM> &gt; 2<SUP>52</SUP> or 
  1/2 if <EM>m</EM> = 2<SUP>52</SUP>. Thus, as |<EM>ne</EM>| <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  1/4, <EM>m</EM> + <EM>ne</EM> will round to <EM>m</EM>. (Even if <EM>m</EM> = 
  2<SUP>52</SUP> and <EM>ne</EM> = -1/4, the product will round to <EM>m</EM> by 
  the round-ties-to-even rule.) Similarly, if <EM>n</EM> has the form 1 + 
  2<SUP>-</SUP><SUP><EM>k</EM></SUP>, then <EM>ne</EM> is an integer multiple of 
  2<SUP>-</SUP><SUP><EM>k</EM></SUP> and |<EM>ne</EM>|&nbsp;&lt;&nbsp;1/2&nbsp;+ 
  2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP> + 1)</SUP>; this implies 
  |<EM>ne</EM>| <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  1/2. We can't have <EM>m</EM> = 2<SUP>52</SUP> in this case because <EM>m</EM> 
  is strictly greater than <EM>q</EM>, so <EM>m</EM> differs from its nearest 
  representable neighbors by <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">±</FONT>1. Thus, as |<EM>ne</EM>| 
  <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  1/2, again <EM>m</EM> + <EM>ne</EM> will round to <EM>m</EM>. (Even if 
  |<EM>ne</EM>| = 1/2, the product will round to <EM>m</EM> by the 
  round-ties-to-even rule because <EM>m</EM> is even.) This completes the proof 
  for correctly rounded arithmetic.</FONT> </P>
  <P><A name=3415></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In 
  double-rounding arithmetic, it may still happen that <EM>q</EM> is the 
  correctly rounded quotient (even though it was actually rounded twice), so 
  |<EM>e</EM>| &lt; 1/2 as above. In this case, we can appeal to the arguments 
  of the previous paragraph provided we consider the fact that <EM>q</EM> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/circmult.gif"></FONT> 
  <EM>n</EM> will be rounded twice. To account for this, note that the IEEE 
  standard requires that an extended double format carry at least 64 significant 
  bits, so that the numbers <EM>m</EM> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">±</FONT> 1/2 and <EM>m</EM> <FONT 
  face="Verdana, Arial, Helvetica, sans-serif">±</FONT> 1/4 are exactly 
  representable in extended double precision. Thus, if <EM>n</EM> has the form 
  1/2 + 2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP>&nbsp;+&nbsp;1)</SUP>, so that 
  |<EM>ne</EM>| <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  1/4, then rounding <EM>m</EM> + <EM>ne</EM> to extended double precision must 
  produce a result that differs from <EM>m</EM> by at most 1/4, and as noted 
  above, this value will round to <EM>m</EM> in double precision. Similarly, if 
  <EM>n</EM> has the form 1 + 2<SUP>-</SUP><SUP><EM>k</EM></SUP>, so that 
  |<EM>ne</EM>| <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  1/2, then rounding <EM>m</EM>&nbsp;+&nbsp;<EM>ne</EM> to extended double 
  precision must produce a result that differs from <EM>m</EM> by at most 1/2, 
  and this value will round to <EM>m</EM> in double precision. (Recall that 
  <EM>m</EM> &gt; 2<SUP>52</SUP> in this case.)</FONT> </P>
  <P><A name=3540></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Finally, we are left to consider 
  cases in which <EM>q</EM> is not the correctly rounded quotient due to 
  double-rounding. In these cases, we have |<EM>e</EM>| &lt; 1/2 + 
  2<SUP>-(</SUP><SUP><EM>d</EM></SUP><SUP> + 1)</SUP> in the worst case, where 
  <EM>d</EM> is the number of extra bits in the extended double format. (All 
  existing extended-based systems support an extended double format with exactly 
  64 significant bits; for this format, <EM>d</EM> = 64 - 53 = 11.) Because 
  double-rounding only produces an incorrectly rounded result when the second 
  rounding is determined by the round-ties-to-even rule, <EM>q</EM> must be an 
  even integer. Thus if <EM>n</EM> has the form 
  1/2&nbsp;+&nbsp;2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP> + 1)</SUP>, then 
  <EM>ne</EM> = <EM>nq</EM> - <EM>m</EM> is an integer multiple of 
  2<SUP>-</SUP><SUP><EM>k</EM></SUP>, and </FONT></P><A name=12699></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=2>|<EM>ne</EM>| &lt; 
  (1/2&nbsp;+&nbsp;2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP>&nbsp;+&nbsp;1)</SUP>)(1/2 
  + 2<SUP>-(</SUP><SUP><EM>d</EM></SUP><SUP> + 1)</SUP>) = 1/4 + 
  2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP> +&nbsp;2)</SUP> + 
  2<SUP>-(</SUP><SUP><EM>d</EM></SUP><SUP> + 2)</SUP> + 
  2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP> + </SUP><SUP><EM>d</EM></SUP><SUP> + 
  2)</SUP>. <BR></FONT>
  <P><A name=12700></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If 
  <EM>k</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  <EM>d</EM>, this implies |<EM>ne</EM>| <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  1/4. If <EM>k</EM> &gt; <EM>d</EM>, we have |<EM>ne</EM>| <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  1/4 + 2<SUP>-(</SUP><SUP><EM>d</EM></SUP><SUP> + 2)</SUP>. In either case, the 
  first rounding of the product will deliver a result that differs from 
  <EM>m</EM> by at most 1/4, and by previous arguments, the second rounding will 
  round to <EM>m</EM>. Similarly, if <EM>n</EM> has the form 1 + 
  2<SUP>-</SUP><SUP><EM>k</EM></SUP>, then <EM>ne</EM> is an integer multiple of 
  2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP> - 1)</SUP>, and</FONT> </P><A 
  name=12701></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=2>|<EM>ne</EM>| &lt; 1/2 + 2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP> + 
  1)</SUP> + 2<SUP>-(</SUP><SUP><EM>d</EM></SUP><SUP> + 1)</SUP> + 
  2<SUP>-(</SUP><SUP><EM>k</EM></SUP><SUP> + </SUP><SUP><EM>d</EM></SUP><SUP> + 
  1)</SUP>. <BR></FONT>
  <P><A name=12703></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If 
  <EM>k</EM> <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  <EM>d</EM>, this implies |<EM>ne</EM>| <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  1/2. If <EM>k</EM> &gt; <EM>d</EM>, we have |<EM>ne</EM>| <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/lt_equal.gif"></FONT> 
  1/2 + 2<SUP>-(</SUP><SUP><EM>d</EM></SUP><SUP> + 1)</SUP>. In either case, the 
  first rounding of the product will deliver a result that differs from 
  <EM>m</EM> by at most 1/2, and again by previous arguments, the second 
  rounding will round to <EM>m</EM>. <FONT 
  face="Verdana, Arial, Helvetica, sans-serif" size=1>z</FONT> </FONT></P>
  <P><A name=3497></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  preceding proof shows that the product can incur double-rounding only if the 
  quotient does, and even then, it rounds to the correct result. The proof also 
  shows that extending our reasoning to include the possibility of 
  double-rounding can be challenging even for a program with only two 
  floating-point operations. For a more complicated program, it may be 
  impossible to systematically account for the effects of double-rounding, not 
  to mention more general combinations of double and extended double precision 
  computations.</FONT> </P>
  <H3><A name=3922></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Programming Language Support for Extended Precision</FONT> </H3>
  <P><A name=3927></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  preceding examples should not be taken to suggest that extended precision 
  <EM>per se</EM> is harmful. Many programs can benefit from extended precision 
  when the programmer is able to use it selectively. Unfortunately, current 
  programming languages do not provide sufficient means for a programmer to 
  specify when and how extended precision should be used. To indicate what 
  support is needed, we consider the ways in which we might want to manage the 
  use of extended precision.</FONT> </P>
  <P><A name=3945></A><FONT face="Verdana, Arial, Helvetica, sans-serif">In a 
  portable program that uses double precision as its nominal working precision, 
  there are five ways we might want to control the use of a wider 
  precision:</FONT> </P>
  <OL type=1>
    <P>
    <LI value=1><A name=3946></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Compile to produce the fastest 
    code, using extended precision where possible on extended-based systems. 
    Clearly most numerical software does not require more of the arithmetic than 
    that the relative error in each operation is bounded by the "machine 
    epsilon". When data in memory are stored in double precision, the machine 
    epsilon is usually taken to be the largest relative roundoff error in that 
    precision, since the input data are (rightly or wrongly) assumed to have 
    been rounded when they were entered and the results will likewise be rounded 
    when they are stored. Thus, while computing some of the intermediate results 
    in extended precision may yield a more accurate result, extended precision 
    is not essential. In this case, we might prefer that the compiler use 
    extended precision only when it will not appreciably slow the program and 
    use double precision otherwise.</FONT> 
    <P></P>
    <P></P>
    <LI value=2><A name=3947></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Use a format wider than double 
    if it is reasonably fast and wide enough, otherwise resort to something 
    else. Some computations can be performed more easily when extended precision 
    is available, but they can also be carried out in double precision with only 
    somewhat greater effort. Consider computing the Euclidean norm of a vector 
    of double precision numbers. By computing the squares of the elements and 
    accumulating their sum in an IEEE 754 extended double format with its wider 
    exponent range, we can trivially avoid premature underflow or overflow for 
    vectors of practical lengths. On extended-based systems, this is the fastest 
    way to compute the norm. On single/double systems, an extended double format 
    would have to be emulated in software (if one were supported at all), and 
    such emulation would be much slower than simply using double precision, 
    testing the exception flags to determine whether underflow or overflow 
    occurred, and if so, repeating the computation with explicit scaling. Note 
    that to support this use of extended precision, a language must provide both 
    an indication of the widest available format that is reasonably fast, so 
    that a program can choose which method to use, and environmental parameters 
    that indicate the precision and range of each format, so that the program 
    can verify that the widest fast format is wide enough (e.g., that it has 
    wider range than double).</FONT> 
    <P></P>
    <P></P>
    <LI value=3><A name=3948></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Use a format wider than double 
    even if it has to be emulated in software. For more complicated programs 
    than the Euclidean norm example, the programmer may simply wish to avoid the 
    need to write two versions of the program and instead rely on extended 
    precision even if it is slow. Again, the language must provide environmental 
    parameters so that the program can determine the range and precision of the 
    widest available format.</FONT> 
    <P></P>
    <P></P>
    <LI value=4><A name=3949></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Don't use a wider precision; 
    round results correctly to the precision of the double format, albeit 
    possibly with extended range. For programs that are most easily written to 
    depend on correctly rounded double precision arithmetic, including some of 
    the examples mentioned above, a language must provide a way for the 
    programmer to indicate that extended precision must not be used, even though 
    intermediate results may be computed in registers with a wider exponent 
    range than double. (Intermediate results computed in this way can still 
    incur double-rounding if they underflow when stored to memory: if the result 
    of an arithmetic operation is rounded first to 53 significant bits, then 
    rounded again to fewer significant bits when it must be denormalized, the 
    final result may differ from what would have been obtained by rounding just 
    once to a denormalized number. Of course, this form of double-rounding is 
    highly unlikely to affect any practical program adversely.)</FONT> 
    <P></P>
    <P></P>
    <LI value=5><A name=3950></A><FONT 
    face="Verdana, Arial, Helvetica, sans-serif">Round results correctly to both 
    the precision and range of the double format. This strict enforcement of 
    double precision would be most useful for programs that test either 
    numerical software or the arithmetic itself near the limits of both the 
    range and precision of the double format. Such careful test programs tend to 
    be difficult to write in a portable way; they become even more difficult 
    (and error prone) when they must employ dummy subroutines and other tricks 
    to force results to be rounded to a particular format. Thus, a programmer 
    using an extended-based system to develop robust software that must be 
    portable to all IEEE 754 implementations would quickly come to appreciate 
    being able to emulate the arithmetic of single/double systems without 
    extraordinary effort.</FONT> 
    <P></P></LI></OL>
  <P><A name=3951></A><FONT face="Verdana, Arial, Helvetica, sans-serif">No 
  current language supports all five of these options. In fact, few languages 
  have attempted to give the programmer the ability to control the use of 
  extended precision at all. One notable exception is the ISO/IEC 9899:1999 
  Programming Languages - C standard, the latest revision to the C language, 
  which is now in the final stages of standardization.</FONT> </P>
  <P><A name=4014></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The C99 
  standard allows an implementation to evaluate expressions in a format wider 
  than that normally associated with their type, but the C99 standard recommends 
  using one of only three expression evaluation methods. The three recommended 
  methods are characterized by the extent to which expressions are "promoted" to 
  wider formats, and the implementation is encouraged to identify which method 
  it uses by defining the preprocessor macro <CODE>FLT_EVAL_METHOD</CODE>: if 
  <CODE>FLT_EVAL_METHOD</CODE> is 0, each expression is evaluated in a format 
  that corresponds to its type; if <CODE>FLT_EVAL_METHOD</CODE> is 1, 
  <CODE>float</CODE> expressions are promoted to the format that corresponds to 
  <CODE>double</CODE>; and if <CODE>FLT_EVAL_METHOD</CODE> is 2, 
  <CODE>float</CODE> and <CODE>double</CODE> expressions are promoted to the 
  format that corresponds to <CODE>long double</CODE>. (An implementation is 
  allowed to set <CODE>FLT_EVAL_METHOD</CODE> to -1 to indicate that the 
  expression evaluation method is indeterminable.) The C99 standard also 
  requires that the <CODE>&lt;math.h&gt;</CODE> header file define the types 
  <CODE>float_t</CODE> and <CODE>double_t</CODE>, which are at least as wide as 
  <CODE>float</CODE> and <CODE>double</CODE>, respectively, and are intended to 
  match the types used to evaluate <CODE>float</CODE> and <CODE>double</CODE> 
  expressions. For example, if <CODE>FLT_EVAL_METHOD</CODE> is 2, both 
  <CODE>float_t</CODE> and <CODE>double_t</CODE> are <CODE>long double</CODE>. 
  Finally, the C99 standard requires that the <CODE>&lt;float.h&gt;</CODE> 
  header file define preprocessor macros that specify the range and precision of 
  the formats corresponding to each floating-point type.</FONT> </P>
  <P><A name=4073></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  combination of features required or recommended by the C99 standard supports 
  some of the five options listed above but not all. For example, if an 
  implementation maps the <CODE>long double</CODE> type to an extended double 
  format and defines <CODE>FLT_EVAL_METHOD</CODE> to be 2, the programmer can 
  reasonably assume that extended precision is relatively fast, so programs like 
  the Euclidean norm example can simply use intermediate variables of type 
  <CODE>long double</CODE> (or <CODE>double_t</CODE>). On the other hand, the 
  same implementation must keep anonymous expressions in extended precision even 
  when they are stored in memory (e.g., when the compiler must spill 
  floating-point registers), and it must store the results of expressions 
  assigned to variables declared <CODE>double</CODE> to convert them to double 
  precision even if they could have been kept in registers. Thus, neither the 
  <CODE>double</CODE> nor the <CODE>double_t</CODE> type can be compiled to 
  produce the fastest code on current extended-based hardware.</FONT> </P>
  <P><A name=4027></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Likewise, the C99 standard 
  provides solutions to some of the problems illustrated by the examples in this 
  section but not all. A C99 standard version of the <CODE>log1p</CODE> function 
  is guaranteed to work correctly if the expression 
  <CODE>1.0</CODE>&nbsp;<CODE>+</CODE>&nbsp;<CODE>x</CODE> is assigned to a 
  variable (of any type) and that variable used throughout. A portable, 
  efficient C99 standard program for splitting a double precision number into 
  high and low parts, however, is more difficult: how can we split at the 
  correct position and avoid double-rounding if we cannot guarantee that 
  <CODE>double</CODE> expressions are rounded correctly to double precision? One 
  solution is to use the <CODE>double_t</CODE> type to perform the splitting in 
  double precision on single/double systems and in extended precision on 
  extended-based systems, so that in either case the arithmetic will be 
  correctly rounded. Theorem 14 says that we can split at any bit position 
  provided we know the precision of the underlying arithmetic, and the 
  <CODE>FLT_EVAL_METHOD</CODE> and environmental parameter macros should give us 
  this information.</FONT> </P>
  <P><A name=11089></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  following fragment shows one possible implementation: 
  <P>
  <TABLE cellSpacing=0 borderColorDark=#000000 cellPadding=5 
  borderColorLight=#ffffff border=1>
    <CAPTION align=left><B></B></CAPTION>
    <TBODY>
    <TR>
      <TD><FONT face=Courier><A name=4101></A><PRE>#include &lt;math.h&gt;
</PRE><A name=4106></A><PRE>#include &lt;float.h&gt;
</PRE><A name=4107></A><PRE></PRE><A name=4108></A><PRE>#if (FLT_EVAL_METHOD==2)
</PRE><A name=4109></A><PRE>#define PWR2  LDBL_MANT_DIG - (DBL_MANT_DIG/2)
</PRE><A name=4110></A><PRE>#elif ((FLT_EVAL_METHOD==1) || (FLT_EVAL_METHOD==0))
</PRE><A name=4102></A><PRE>#define PWR2  DBL_MANT_DIG - (DBL_MANT_DIG/2)
</PRE><A name=4111></A><PRE>#else
</PRE><A name=4113></A><PRE>#error FLT_EVAL_METHOD unknown!
</PRE><A name=4112></A><PRE>#endif
</PRE><A name=4114></A><PRE></PRE><A name=4115></A><PRE>...
</PRE><A name=4116></A><PRE>    double   x, xh, xl;
</PRE><A name=4117></A><PRE>    double_t m;
</PRE><A name=4118></A><PRE></PRE><A name=4120></A><PRE>    m = scalbn(1.0, PWR2) + 1.0;  // 2**PWR2 + 1
</PRE><A name=4124></A><PRE>    xh = (m * x) - ((m * x) - x);
</PRE><A name=4125></A><PRE>    xl = x - xh;
</PRE></FONT></TD></TR></TBODY></TABLE></P></FONT>
  <P></P>
  <P><A name=4130></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Of 
  course, to find this solution, the programmer must know that 
  <CODE>double</CODE> expressions may be evaluated in extended precision, that 
  the ensuing double-rounding problem can cause the algorithm to malfunction, 
  and that extended precision may be used instead according to Theorem 14. A 
  more obvious solution is simply to specify that each expression be rounded 
  correctly to double precision. On extended-based systems, this merely requires 
  changing the rounding precision mode, but unfortunately, the C99 standard does 
  not provide a portable way to do this. (Early drafts of the Floating-Point C 
  Edits, the working document that specified the changes to be made to the C90 
  standard to support floating-point, recommended that implementations on 
  systems with rounding precision modes provide <CODE>fegetprec</CODE> and 
  <CODE>fesetprec</CODE> functions to get and set the rounding precision, 
  analogous to the <CODE>fegetround</CODE> and <CODE>fesetround</CODE> functions 
  that get and set the rounding direction. This recommendation was removed 
  before the changes were made to the C99 standard.)</FONT> </P>
  <P><A name=4133></A><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">Coincidentally, the C99 
  standard's approach to supporting portability among systems with different 
  integer arithmetic capabilities suggests a better way to support different 
  floating-point architectures. Each C99 standard implementation supplies an 
  <CODE>&lt;stdint.h&gt;</CODE> header file that defines those integer types the 
  implementation supports, named according to their sizes and efficiency: for 
  example, <CODE>int32_t</CODE> is an integer type exactly 32 bits wide, 
  <CODE>int_fast16_t</CODE> is the implementation's fastest integer type at 
  least 16 bits wide, and <CODE>intmax_t</CODE> is the widest integer type 
  supported. One can imagine a similar scheme for floating-point types: for 
  example, <CODE>float53_t</CODE> could name a floating-point type with exactly 
  53 bit precision but possibly wider range, <CODE>float_fast24_t</CODE> could 
  name the implementation's fastest type with at least 24 bit precision, and 
  <CODE>floatmax_t</CODE> could name the widest reasonably fast type supported. 
  The fast types could allow compilers on extended-based systems to generate the 
  fastest possible code subject only to the constraint that the values of named 
  variables must not appear to change as a result of register spilling. The 
  exact width types would cause compilers on extended-based systems to set the 
  rounding precision mode to round to the specified precision, allowing wider 
  range subject to the same constraint. Finally, <CODE>double_t</CODE> could 
  name a type with both the precision and range of the IEEE 754 double format, 
  providing strict double evaluation. Together with environmental parameter 
  macros named accordingly, such a scheme would readily support all five options 
  described above and allow programmers to indicate easily and unambiguously the 
  floating-point semantics their programs require.</FONT> </P>
  <P><A name=4202></A><FONT face="Verdana, Arial, Helvetica, sans-serif">Must 
  language support for extended precision be so complicated? On single/double 
  systems, four of the five options listed above coincide, and there is no need 
  to differentiate fast and exact width types. Extended-based systems, however, 
  pose difficult choices: they support neither pure double precision nor pure 
  extended precision computation as efficiently as a mixture of the two, and 
  different programs call for different mixtures. Moreover, the choice of when 
  to use extended precision should not be left to compiler writers, who are 
  often tempted by benchmarks (and sometimes told outright by numerical 
  analysts) to regard floating-point arithmetic as "inherently inexact" and 
  therefore neither deserving nor capable of the predictability of integer 
  arithmetic. Instead, the choice must be presented to programmers, and they 
  will require languages capable of expressing their selection.</FONT> </P>
  <H3><A name=3365></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  color=#003366>Conclusion</FONT> </H3>
  <P><A name=3220></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  foregoing remarks are not intended to disparage extended-based systems but to 
  expose several fallacies, the first being that all IEEE 754 systems must 
  deliver identical results for the same program. We have focused on differences 
  between extended-based systems and single/double systems, but there are 
  further differences among systems within each of these families. For example, 
  some single/double systems provide a single instruction to multiply two 
  numbers and add a third with just one final rounding. This operation, called a 
  <EM>fused multiply-add</EM>, can cause the same program to produce different 
  results across different single/double systems, and, like extended precision, 
  it can even cause the same program to produce different results on the same 
  system depending on whether and when it is used. (A fused multiply-add can 
  also foil the splitting process of Theorem 6, although it can be used in a 
  non-portable way to perform multiple precision multiplication without the need 
  for splitting.) Even though the IEEE standard didn't anticipate such an 
  operation, it nevertheless conforms: the intermediate product is delivered to 
  a "destination" beyond the user's control that is wide enough to hold it 
  exactly, and the final sum is rounded correctly to fit its single or double 
  precision destination.</FONT> </P>
  <P><A name=4304></A><FONT face="Verdana, Arial, Helvetica, sans-serif">The 
  idea that IEEE 754 prescribes precisely the result a given program must 
  deliver is nonetheless appealing. Many programmers like to believe that they 
  can understand the behavior of a program and prove that it will work correctly 
  without reference to the compiler that compiles it or the computer that runs 
  it. In many ways, supporting this belief is a worthwhile goal for the 
  designers of computer systems and programming languages. Unfortunately, when 
  it comes to floating-point arithmetic, the goal is virtually impossible to 
  achieve. The authors of the IEEE standards knew that, and they didn't attempt 
  to achieve it. As a result, despite nearly universal conformance to (most of) 
  the IEEE 754 standard throughout the computer industry, programmers of 
  portable software must continue to cope with unpredictable floating-point 
  arithmetic.</FONT> </P>
  <P><A name=4311></A><FONT face="Verdana, Arial, Helvetica, sans-serif">If 
  programmers are to exploit the features of IEEE 754, they will need 
  programming languages that make floating-point arithmetic predictable. The C99 
  standard improves predictability to some degree at the expense of requiring 
  programmers to write multiple versions of their programs, one for each 
  <CODE>FLT_EVAL_METHOD</CODE>. Whether future languages will choose instead to 
  allow programmers to write a single program with syntax that unambiguously 
  expresses the extent to which it depends on IEEE 754 semantics remains to be 
  seen. Existing extended-based systems threaten that prospect by tempting us to 
  assume that the compiler and the hardware can know better than the programmer 
  how a computation should be performed on a given system. That assumption is 
  the second fallacy: the accuracy required in a computed result depends not on 
  the machine that produces it but only on the conclusions that will be drawn 
  from it, and of the programmer, the compiler, and the hardware, at best only 
  the programmer can know what those conclusions may be.</FONT> </P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#683"><SUP>1</SUP></A> 
  <A name=1370></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>Examples of other representations are <EM>floating slash</EM> and 
  <EM>signed logarithm </EM>[Matula and Kornerup 1985; Swartzlander and 
  Alexopoulos 1975].</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#10061"><SUP>2</SUP></A> 
  <A name=1377></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>This term was introduced by Forsythe and Moler [1967], and has 
  generally replaced the older term <EM>mantissa</EM>.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#684"><SUP>3</SUP></A> 
  <A name=685></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>This assumes the usual arrangement where the exponent is stored to the 
  left of the significand.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#688"><SUP>4</SUP></A> 
  <A name=690></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>Unless the number <FONT face=Arial,Helvetica><EM>z</EM></FONT> is 
  larger than <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg97.gif" 
  width=24> +1 or smaller than <IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg91.gif" 
  width=24> . Numbers which are out of range in this fashion will not be 
  considered until further notice.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#688"><SUP>5</SUP></A> 
  <A name=728></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=-1>Let 
  <FONT face=Arial,Helvetica><EM>z</EM></FONT>' be the floating-point number 
  that approximates <FONT face=Arial,Helvetica><EM>z</EM></FONT>. Then <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakmidl.gif"></FONT><FONT 
  face=Arial,Helvetica><EM>d.d</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif">...</FONT><FONT 
  face=Arial,Helvetica><EM>d</EM></FONT> - (<FONT 
  face=Arial,Helvetica><EM>z</EM></FONT>/<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>e</EM></SUP>)<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakmidl.gif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>p-1</EM></SUP> 
  is equivalent to <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakmidl.gif"><FONT 
  face=Arial,Helvetica><EM>z</EM></FONT>'-<FONT 
  face=Arial,Helvetica><EM>z</EM></FONT><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakmidl.gif">/ulp(<FONT 
  face=Arial,Helvetica><EM>z</EM></FONT>'). A more accurate formula for 
  measuring error is <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakmidl.gif"><FONT 
  face=Arial,Helvetica><EM>z</EM></FONT>'-<FONT 
  face=Arial,Helvetica><EM>z</EM></FONT><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/brakmidl.gif">/ulp(<FONT 
  face=Arial,Helvetica><EM>z</EM></FONT>). - Ed. </FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#9518"><SUP>6</SUP></A> 
  <A name=9521></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>700, not 70. Since .1 - .0292 = .0708, the error in terms of 
  ulp(0.0292) is 708 ulps. - Ed.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1393"><SUP>7</SUP></A> 
  <A name=1397></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>Although the expression (<FONT face=Arial,Helvetica><EM>x</EM></FONT> 
  - <FONT face=Arial,Helvetica><EM>y</EM></FONT>)(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) does not cause a catastrophic 
  cancellation, it is slightly less accurate than <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP> -<FONT 
  face=Arial,Helvetica><EM> y</EM></FONT><SUP>2</SUP> if <IMG height=13 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg149.gif" 
  width=26> or <IMG height=13 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg155.gif" 
  width=26> . In this case, (<FONT face=Arial,Helvetica><EM>x</EM></FONT> - 
  <FONT face=Arial,Helvetica><EM>y</EM></FONT>)(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT>) has three rounding errors, but 
  x<SUP>2</SUP> - y<SUP>2 </SUP>has only two since the rounding error committed 
  when computing the smaller of <FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>2</SUP> and <FONT 
  face=Arial,Helvetica><EM>y</EM></FONT><SUP>2</SUP> does not affect the final 
  subtraction.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#705"><SUP>8</SUP></A> 
  <A name=729></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>Also commonly referred to as <EM>correctly rounded</EM>. - Ed. </FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#11655"><SUP>9</SUP></A> 
  <A name=730></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>When n = 845, x<SUB>n</SUB>= 9.45, x<SUB>n</SUB> + 0.555 = 10.0, and 
  10.0 - 0.555 = 9.45. Therefore, x<SUB>n</SUB> = x<SUB>845 </SUB>for<FONT 
  face=Arial,Helvetica><EM> n</EM></FONT> &gt; 845. </FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#11706"><SUP>10</SUP></A> 
  <A name=11697></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>Notice that in binary,<EM> q</EM> cannot equal <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg217.gif" 
  width=10> . - Ed. </FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#9922"><SUP>11</SUP></A> 
  <A name=9921></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>Left as an exercise to the reader: extend the proof to bases other 
  than 2. - Ed. </FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#807"><SUP>12</SUP></A> 
  <A name=808></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=1>This 
  appears to have first been published by Goldberg [1967], although Knuth 
  ([1981], page 211) attributes this idea to Konrad Zuse.<BR></FONT><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#853"><SUP>13</SUP></A> 
  <A name=854></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=1>According to Kahan, extended precision has 64 bits of significand 
  because that was the widest precision across which carry propagation could be 
  done on the Intel 8087 without increasing the cycle time [Kahan 
  1988].<BR></FONT><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#12892"><SUP>14</SUP></A> 
  <A name=12895></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>Some arguments against including inner product as one of the basic 
  operations are presented by Kahan and LeBlanc [1985].</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#12892"><SUP>15</SUP></A> 
  <A name=12898></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=1>Kirchner writes: It is possible to compute inner products to within 1 
  ulp in hardware in one partial product per clock cycle. The additionally 
  needed hardware compares to the multiplier array needed anyway for that speed. 
  <BR></FONT><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#873"><SUP>16</SUP></A> 
  <A name=874></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=1>CORDIC is an acronym for Coordinate Rotation Digital Computer and is a 
  method of computing transcendental functions that uses mostly shifts and adds 
  (i.e., very few multiplications and divisions) [Walther 1971]. It is the 
  method additionally needed hardware compares to the multiplier array needed 
  anyway for that speed. d used on both the Intel 8087 and the Motorola 
  68881.<BR></FONT><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#919"><SUP>17</SUP></A> 
  <A name=920></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>Fine point: Although the default in IEEE arithmetic is to round 
  overflowed numbers to <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  it is possible to change the default (see <A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#984">Rounding 
  Modes</A>)</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#936"><SUP>18</SUP></A> 
  <A name=935></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>They are called <EM>subnormal</EM> in 854, <EM>denormal</EM> in 
  754.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#936"><SUP>19</SUP></A> 
  <A name=937></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=1>This 
  is the cause of one of the most troublesome aspects of the standard. Programs 
  that frequently underflow often run noticeably slower on hardware that uses 
  software traps.<BR></FONT><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#5376"><SUP>20</SUP></A> 
  <A name=5385></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=-1>No 
  invalid exception is raised unless a "trapping" NaN is involved in the 
  operation. See section 6.2 of IEEE Std 754-1985. - Ed. </FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#717"><SUP>21</SUP></A> 
  <A name=753></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1><IMG height=18 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg291.gif" 
  width=9> may be greater than <IMG height=16 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg295.gif" 
  width=9> if both x and y are negative. - Ed. </FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#6183"><SUP>22</SUP></A> 
  <A name=6189></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=-1>It 
  can be in range because if <EM>x</EM> &lt; 1, <FONT 
  face=Arial,Helvetica><EM>n</EM></FONT> &lt; 0 and 
  <EM>x</EM><SUP>-</SUP><SUP><EM>n</EM></SUP> is just a tiny bit smaller than 
  the underflow threshold <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg66.gif" 
  width=26> , then <IMG height=20 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/ncg_goldberg79.gif" 
  width=92> , and so may not overflow, since in all IEEE precisions, 
  -<EM>e</EM><SUB>min</SUB> &lt; <EM>e</EM><SUB>max.</SUB></FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#12036"><SUP>23</SUP></A> 
  <A name=12039></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>This is probably because designers like "orthogonal" instruction sets, 
  where the precisions of a floating-point instruction are independent of the 
  actual operation. Making a special case for multiplication destroys this 
  orthogonality.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1053"><SUP>24</SUP></A> 
  <A name=1054></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>This assumes the common convention that <CODE>3.0</CODE> is a 
  single-precision constant, while <CODE>3.0D0</CODE> is a double precision 
  constant.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1060"><SUP>25</SUP></A> 
  <A name=1061></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>The conclusion that 0<SUP>0</SUP> = 1 depends on the restriction that 
  <FONT face=Arial,Helvetica><EM>f</EM></FONT> be nonconstant. If this 
  restriction is removed, then letting <FONT 
  face=Arial,Helvetica><EM>f</EM></FONT> be the identically 0 function gives 0 
  as a possible value for lim <SUB>x <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/arrwrite.gif"> 
  0</SUB> <FONT face=Arial,Helvetica><EM>f</EM></FONT>(<FONT 
  face=Arial,Helvetica><EM>x</EM></FONT>)<SUP><EM>g</EM></SUP><SUP>(</SUP><SUP><EM>x</EM></SUP><SUP>)</SUP>, 
  and so 0<SUP>0</SUP> would have to be defined to be a NaN.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1060"><SUP>26</SUP></A> 
  <A name=1062></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=1>In 
  the case of 0<SUP>0</SUP>, plausibility arguments can be made, but the 
  convincing argument is found in "Concrete Mathematics" by Graham, Knuth and 
  Patashnik, and argues that 0<FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=3>0</FONT> = 1 for the binomial theorem to work. - Ed. <BR></FONT><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1066"><SUP>27</SUP></A> 
  <A name=1067></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>Unless the rounding mode is round toward -<FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/infinity.gif"></FONT>, 
  in which case <EM>x</EM> - <FONT face=Arial,Helvetica><EM>x</EM></FONT> = 
  -0.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1102"><SUP>28</SUP></A> 
  <A name=1103></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>The VMS math libraries on the VAX use a weak form of in-line procedure 
  substitution, in that they use the inexpensive jump to subroutine call rather 
  than the slower <CODE>CALLS</CODE> and <CODE>CALLG</CODE> instructions.</FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1123"><SUP>29</SUP></A> 
  <A name=1124></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>The difficulty with presubstitution is that it requires either direct 
  hardware implementation, or continuable floating-point traps if implemented in 
  software. - Ed. </FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1240"><SUP>30</SUP></A> 
  <A name=1241></A><FONT face="Verdana, Arial, Helvetica, sans-serif" size=-1>In 
  this informal proof, assume that <IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"> 
  = 2 so that multiplication by 4 is exact and doesn't require a <FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/delta.gif"></FONT><SUB><EM>i.</EM></SUB></FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1196"><SUP>31</SUP></A> 
  <A name=1343></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=-1>This is the sum if adding w does not generate carry out. Additional 
  argument is needed for the special case where adding w does generate carry 
  out. - Ed. </FONT>
  <P></P><A 
  href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#1344"><SUP>32</SUP></A> 
  <A name=1345></A><FONT face="Verdana, Arial, Helvetica, sans-serif" 
  size=1>Rounding gives <FONT face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>w</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP> 
  - <FONT face=Arial,Helvetica><EM>r</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k 
  </EM></SUP>only if<SUP> (</SUP><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT> + <FONT 
  face=Arial,Helvetica><EM>w</EM></FONT><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><SUP>) 
  </SUP>keeps the form of<SUP> </SUP><FONT 
  face="Verdana, Arial, Helvetica, sans-serif"><IMG 
  src="What%20Every%20Computer%20Scientist%20Should%20Know%20About%20Floating-Point%20Arithmetic_files/beta.gif"></FONT><SUP><EM>k</EM></SUP><FONT 
  face=Arial,Helvetica><EM>x</EM></FONT><SUP>. </SUP>-<SUP> Ed. 
</SUP><BR></FONT></BLOCKQUOTE>
<HR>
<!-- BEGINNING OF NAVIGATION BAR ------------------------------------------------- -->
<TABLE cellPadding=6 width="100%" border=0 cellspacing-?0?>
  <TBODY>
  <TR>
    <TD vAlign=top align=left><FONT size=2><A href="http://www.sun.com/">Sun 
      Microsystems, Inc.</A><BR><A 
      href="http://docs.sun.com/source/806-3568/PRN.html">Copyright 
      information</A>. All rights reserved.<BR><A 
      href="http://www.sun.com/cgi-bin/comment-form.pl">Feedback</A><BR></FONT></TD>
    <TD vAlign=top align=right><FONT face=helvetica,arial size=2><A 
      href="http://docs.sun.com/index.html">Library</A> 
      &nbsp;&nbsp;|&nbsp;&nbsp; <A 
      href="http://docs.sun.com/source/806-3568/ncgTOC.html">Contents</A> 
      &nbsp;&nbsp;|&nbsp;&nbsp; <A 
      href="http://docs.sun.com/source/806-3568/ncg_x86.html">Previous</A> 
      &nbsp;&nbsp;|&nbsp;&nbsp; <A 
      href="http://docs.sun.com/source/806-3568/ncg_compliance.html">Next</A> 
      &nbsp;&nbsp;|&nbsp;&nbsp; <A 
      href="http://docs.sun.com/source/806-3568/ncgIX.html">Index</A> 
  </FONT></TD></TR></TBODY></TABLE><!-- END OF NAVIGATION BAR ------------------------------------------------------- --></BODY></HTML>
