<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:m="http://schemas.microsoft.com/office/2004/12/omml"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1253">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 12">
<meta name=Originator content="Microsoft Word 12">
<link rel=File-List href="lec12-subroutines-example3_files/filelist.xml">
<link rel=Edit-Time-Data href="lec12-subroutines-example3_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>ECE243</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Name</o:Author>
  <o:LastAuthor>bongo</o:LastAuthor>
  <o:Revision>123</o:Revision>
  <o:TotalTime>268</o:TotalTime>
  <o:Created>2005-01-27T05:46:00Z</o:Created>
  <o:LastSaved>2012-02-13T15:47:00Z</o:LastSaved>
  <o:Pages>3</o:Pages>
  <o:Words>1285</o:Words>
  <o:Characters>7327</o:Characters>
  <o:Company>Organization</o:Company>
  <o:Lines>61</o:Lines>
  <o:Paragraphs>17</o:Paragraphs>
  <o:CharactersWithSpaces>8595</o:CharactersWithSpaces>
  <o:Version>12.00</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<link rel=themeData href="lec12-subroutines-example3_files/themedata.thmx">
<link rel=colorSchemeMapping
href="lec12-subroutines-example3_files/colorschememapping.xml">
<!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Zoom>BestFit</w:Zoom>
  <w:SpellingState>Clean</w:SpellingState>
  <w:GrammarState>Clean</w:GrammarState>
  <w:TrackMoves>false</w:TrackMoves>
  <w:TrackFormatting/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DoNotPromoteQF/>
  <w:LidThemeOther>EN-US</w:LidThemeOther>
  <w:LidThemeAsian>X-NONE</w:LidThemeAsian>
  <w:LidThemeComplexScript>X-NONE</w:LidThemeComplexScript>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
   <w:DontGrowAutofit/>
   <w:SplitPgBreakAndParaMark/>
   <w:DontVertAlignCellWithSp/>
   <w:DontBreakConstrainedForcedTables/>
   <w:DontVertAlignInTxbx/>
   <w:Word11KerningPairs/>
   <w:CachedColBalance/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
  <m:mathPr>
   <m:mathFont m:val="Cambria Math"/>
   <m:brkBin m:val="before"/>
   <m:brkBinSub m:val="&#45;-"/>
   <m:smallFrac m:val="off"/>
   <m:dispDef/>
   <m:lMargin m:val="0"/>
   <m:rMargin m:val="0"/>
   <m:defJc m:val="centerGroup"/>
   <m:wrapIndent m:val="1440"/>
   <m:intLim m:val="subSup"/>
   <m:naryLim m:val="undOvr"/>
  </m:mathPr></w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" DefUnhideWhenUsed="false"
  DefSemiHidden="false" DefQFormat="false" LatentStyleCount="267">
  <w:LsdException Locked="false" QFormat="true" Name="Normal"/>
  <w:LsdException Locked="false" QFormat="true" Name="heading 1"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 2"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 3"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 4"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 5"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 6"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 7"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 8"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 9"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="caption"/>
  <w:LsdException Locked="false" QFormat="true" Name="Title"/>
  <w:LsdException Locked="false" Priority="1" Name="Default Paragraph Font"/>
  <w:LsdException Locked="false" QFormat="true" Name="Subtitle"/>
  <w:LsdException Locked="false" QFormat="true" Name="Strong"/>
  <w:LsdException Locked="false" QFormat="true" Name="Emphasis"/>
  <w:LsdException Locked="false" Priority="99" Name="No List"/>
  <w:LsdException Locked="false" Priority="99" SemiHidden="true"
   Name="Placeholder Text"/>
  <w:LsdException Locked="false" Priority="1" QFormat="true" Name="No Spacing"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 1"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 1"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 1"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 1"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 1"/>
  <w:LsdException Locked="false" Priority="99" SemiHidden="true" Name="Revision"/>
  <w:LsdException Locked="false" Priority="34" QFormat="true"
   Name="List Paragraph"/>
  <w:LsdException Locked="false" Priority="29" QFormat="true" Name="Quote"/>
  <w:LsdException Locked="false" Priority="30" QFormat="true"
   Name="Intense Quote"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 1"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 1"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 1"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 1"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 1"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 1"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 2"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 2"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 2"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 2"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 2"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 2"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 2"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 2"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 3"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 3"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 3"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 3"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 3"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 3"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 3"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 3"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 4"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 4"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 4"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 4"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 4"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 4"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 4"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 4"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 5"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 5"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 5"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 5"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 5"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 5"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 5"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 5"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 6"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 6"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 6"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 6"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 6"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 6"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 6"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 6"/>
  <w:LsdException Locked="false" Priority="19" QFormat="true"
   Name="Subtle Emphasis"/>
  <w:LsdException Locked="false" Priority="21" QFormat="true"
   Name="Intense Emphasis"/>
  <w:LsdException Locked="false" Priority="31" QFormat="true"
   Name="Subtle Reference"/>
  <w:LsdException Locked="false" Priority="32" QFormat="true"
   Name="Intense Reference"/>
  <w:LsdException Locked="false" Priority="33" QFormat="true" Name="Book Title"/>
  <w:LsdException Locked="false" Priority="37" SemiHidden="true"
   UnhideWhenUsed="true" Name="Bibliography"/>
  <w:LsdException Locked="false" Priority="39" SemiHidden="true"
   UnhideWhenUsed="true" QFormat="true" Name="TOC Heading"/>
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:Batang;
	panose-1:2 3 6 0 0 1 1 1 1 1;
	mso-font-alt:Batang;
	mso-font-charset:129;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1342176593 1775729915 48 0 524447 0;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;
	mso-font-charset:1;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:variable;
	mso-font-signature:0 0 0 0 0 0;}
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:-520081665 -1073717157 41 0 66047 0;}
@font-face
	{font-family:"\@Batang";
	panose-1:2 3 6 0 0 1 1 1 1 1;
	mso-font-charset:129;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:-1342176593 1775729915 48 0 524447 0;}
@font-face
	{font-family:Consolas;
	panose-1:2 11 6 9 2 2 4 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:auto;
	mso-font-signature:0 0 0 0 0 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";
	mso-fareast-font-family:Batang;}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{mso-style-unhide:no;
	mso-style-link:"Plain Text Char";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:Batang;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-unhide:no;
	mso-style-link:"Balloon Text Char";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:8.0pt;
	font-family:"Tahoma","sans-serif";
	mso-fareast-font-family:Batang;}
span.PlainTextChar
	{mso-style-name:"Plain Text Char";
	mso-style-unhide:no;
	mso-style-locked:yes;
	mso-style-link:"Plain Text";
	mso-ansi-font-size:10.5pt;
	mso-bidi-font-size:10.5pt;
	font-family:"Consolas","serif";
	mso-ascii-font-family:Consolas;
	mso-fareast-font-family:Batang;
	mso-hansi-font-family:Consolas;}
span.BalloonTextChar
	{mso-style-name:"Balloon Text Char";
	mso-style-unhide:no;
	mso-style-locked:yes;
	mso-style-link:"Balloon Text";
	mso-ansi-font-size:8.0pt;
	mso-bidi-font-size:8.0pt;
	font-family:"Tahoma","sans-serif";
	mso-ascii-font-family:Tahoma;
	mso-fareast-font-family:Batang;
	mso-hansi-font-family:Tahoma;
	mso-bidi-font-family:Tahoma;}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
.MsoChpDefault
	{mso-style-type:export-only;
	mso-default-props:yes;
	font-size:10.0pt;
	mso-ansi-font-size:10.0pt;
	mso-bidi-font-size:10.0pt;}
@page WordSection1
	{size:8.5in 11.0in;
	margin:1.0in 65.95pt 1.0in 65.95pt;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.WordSection1
	{page:WordSection1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-qformat:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman","serif";}
table.MsoTableGrid
	{mso-style-name:"Table Grid";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-unhide:no;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman","serif";}
</style>
<![endif]-->
<script id="injection_graph_func"  charset="utf-8" src="lec12-subroutines-example3_files/injection_graph_func.js">
</script>
<!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="11266"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=WordSection1>

<p class=MsoPlainText>ECE243</p>

<p class=MsoPlainText>Spring 2005</p>

<p class=MsoPlainText>Andreas <span class=SpellE>Moshovos</span></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b>Subroutines – Examples<o:p></o:p></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>We will look at two subroutine examples. We may not cover
both of them during the lectures. You may use those that we do not cover as
practice questions. That is, try to develop code for the C equivalents and then
compare your solution to the ones presented here.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b>1. Searching Through a Sorted Binary Tree<o:p></o:p></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>A binary tree is a data structure comprising several
nodes. Each node has three components:</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. A data value</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. A left child</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3. A right child</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Both children are also nodes. In C we can define a tree
using the following structure:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span class=SpellE><span class=GramE>struct</span></span>
<span class=SpellE>node_t</span></p>

<p class=MsoPlainText>{</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=SpellE><span
class=GramE>int</span></span>&nbsp;&nbsp; value;</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=SpellE><span
class=GramE>struct</span></span> <span class=SpellE>node_t</span> *left;</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class=SpellE><span
class=GramE>struct</span></span> <span class=SpellE>node_t</span> *right;</p>

<p class=MsoPlainText>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>A binary tree is sorted if the following two conditions
apply at each node:</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. The values of all nodes
in the left <span class=SpellE>subtree</span> of a node are less than the value
of the node.</p>

<p class=MsoPlainText style='margin-left:.5in'>2. The values of all nodes in
the right <span class=SpellE>subtree</span> of a node are greater than or equal
to the value of the node.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>The following figure shows a sorted binary tree:</p>

<p class=MsoPlainText><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="Picture_x0020_1" o:spid="_x0000_i1026" type="#_x0000_t75"
 alt="image002" style='width:233.35pt;height:174.65pt;visibility:visible;
 mso-wrap-style:square'>
 <v:imagedata src="lec12-subroutines-example3_files/image001.gif" o:title="image002"/>
</v:shape><![endif]--><![if !vml]><img width=311 height=233
src="lec12-subroutines-example3_files/image001.gif" alt=image002 v:shapes="Picture_x0020_1"><![endif]></span></p>

<p class=MsoPlainText>The following C function searches a sorted binary tree
for a given value. It returns 1 if the value is found otherwise it returns 0:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span class=SpellE><span class=GramE>int</span></span></p>

<p class=MsoPlainText><span class=SpellE>st_search</span> (<span class=SpellE>struct</span>
<span class=SpellE>node_t</span> *tree, <span class=SpellE>int</span> value)</p>

<p class=MsoPlainText>{</p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=SpellE><span
class=GramE>struct</span></span> <span class=SpellE>node_t</span>&nbsp;&nbsp; *<span
class=SpellE>curr</span> = tree;</p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=GramE>while</span>
(<span class=SpellE>curr</span>)</p>

<p class=MsoPlainText style='text-indent:12.0pt'>{</p>

<p class=MsoPlainText style='text-indent:.5in'><span class=GramE>if</span> (<span
class=SpellE>curr</span>-&gt;value == value) return 1; // value found</p>

<p class=MsoPlainText style='text-indent:.5in'><span class=GramE>if</span>
(value &lt; <span class=SpellE>curr</span>-&gt;value)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// if value less than that of the current node search the left</p>

<p class=MsoPlainText style='text-indent:12.0pt'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span class=SpellE><span class=GramE>curr</span></span> = <span class=SpellE>curr</span>-&gt;left;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// <span class=SpellE>subtree</span></p>

<p class=MsoPlainText style='text-indent:.5in'>else<span class=GramE>&nbsp; <span
class=SpellE>curr</span></span> = <span class=SpellE>curr</span>-&gt;right;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// search the right <span class=SpellE>subtree</span></p>

<p class=MsoPlainText style='text-indent:12.0pt'>}</p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=GramE>return</span>
0;</p>

<p class=MsoPlainText>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>This routine uses the <span class=SpellE>curr</span>
pointer to start searching from the top node following the left or right child
pointers until either the value is found or there are no more nodes to search.
The following figure shows the path the function will follow if called to
search for value 13.</p>

<p class=MsoPlainText><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_2" o:spid="_x0000_i1025" type="#_x0000_t75" alt="image004"
 style='width:232.65pt;height:174.65pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="lec12-subroutines-example3_files/image002.gif" o:title="image004"/>
</v:shape><![endif]--><![if !vml]><img width=310 height=233
src="lec12-subroutines-example3_files/image002.gif" alt=image004 v:shapes="Picture_x0020_2"><![endif]></span></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>At the machine level the tree has to be represented in
memory. Following the “<span class=SpellE>struct</span>” definition in C, each
node is represented using three consecutive words in memory. The order and use
of the words follows exactly that of the “<span class=SpellE>struct</span>”
definition: The first holds the data <span class=GramE>value,</span> the second
word contains a <b>pointer </b>to the left child while the third word contains
a pointer to the right child. A pointer has a value which can be used as an
address to refer to some other object in memory. Here’s a series of assembler
directives that form our example tree:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>.<span class=SpellE>equ</span><span style='mso-tab-count:
1'>  </span>NULL,<span style='mso-tab-count:1'> </span>0<span style='mso-tab-count:
1'>     </span># define NULL to be a pointer to address 0. By default this is
the NULL pointer in C</p>

<p class=MsoPlainText><span style='mso-tab-count:3'>                  </span># <span
class=GramE>This</span> is a compromise as this way we cannot store an object
at address 0 and take its pointer</p>

<p class=MsoPlainText><span style='mso-tab-count:3'>                  </span># <span
class=GramE>but</span> then, there are 2^32-1 other addresses we can use</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span
style='mso-spacerun:yes'>  </span>.data</p>

<p class=MsoPlainText>node0: .word<span class=GramE>&nbsp; 10</span>, node1,
node2&nbsp; # top node</p>

<p class=MsoPlainText>node1: .word<span class=GramE>&nbsp; 5</span>, NULL,
node3&nbsp;&nbsp;&nbsp; # top node’s left child</p>

<p class=MsoPlainText>node2: .word<span class=GramE>&nbsp; 20</span>, node4,
node5&nbsp; # top node’s right child</p>

<p class=MsoPlainText>node3: .word<span class=GramE>&nbsp; 8</span>, NULL,
NULL&nbsp;&nbsp;&nbsp;&nbsp; </p>

<p class=MsoPlainText>node4: .word<span class=GramE>&nbsp; 15</span>, NULL,
NULL</p>

<p class=MsoPlainText>node5: .word<span class=GramE>&nbsp; 30</span>, NULL,
NULL</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Note that the exact order in which the nodes appear in
memory is *not* important. That is the following statements define the same
tree (when viewed in the abstract) but with a different in memory layout:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>.<span class=SpellE>equ</span><span style='mso-tab-count:
1'>  </span>NULL,<span style='mso-tab-count:1'> </span>0</p>

<p class=MsoPlainText>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span
style='mso-spacerun:yes'>  </span>.data</p>

<p class=MsoPlainText>node2: .word<span class=GramE>&nbsp; 20</span>, node4,
node5&nbsp; # top node’s right child</p>

<p class=MsoPlainText>node3: .word<span class=GramE>&nbsp; 8</span>, NULL,
NULL&nbsp;&nbsp;&nbsp;&nbsp; </p>

<p class=MsoPlainText>node4: .word<span class=GramE>&nbsp; 15</span>, NULL,
NULL</p>

<p class=MsoPlainText>node5: .word<span class=GramE>&nbsp; 30</span>, NULL,
NULL</p>

<p class=MsoPlainText>node0: .word<span class=GramE>&nbsp; 10</span>, node1,
node2&nbsp; # top node</p>

<p class=MsoPlainText>node1: .word<span class=GramE>&nbsp; 5</span>, NULL,
node3&nbsp;&nbsp;&nbsp; # top node’s left child</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>The next important step is to figure out what the stack
layout should be for a correct implementation of <span class=SpellE>st_search</span>.
This subroutine takes two arguments: a pointer and a value. So, we do not need
to pass any values through the stack.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>With this in hand now we can start writing the
subroutine. </p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>A concern any time we start developing a subroutine is
that often we cannot tell immediately how many registers and local variables
(allocated on the stack) we will need. This is important to know as we will
have to save registers on the stack prior to using them and since we will have
to allocate local variables on the stack. The net effect will be that the
relative distance from the stack pointer of the parameters may change. A
methodology that would work is to write the subroutine using names for the
various parameters and locals and once the subroutine is complete to rewrite
saving/restoring any registers we used and replacing parameter names with
appropriate displacements from the top of the stack.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Here’s the first implementation that ignores
saving/restoring registers:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>.text</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span># r4
contains “tree”, we’ll re-use it for <span class=SpellE>curr</span></p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span># <span
class=GramE>this</span> OK since the value of r4 does not need to be preserved</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span># r5
contains “value”</p>

<p class=MsoPlainText><span class=SpellE>st_search</span>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span># <span
class=GramE>nothing</span> is needed for <span class=SpellE>curr</span> = tree,
we reuse r4</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span class=GramE>loop</span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
class=SpellE><span class=GramE>beq</span></span><span style='mso-tab-count:
2'>         </span>r0, r4, <span class=SpellE>notfound</span><span
style='mso-tab-count:1'>  </span># if reached a NULL pointer</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
class=SpellE><span class=GramE>ldw</span></span><span
style='mso-spacerun:yes'>  </span><span style='mso-tab-count:2'>       </span>r8,
0(r4)<span style='mso-tab-count:2'>         </span># read <span class=SpellE>curr</span>-&gt;value
into r8</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
class=SpellE><span class=GramE>beq</span></span><span style='mso-tab-count:
2'>         </span>r8, r5, found<span style='mso-tab-count:1'>     </span># if <span
class=SpellE>curr</span>-&gt;value == value <span class=SpellE>goto</span>
found</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
class=SpellE><span class=GramE>blt</span></span><span style='mso-tab-count:
2'>         </span>r5, r8, <span class=SpellE>goleft</span><span
style='mso-tab-count:1'>    </span># if the value we are looking for is greater
than the one we just read we </p>

<p class=MsoPlainText><span style='mso-tab-count:7'>                                          </span>#
must visit the left <span class=SpellE>subtree</span></p>

<p class=MsoPlainText><span class=SpellE><span class=GramE>goright</span></span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
class=SpellE><span class=GramE>ldw</span></span><span
style='mso-spacerun:yes'>  </span><span style='mso-tab-count:2'>       </span>r4,
8(r4)<span style='mso-tab-count:2'>         </span># <span class=SpellE>curr</span>
= <span class=SpellE>curr</span>-&gt;right</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
class=SpellE><span class=GramE>br</span></span><span style='mso-tab-count:2'>          </span>loop</p>

<p class=MsoPlainText><span class=SpellE><span class=GramE>goleft</span></span>:
<span style='mso-tab-count:1'>    </span><span class=SpellE>ldw</span><span
style='mso-spacerun:yes'>  </span><span style='mso-tab-count:2'>       </span>r4,
4(r4)<span style='mso-tab-count:2'>         </span># <span class=SpellE>curr</span>
= <span class=SpellE>curr</span>-&gt;left</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
class=SpellE><span class=GramE>br</span></span><span style='mso-tab-count:2'>          </span>loop</p>

<p class=MsoPlainText><span class=GramE>found</span>:<span style='mso-tab-count:
1'>      </span><span class=SpellE>addi</span><span style='mso-tab-count:2'>        </span>r2,
r0, 1</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
class=SpellE><span class=GramE>br</span></span><span style='mso-tab-count:2'>          </span>epilogue</p>

<p class=MsoPlainText><span class=SpellE><span class=GramE>notfound</span></span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
class=GramE>add</span><span style='mso-tab-count:2'>         </span>r2, r0, r0</p>

<p class=MsoPlainText><span class=GramE>epilogue</span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
class=GramE>ret</span></p>

<p class=MsoPlainText><b><span style='color:red'><o:p>&nbsp;</o:p></span></b></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>In this case no further changes are needed since we did
not modify any <span class=SpellE>callee</span>-saved registers and we did not
use any stack allocated locals.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><b>SECOND EXAMPLE: Detecting whether a string is a
palindrome (or <span class=SpellE>carcinic</span>)<o:p></o:p></b></p>

<p class=MsoPlainText><b><o:p>&nbsp;</o:p></b></p>

<p class=MsoPlainText>A series of letters is a palindrome if it reads exactly
the same if read from left to right or from right to left. For example “<span
class=SpellE>abba</span>” is a palindrome and so is “<span class=SpellE>lalal</span>”.
“<span class=SpellE><span class=GramE>lala</span></span>” is not a palindrome.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>We want to write a function that returns 1 if its string
parameter is a palindrome. The function should return a 0 otherwise. Before we
do so, let’s first explain what <span class=GramE>is a string</span>. A string
at the machine level is a sequence of bytes. The C implementation of strings
uses a zero-terminated sequence of bytes. That is, the end of the string is
marked by a byte whose value is zero. This zero is not part of the <span
class=GramE>string,</span> it only marks its end. Hence we cannot have a string
that contains the 0 byte. So, “<span class=SpellE>abba</span>” will be
represented as five bytes with values: ‘a’, ‘b’, ‘b’, ‘a’ and 0, where for
example ‘a’ is the ASCII code for the character a. So, if in C we write:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span class=GramE>char</span> s[] = “<span class=SpellE>abba</span>”;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>In assembly we would write:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>.data</p>

<p class=MsoPlainText><span class=GramE>s</span>:
.byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ‘a’, ‘b’, ‘b’, ‘a’, 0 # we are using single
quotes. If you copy-paste from this text replace all quote with single quotes.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>So, a string is really <span class=GramE>an</span> <span
class=SpellE>unidimensional</span> array. So, using just “s” we are effectively
referring to the address of its first element (same as &amp;<span class=GramE>s[</span>0]).
</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Alternatively we can write:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>.data</p>

<p class=MsoPlainText><span class=GramE>s</span>:<span style='mso-tab-count:
1'>    </span>.string<span style='mso-tab-count:1'>     </span>“<span
class=SpellE>abba</span>”<span style='mso-tab-count:1'>      </span># We are
using double-quotes. If you copy-paste convert all to double-quotes.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>This is exactly equivalent. It does allocate the
terminating zero.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>The function palindrome will have the following
interface:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span class=SpellE><span class=GramE>int</span></span></p>

<p class=MsoPlainText><span class=GramE>palindrome</span> (char *a)</p>

<p class=MsoPlainText>{</p>

<p class=MsoPlainText>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Hence “a” will be a word whose value is the address where
the string starts at.</p>

<p class=MsoPlainText>Here’s an implementation of palindrome in C:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span class=SpellE><span class=GramE>int</span></span></p>

<p class=MsoPlainText><span class=GramE>palindrome</span> (char *a) </p>

<p class=MsoPlainText>{</p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=GramE>char</span>
*e;</p>

<p class=MsoPlainText style='text-indent:12.0pt'><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=GramE>if</span> (a
== NULL) return 1;&nbsp;&nbsp;&nbsp; // NULL string is a palindrome (we define
this)</p>

<p class=MsoPlainText style='text-indent:12.0pt'>e = a;</p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=GramE>while</span>
(*e != 0)
e++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// find the terminating zero</p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=GramE>if</span> (e
== a) return 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // empty string (just a
terminating zero) is a palindrome</p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=GramE>e--</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// point to the last character</p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=GramE>while</span>
((*a != 0) &amp;&amp; (*a == *e))</p>

<p class=MsoPlainText style='text-indent:12.0pt'>{</p>

<p class=MsoPlainText style='text-indent:12.0pt'>&nbsp;&nbsp;&nbsp; <span
class=GramE>a</span>++;</p>

<p class=MsoPlainText style='text-indent:12.0pt'>&nbsp;&nbsp;&nbsp; <span
class=GramE>e--</span>;</p>

<p class=MsoPlainText style='text-indent:12.0pt'>}</p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=GramE>if</span>
(*a == 0) return 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // is a palindrome</p>

<p class=MsoPlainText style='text-indent:12.0pt'><span class=GramE>return</span>
0;</p>

<p class=MsoPlainText>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Here’s the implementation where we initially ignore
saving/restoring registers and the actual distance of parameters from the top
of the stack:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>.text</p>

<p class=MsoPlainText><span class=GramE>palindrome</span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>beq</span></span><span style='mso-tab-count:
1'>   </span>r4, r0, ret1</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=GramE>add</span><span style='mso-tab-count:1'>   </span>r8, r4, r0<span
style='mso-tab-count:2'>        </span># a is in r4, e = a <span
style='font-family:Wingdings;mso-ascii-font-family:"Courier New";mso-hansi-font-family:
"Courier New";mso-char-type:symbol;mso-symbol-font-family:Wingdings'><span
style='mso-char-type:symbol;mso-symbol-font-family:Wingdings'>&agrave;</span></span>
r8 = r4</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span># while (*<span
class=GramE>e !</span>= 0) e++</p>

<p class=MsoPlainText><span class=SpellE><span class=GramE>findzero</span></span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>ldb</span></span><span
style='mso-spacerun:yes'>  </span><span style='mso-tab-count:1'> </span>r9,
0(r8)<span style='mso-tab-count:2'>         </span># read *e and check if zero</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>beq<span
style='mso-tab-count:1'>   </span>r9, r0, <span class=SpellE>foundzero</span></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>addi</span></span><span style='mso-tab-count:
1'>  </span>r8, r8, 1<span style='mso-tab-count:2'>         </span># *e
non-zero move to the next byte</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>br</span></span><span style='mso-tab-count:1'>    </span><span
class=SpellE>findzero</span></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span class=SpellE><span class=GramE>foundzero</span></span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>beq</span></span><span style='mso-tab-count:
1'>   </span>r8, r4, ret1<span style='mso-tab-count:1'>      </span># if (e ==
a) return 1</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>subi</span></span><span style='mso-tab-count:
1'>  </span>r8, r8, 1<span style='mso-tab-count:2'>         </span># e = e -1</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span class=SpellE><span class=GramE>cmploop</span></span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>ldb</span></span> <span style='mso-tab-count:
1'>  </span>r9, 0(r8)<span style='mso-tab-count:2'>         </span># if not *a
!= 0 exit the loop</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>beq</span></span><span style='mso-tab-count:
1'>   </span>r9, r0, after</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>ldb</span></span> <span style='mso-tab-count:
1'>  </span>r10, 0(r4)<span style='mso-tab-count:2'>        </span># if not *a
== *e exit the loop</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>bne</span></span><span style='mso-tab-count:
1'>   </span>r9, r10, after</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>addi</span></span><span style='mso-tab-count:
1'>  </span>r4, r4, 1<span style='mso-tab-count:1'>   </span><span
style='mso-tab-count:1'>      </span># a++</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>subi</span></span><span style='mso-tab-count:
1'>  </span>r8, r8, 1<span style='mso-tab-count:2'>         </span># e—</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>br</span></span> <span style='mso-tab-count:
1'>   </span><span class=SpellE>cmploop</span></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span class=GramE>after</span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE>ldb</span> <span style='mso-tab-count:1'>  </span>r9, 0(r4) <span
style='mso-tab-count:2'>        </span># if (*a == 0) return 1</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>beq</span></span><span style='mso-tab-count:
1'>   </span>r9, r0, ret1</p>

<p class=MsoPlainText>ret0:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=GramE>add</span><span style='mso-tab-count:1'>   </span>r2, r0, r0<span
style='mso-tab-count:2'>        </span># not found return 0</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>br</span></span><span style='mso-tab-count:1'>    </span>epilogue</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>ret1:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>addi</span></span><span style='mso-tab-count:
1'>  </span>r2, r0, 1<span style='mso-tab-count:2'>         </span># found
return 1</p>

<p class=MsoPlainText><span class=GramE>epilogue</span>:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText style='text-indent:.5in'><span class=GramE>ret</span></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>This is not the best possible palindrome implementation.
Our goal is to show one that works and focus on the assembly implementation.</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Here’s a main function that calls palindrome with s as
the argument:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>.text</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>.<span
class=SpellE>globl</span> main</p>

<p class=MsoPlainText><span class=GramE>main</span>:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=SpellE><span class=GramE>movia</span></span><span style='mso-tab-count:
1'> </span>r4, s</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
class=GramE>call</span><span style='mso-tab-count:1'>  </span>palindrome</p>

</div>

</body>

</html>
